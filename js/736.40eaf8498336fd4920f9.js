/*! For license information please see 736.40eaf8498336fd4920f9.js.LICENSE.txt */
(self.webpackChunk = self.webpackChunk || []).push([
  [736],
  {
    9720: (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        vi: () => StatusCodes,
        _3: () => TransportStatusError,
        Ay: () => lib_es_Transport,
      });
      var __webpack_exports__ = __webpack_require__(6827),
        events_default = __webpack_require__.n(__webpack_exports__);
      const errorClasses = {},
        deserializers = {};
      const createCustomErrorClass = (name) => {
        class CustomErrorClass extends Error {
          constructor(message, fields, options) {
            if (
              (super(message || name, options),
              Object.setPrototypeOf(this, CustomErrorClass.prototype),
              (this.name = name),
              fields)
            )
              for (const k in fields) this[k] = fields[k];
            options &&
              (function isObject(value) {
                return "object" == typeof value;
              })(options) &&
              "cause" in options &&
              !("cause" in this) &&
              ((message = options.cause), "stack" in (this.cause = message)) &&
              (this.stack = this.stack + "\nCAUSE: " + message.stack);
          }
        }
        return (errorClasses[name] = CustomErrorClass);
      };
      createCustomErrorClass("AccountNameRequired"),
        createCustomErrorClass("AccountNotSupported"),
        createCustomErrorClass("AmountRequired"),
        createCustomErrorClass("BluetoothRequired"),
        createCustomErrorClass("BtcUnmatchedApp"),
        createCustomErrorClass("CantOpenDevice"),
        createCustomErrorClass("CashAddrNotSupported"),
        createCustomErrorClass("ClaimRewardsFeesWarning"),
        createCustomErrorClass("CurrencyNotSupported"),
        createCustomErrorClass("DeviceAppVerifyNotSupported"),
        createCustomErrorClass("DeviceGenuineSocketEarlyClose"),
        createCustomErrorClass("DeviceNotGenuine"),
        createCustomErrorClass("DeviceOnDashboardExpected"),
        createCustomErrorClass("DeviceOnDashboardUnexpected"),
        createCustomErrorClass("DeviceInOSUExpected"),
        createCustomErrorClass("DeviceHalted"),
        createCustomErrorClass("DeviceNameInvalid"),
        createCustomErrorClass("DeviceSocketFail"),
        createCustomErrorClass("DeviceSocketNoBulkStatus"),
        createCustomErrorClass("DeviceSocketNoBulkStatus"),
        createCustomErrorClass("UnresponsiveDeviceError"),
        createCustomErrorClass("DisconnectedDevice"),
        createCustomErrorClass("DisconnectedDeviceDuringOperation"),
        createCustomErrorClass("DeviceExtractOnboardingStateError"),
        createCustomErrorClass("DeviceOnboardingStatePollingError"),
        createCustomErrorClass("EnpointConfig"),
        createCustomErrorClass("EthAppPleaseEnableContractData"),
        createCustomErrorClass("FeeEstimationFailed"),
        createCustomErrorClass("FirmwareNotRecognized"),
        createCustomErrorClass("HardResetFail"),
        createCustomErrorClass("InvalidXRPTag"),
        createCustomErrorClass("InvalidAddress"),
        createCustomErrorClass("InvalidNonce"),
        createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource"),
        createCustomErrorClass("LatestMCUInstalledError"),
        createCustomErrorClass("UnknownMCU"),
        createCustomErrorClass("LedgerAPIError"),
        createCustomErrorClass("LedgerAPIErrorWithMessage"),
        createCustomErrorClass("LedgerAPINotAvailable"),
        createCustomErrorClass("ManagerAppAlreadyInstalled"),
        createCustomErrorClass("ManagerAppRelyOnBTC"),
        createCustomErrorClass("ManagerAppDepInstallRequired"),
        createCustomErrorClass("ManagerAppDepUninstallRequired"),
        createCustomErrorClass("ManagerDeviceLocked"),
        createCustomErrorClass("ManagerFirmwareNotEnoughSpace"),
        createCustomErrorClass("ManagerNotEnoughSpace"),
        createCustomErrorClass("ManagerUninstallBTCDep"),
        createCustomErrorClass("NetworkDown"),
        createCustomErrorClass("NetworkError"),
        createCustomErrorClass("NoAddressesFound"),
        createCustomErrorClass("NotEnoughBalance"),
        createCustomErrorClass("NotEnoughBalanceToDelegate"),
        createCustomErrorClass("NotEnoughBalanceInParentAccount"),
        createCustomErrorClass("NotEnoughSpendableBalance"),
        createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated"),
        createCustomErrorClass("NoAccessToCamera"),
        createCustomErrorClass("NotEnoughGas"),
        createCustomErrorClass("NotEnoughGasSwap"),
        createCustomErrorClass("NotSupportedLegacyAddress"),
        createCustomErrorClass("GasLessThanEstimate"),
        createCustomErrorClass("PriorityFeeTooLow"),
        createCustomErrorClass("PriorityFeeTooHigh"),
        createCustomErrorClass("PriorityFeeHigherThanMaxFee"),
        createCustomErrorClass("MaxFeeTooLow"),
        createCustomErrorClass("PasswordsDontMatch"),
        createCustomErrorClass("PasswordIncorrect"),
        createCustomErrorClass("RecommendSubAccountsToEmpty"),
        createCustomErrorClass("RecommendUndelegation"),
        createCustomErrorClass("TimeoutTagged"),
        createCustomErrorClass("UnexpectedBootloader"),
        createCustomErrorClass("MCUNotGenuineToDashboard"),
        createCustomErrorClass("RecipientRequired"),
        createCustomErrorClass("UnavailableTezosOriginatedAccountReceive"),
        createCustomErrorClass("UnavailableTezosOriginatedAccountSend"),
        createCustomErrorClass("UpdateFetchFileFail"),
        createCustomErrorClass("UpdateIncorrectHash"),
        createCustomErrorClass("UpdateIncorrectSig"),
        createCustomErrorClass("UpdateYourApp"),
        createCustomErrorClass("UserRefusedDeviceNameChange"),
        createCustomErrorClass("UserRefusedAddress"),
        createCustomErrorClass("UserRefusedFirmwareUpdate"),
        createCustomErrorClass("UserRefusedAllowManager"),
        createCustomErrorClass("UserRefusedOnDevice"),
        createCustomErrorClass("ExpertModeRequired"),
        createCustomErrorClass("TransportOpenUserCancelled"),
        createCustomErrorClass("TransportInterfaceNotAvailable");
      const TransportRaceCondition = createCustomErrorClass(
        "TransportRaceCondition"
      );
      createCustomErrorClass("TransportWebUSBGestureRequired"),
        createCustomErrorClass("TransactionHasBeenValidatedError"),
        createCustomErrorClass("TransportExchangeTimeoutError"),
        createCustomErrorClass("DeviceShouldStayInApp"),
        createCustomErrorClass("WebsocketConnectionError"),
        createCustomErrorClass("WebsocketConnectionFailed"),
        createCustomErrorClass("WrongDeviceForAccount"),
        createCustomErrorClass("WrongAppForCurrency"),
        createCustomErrorClass("ETHAddressNonEIP"),
        createCustomErrorClass("CantScanQRCode"),
        createCustomErrorClass("FeeNotLoaded"),
        createCustomErrorClass("FeeNotLoadedSwap"),
        createCustomErrorClass("FeeRequired"),
        createCustomErrorClass("FeeTooHigh"),
        createCustomErrorClass("PendingOperation"),
        createCustomErrorClass("SyncError"),
        createCustomErrorClass("PairingFailed"),
        createCustomErrorClass("PeerRemovedPairing"),
        createCustomErrorClass("GenuineCheckFailed"),
        createCustomErrorClass("LedgerAPI4xx"),
        createCustomErrorClass("LedgerAPI5xx"),
        createCustomErrorClass("FirmwareOrAppUpdateRequired"),
        createCustomErrorClass("ReplacementTransactionUnderpriced"),
        createCustomErrorClass("OpReturnSizeLimit"),
        createCustomErrorClass("DustLimit"),
        createCustomErrorClass("LanguageNotFound"),
        createCustomErrorClass("NoDBPathGiven"),
        createCustomErrorClass("DBWrongPassword"),
        createCustomErrorClass("DBNotReset");
      !(function (HwTransportErrorType) {
        (HwTransportErrorType.Unknown = "Unknown"),
          (HwTransportErrorType.LocationServicesDisabled =
            "LocationServicesDisabled"),
          (HwTransportErrorType.LocationServicesUnauthorized =
            "LocationServicesUnauthorized"),
          (HwTransportErrorType.BluetoothScanStartFailed =
            "BluetoothScanStartFailed");
      })({});
      (class extends Error {});
      class TransportError extends Error {
        constructor(message, id) {
          var name = "TransportError";
          super(message || name),
            (this.name = name),
            (this.message = message),
            (this.stack = new Error(message).stack),
            (this.id = id);
        }
      }
      deserializers.TransportError = (e) => new TransportError(e.message, e.id);
      const StatusCodes = {
        ACCESS_CONDITION_NOT_FULFILLED: 38916,
        ALGORITHM_NOT_SUPPORTED: 38020,
        CLA_NOT_SUPPORTED: 28160,
        CODE_BLOCKED: 38976,
        CODE_NOT_INITIALIZED: 38914,
        COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
        CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
        CONTRADICTION_INVALIDATION: 38928,
        CONTRADICTION_SECRET_CODE_STATUS: 38920,
        CUSTOM_IMAGE_BOOTLOADER: 26159,
        CUSTOM_IMAGE_EMPTY: 26158,
        FILE_ALREADY_EXISTS: 27273,
        FILE_NOT_FOUND: 37892,
        GP_AUTH_FAILED: 25344,
        HALTED: 28586,
        INCONSISTENT_FILE: 37896,
        INCORRECT_DATA: 27264,
        INCORRECT_LENGTH: 26368,
        INCORRECT_P1_P2: 27392,
        INS_NOT_SUPPORTED: 27904,
        DEVICE_NOT_ONBOARDED: 27911,
        DEVICE_NOT_ONBOARDED_2: 26129,
        INVALID_KCV: 38021,
        INVALID_OFFSET: 37890,
        LICENSING: 28482,
        LOCKED_DEVICE: 21781,
        MAX_VALUE_REACHED: 38992,
        MEMORY_PROBLEM: 37440,
        MISSING_CRITICAL_PARAMETER: 26624,
        NO_EF_SELECTED: 37888,
        NOT_ENOUGH_MEMORY_SPACE: 27268,
        OK: 36864,
        PIN_REMAINING_ATTEMPTS: 25536,
        REFERENCED_DATA_NOT_FOUND: 27272,
        SECURITY_STATUS_NOT_SATISFIED: 27010,
        TECHNICAL_PROBLEM: 28416,
        UNKNOWN_APDU: 27906,
        USER_REFUSED_ON_DEVICE: 21761,
        NOT_ENOUGH_SPACE: 20738,
      };
      class TransportStatusError extends Error {
        constructor(statusCode, { canBeMappedToChildError = !0 } = {}) {
          var statusText =
              Object.keys(StatusCodes).find(
                (k) => StatusCodes[k] === statusCode
              ) || "UNKNOWN_ERROR",
            message = `Ledger device: ${
              (function getAltStatusMessage(code) {
                switch (code) {
                  case 26368:
                    return "Incorrect length";
                  case 26624:
                    return "Missing critical parameter";
                  case 27010:
                    return "Security not satisfied (dongle locked or have invalid access rights)";
                  case 27013:
                    return "Condition of use not satisfied (denied by the user?)";
                  case 27264:
                    return "Invalid data received";
                  case 27392:
                    return "Invalid parameter received";
                  case 21781:
                    return "Locked device";
                }
                if (28416 <= code && code <= 28671)
                  return "Internal error, please report";
              })(statusCode) || statusText
            } (0x${statusCode.toString(16)})`;
          if (
            (super(message),
            (this.name = "TransportStatusError"),
            (this.statusCode = statusCode),
            (this.statusText = statusText),
            Object.setPrototypeOf(this, TransportStatusError.prototype),
            canBeMappedToChildError && statusCode === StatusCodes.LOCKED_DEVICE)
          )
            return new LockedDeviceError(message);
        }
      }
      class LockedDeviceError extends TransportStatusError {
        constructor(message) {
          super(StatusCodes.LOCKED_DEVICE, { canBeMappedToChildError: !1 }),
            message && (this.message = message),
            (this.name = "LockedDeviceError"),
            Object.setPrototypeOf(this, LockedDeviceError.prototype);
        }
      }
      deserializers.TransportStatusError = (e) =>
        new TransportStatusError(e.statusCode);
      var __awaiter = function (thisArg, _arguments, P, generator) {
          return new (P = P || Promise)(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : (function adopt(value) {
                    return value instanceof P
                      ? value
                      : new P(function (resolve) {
                          resolve(value);
                        });
                  })(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            );
          });
        },
        __generator = function (thisArg, body) {
          var f,
            y,
            t,
            _ = {
              label: 0,
              sent: function () {
                if (1 & t[0]) throw t[1];
                return t[1];
              },
              trys: [],
              ops: [],
            },
            g = { next: verb(0), throw: verb(1), return: verb(2) };
          return (
            "function" == typeof Symbol &&
              (g[Symbol.iterator] = function () {
                return this;
              }),
            g
          );
          function verb(n) {
            return function (v) {
              return (function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                for (; _; )
                  try {
                    if (
                      ((f = 1),
                      y &&
                        (t =
                          2 & op[0]
                            ? y.return
                            : op[0]
                            ? y.throw || ((t = y.return) && t.call(y), 0)
                            : y.next) &&
                        !(t = t.call(y, op[1])).done)
                    )
                      return t;
                    switch (
                      ((y = 0), (op = t ? [2 & op[0], t.value] : op)[0])
                    ) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        return _.label++, { value: op[1], done: !1 };
                      case 5:
                        _.label++, (y = op[1]), (op = [0]);
                        continue;
                      case 7:
                        (op = _.ops.pop()), _.trys.pop();
                        continue;
                      default:
                        if (
                          !(t = 0 < (t = _.trys).length && t[t.length - 1]) &&
                          (6 === op[0] || 2 === op[0])
                        ) {
                          _ = 0;
                          continue;
                        }
                        if (
                          3 === op[0] &&
                          (!t || (op[1] > t[0] && op[1] < t[3]))
                        )
                          _.label = op[1];
                        else if (6 === op[0] && _.label < t[1])
                          (_.label = t[1]), (t = op);
                        else {
                          if (!(t && _.label < t[2])) {
                            t[2] && _.ops.pop(), _.trys.pop();
                            continue;
                          }
                          (_.label = t[2]), _.ops.push(op);
                        }
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    (op = [6, e]), (y = 0);
                  } finally {
                    f = t = 0;
                  }
                if (5 & op[0]) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: !0 };
              })([n, v]);
            };
          }
        },
        __read = function (o, n) {
          var m = "function" == typeof Symbol && o[Symbol.iterator];
          if (!m) return o;
          var r,
            e,
            i = m.call(o),
            ar = [];
          try {
            for (; (void 0 === n || 0 < n--) && !(r = i.next()).done; )
              ar.push(r.value);
          } catch (error) {
            e = { error: error };
          } finally {
            try {
              r && !r.done && (m = i.return) && m.call(i);
            } finally {
              if (e) throw e.error;
            }
          }
          return ar;
        },
        __spreadArray = function (to, from, pack) {
          if (pack || 2 === arguments.length)
            for (var ar, i = 0, l = from.length; i < l; i++)
              (!ar && i in from) ||
                ((ar = ar || Array.prototype.slice.call(from, 0, i))[i] =
                  from[i]);
          return to.concat(ar || Array.prototype.slice.call(from));
        },
        __values = function (o) {
          var s = "function" == typeof Symbol && Symbol.iterator,
            m = s && o[s],
            i = 0;
          if (m) return m.call(o);
          if (o && "number" == typeof o.length)
            return {
              next: function () {
                return {
                  value: (o = o && i >= o.length ? void 0 : o) && o[i++],
                  done: !o,
                };
              },
            };
          throw new TypeError(
            s ? "Object is not iterable." : "Symbol.iterator is not defined."
          );
        };
      const lib_es_Transport = (function () {
        function Transport() {
          var _this = this;
          (this.exchangeTimeout = 3e4),
            (this.unresponsiveTimeout = 15e3),
            (this.deviceModel = null),
            (this._events = new (events_default())()),
            (this.send = function (cla, ins, p1, p2, data, statusList) {
              return (
                void 0 === data && (data = Buffer.alloc(0)),
                void 0 === statusList && (statusList = [StatusCodes.OK]),
                __awaiter(_this, void 0, void 0, function () {
                  var response, sw;
                  return __generator(this, function (_a) {
                    switch (_a.label) {
                      case 0:
                        if (256 <= data.length)
                          throw new TransportError(
                            "data.length exceed 256 bytes limit. Got: " +
                              data.length,
                            "DataLengthTooBig"
                          );
                        return [
                          4,
                          this.exchange(
                            Buffer.concat([
                              Buffer.from([cla, ins, p1, p2]),
                              Buffer.from([data.length]),
                              data,
                            ])
                          ),
                        ];
                      case 1:
                        if (
                          ((response = _a.sent()),
                          (sw = response.readUInt16BE(response.length - 2)),
                          statusList.some(function (s) {
                            return s === sw;
                          }))
                        )
                          return [2, response];
                        throw new TransportStatusError(sw);
                    }
                  });
                })
              );
            }),
            (this.exchangeAtomicImpl = function (f) {
              return __awaiter(_this, void 0, void 0, function () {
                var resolveBusy,
                  unresponsiveReached,
                  busyPromise,
                  res,
                  _this = this;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if (this.exchangeBusyPromise)
                        throw new TransportRaceCondition(
                          "An action was already pending on the Ledger device. Please deny or reconnect."
                        );
                      (busyPromise = new Promise(function (r) {
                        resolveBusy = r;
                      })),
                        (this.exchangeBusyPromise = busyPromise),
                        (unresponsiveReached = !1),
                        (busyPromise = setTimeout(function () {
                          (unresponsiveReached = !0),
                            _this.emit("unresponsive");
                        }, this.unresponsiveTimeout)),
                        (_a.label = 1);
                    case 1:
                      return _a.trys.push([1, , 3, 4]), [4, f()];
                    case 2:
                      return (
                        (res = _a.sent()),
                        unresponsiveReached && this.emit("responsive"),
                        [2, res]
                      );
                    case 3:
                      return (
                        clearTimeout(busyPromise),
                        resolveBusy && resolveBusy(),
                        (this.exchangeBusyPromise = null),
                        [7]
                      );
                    case 4:
                      return [2];
                  }
                });
              });
            }),
            (this._appAPIlock = null);
        }
        return (
          (Transport.prototype.exchange = function (_apdu) {
            throw new Error("exchange not implemented");
          }),
          (Transport.prototype.setScrambleKey = function (_key) {}),
          (Transport.prototype.close = function () {
            return Promise.resolve();
          }),
          (Transport.prototype.on = function (eventName, cb) {
            this._events.on(eventName, cb);
          }),
          (Transport.prototype.off = function (eventName, cb) {
            this._events.removeListener(eventName, cb);
          }),
          (Transport.prototype.emit = function (event) {
            for (var _a, args = [], _i = 1; _i < arguments.length; _i++)
              args[_i - 1] = arguments[_i];
            (_a = this._events).emit.apply(
              _a,
              __spreadArray([event], __read(args), !1)
            );
          }),
          (Transport.prototype.setDebugMode = function () {
            console.warn(
              "setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore."
            );
          }),
          (Transport.prototype.setExchangeTimeout = function (exchangeTimeout) {
            this.exchangeTimeout = exchangeTimeout;
          }),
          (Transport.prototype.setExchangeUnresponsiveTimeout = function (
            unresponsiveTimeout
          ) {
            this.unresponsiveTimeout = unresponsiveTimeout;
          }),
          (Transport.create = function (openTimeout, listenTimeout) {
            var _this = this;
            return (
              void 0 === openTimeout && (openTimeout = 3e3),
              new Promise(function (resolve, reject) {
                var found = !1,
                  sub = _this.listen({
                    next: function (e) {
                      (found = !0),
                        sub && sub.unsubscribe(),
                        listenTimeoutId && clearTimeout(listenTimeoutId),
                        _this
                          .open(e.descriptor, openTimeout)
                          .then(resolve, reject);
                    },
                    error: function (e) {
                      listenTimeoutId && clearTimeout(listenTimeoutId),
                        reject(e);
                    },
                    complete: function () {
                      listenTimeoutId && clearTimeout(listenTimeoutId),
                        found ||
                          reject(
                            new TransportError(
                              _this.ErrorMessage_NoDeviceFound,
                              "NoDeviceFound"
                            )
                          );
                    },
                  }),
                  listenTimeoutId = listenTimeout
                    ? setTimeout(function () {
                        sub.unsubscribe(),
                          reject(
                            new TransportError(
                              _this.ErrorMessage_ListenTimeout,
                              "ListenTimeout"
                            )
                          );
                      }, listenTimeout)
                    : null;
              })
            );
          }),
          (Transport.prototype.decorateAppAPIMethods = function (
            self,
            methods,
            scrambleKey
          ) {
            var e_1, _a;
            try {
              for (
                var methods_1 = __values(methods),
                  methods_1_1 = methods_1.next();
                !methods_1_1.done;
                methods_1_1 = methods_1.next()
              ) {
                var methodName = methods_1_1.value;
                self[methodName] = this.decorateAppAPIMethod(
                  methodName,
                  self[methodName],
                  self,
                  scrambleKey
                );
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                methods_1_1 &&
                  !methods_1_1.done &&
                  (_a = methods_1.return) &&
                  _a.call(methods_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }),
          (Transport.prototype.decorateAppAPIMethod = function (
            methodName,
            f,
            ctx,
            scrambleKey
          ) {
            var _this = this;
            return function () {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return __awaiter(_this, void 0, void 0, function () {
                var _appAPIlock;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if ((_appAPIlock = this._appAPIlock))
                        return [
                          2,
                          Promise.reject(
                            new TransportError(
                              "Ledger Device is busy (lock " +
                                _appAPIlock +
                                ")",
                              "TransportLocked"
                            )
                          ),
                        ];
                      _a.label = 1;
                    case 1:
                      return (
                        _a.trys.push([1, , 3, 4]),
                        (this._appAPIlock = methodName),
                        this.setScrambleKey(scrambleKey),
                        [4, f.apply(ctx, args)]
                      );
                    case 2:
                      return [2, _a.sent()];
                    case 3:
                      return (this._appAPIlock = null), [7];
                    case 4:
                      return [2];
                  }
                });
              });
            };
          }),
          (Transport.ErrorMessage_ListenTimeout =
            "No Ledger device found (timeout)"),
          (Transport.ErrorMessage_NoDeviceFound = "No Ledger device found"),
          Transport
        );
      })();
    },
    9829: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      (exports.I0 = exports.DH = exports.NX = exports.u8 = exports.cY = void 0),
        (exports.av = exports.O6 = exports.w3 = exports.Wg = void 0);
      const buffer_1 = __webpack_require__(8891);
      function checkUint8Array(b) {
        if (!(b instanceof Uint8Array))
          throw new TypeError("b must be a Uint8Array");
      }
      function uint8ArrayToBuffer(b) {
        return (
          checkUint8Array(b),
          buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length)
        );
      }
      class Layout {
        constructor(span, property) {
          if (!Number.isInteger(span))
            throw new TypeError("span must be an integer");
          (this.span = span), (this.property = property);
        }
        makeDestinationObject() {
          return {};
        }
        getSpan(b, offset) {
          if (this.span < 0) throw new RangeError("indeterminate span");
          return this.span;
        }
        replicate(property) {
          var rv = Object.create(this.constructor.prototype);
          return Object.assign(rv, this), (rv.property = property), rv;
        }
        fromArray(values) {}
      }
      function nameWithProperty(name, lo) {
        return lo.property ? name + "[" + lo.property + "]" : name;
      }
      Layout;
      class ExternalLayout extends Layout {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      }
      class GreedyCount extends ExternalLayout {
        constructor(elementSpan = 1, property) {
          if (!Number.isInteger(elementSpan) || elementSpan <= 0)
            throw new TypeError("elementSpan must be a (positive) integer");
          super(-1, property), (this.elementSpan = elementSpan);
        }
        isCount() {
          return !0;
        }
        decode(b, offset = 0) {
          checkUint8Array(b);
          b = b.length - offset;
          return Math.floor(b / this.elementSpan);
        }
        encode(src, b, offset) {
          return 0;
        }
      }
      GreedyCount;
      class OffsetLayout extends ExternalLayout {
        constructor(layout, offset = 0, property) {
          if (!(layout instanceof Layout))
            throw new TypeError("layout must be a Layout");
          if (!Number.isInteger(offset))
            throw new TypeError("offset must be integer or undefined");
          super(layout.span, property || layout.property),
            (this.layout = layout),
            (this.offset = offset);
        }
        isCount() {
          return this.layout instanceof UInt || this.layout instanceof UIntBE;
        }
        decode(b, offset = 0) {
          return this.layout.decode(b, offset + this.offset);
        }
        encode(src, b, offset = 0) {
          return this.layout.encode(src, b, offset + this.offset);
        }
      }
      OffsetLayout;
      class UInt extends Layout {
        constructor(span, property) {
          if ((super(span, property), 6 < this.span))
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
        }
        encode(src, b, offset = 0) {
          return (
            uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span), this.span
          );
        }
      }
      UInt;
      class UIntBE extends Layout {
        constructor(span, property) {
          if ((super(span, property), 6 < this.span))
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
        }
        encode(src, b, offset = 0) {
          return (
            uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span), this.span
          );
        }
      }
      UIntBE;
      class Int extends Layout {
        constructor(span, property) {
          if ((super(span, property), 6 < this.span))
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
        }
        encode(src, b, offset = 0) {
          return (
            uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span), this.span
          );
        }
      }
      Int;
      class IntBE extends Layout {
        constructor(span, property) {
          if ((super(span, property), 6 < this.span))
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
        }
        encode(src, b, offset = 0) {
          return (
            uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span), this.span
          );
        }
      }
      IntBE;
      const V2E32 = Math.pow(2, 32);
      function divmodInt64(src) {
        var hi32 = Math.floor(src / V2E32);
        return { hi32: hi32, lo32: src - hi32 * V2E32 };
      }
      function roundedInt64(hi32, lo32) {
        return hi32 * V2E32 + lo32;
      }
      class NearUInt64 extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          var b = uint8ArrayToBuffer(b),
            lo32 = b.readUInt32LE(offset);
          return roundedInt64(b.readUInt32LE(offset + 4), lo32);
        }
        encode(src, b, offset = 0) {
          (src = divmodInt64(src)), (b = uint8ArrayToBuffer(b));
          return (
            b.writeUInt32LE(src.lo32, offset),
            b.writeUInt32LE(src.hi32, offset + 4),
            8
          );
        }
      }
      NearUInt64;
      class NearUInt64BE extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          b = uint8ArrayToBuffer(b);
          return roundedInt64(
            b.readUInt32BE(offset),
            b.readUInt32BE(offset + 4)
          );
        }
        encode(src, b, offset = 0) {
          (src = divmodInt64(src)), (b = uint8ArrayToBuffer(b));
          return (
            b.writeUInt32BE(src.hi32, offset),
            b.writeUInt32BE(src.lo32, offset + 4),
            8
          );
        }
      }
      NearUInt64BE;
      class NearInt64 extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          var b = uint8ArrayToBuffer(b),
            lo32 = b.readUInt32LE(offset);
          return roundedInt64(b.readInt32LE(offset + 4), lo32);
        }
        encode(src, b, offset = 0) {
          (src = divmodInt64(src)), (b = uint8ArrayToBuffer(b));
          return (
            b.writeUInt32LE(src.lo32, offset),
            b.writeInt32LE(src.hi32, offset + 4),
            8
          );
        }
      }
      NearInt64;
      class NearInt64BE extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          b = uint8ArrayToBuffer(b);
          return roundedInt64(
            b.readInt32BE(offset),
            b.readUInt32BE(offset + 4)
          );
        }
        encode(src, b, offset = 0) {
          (src = divmodInt64(src)), (b = uint8ArrayToBuffer(b));
          return (
            b.writeInt32BE(src.hi32, offset),
            b.writeUInt32BE(src.lo32, offset + 4),
            8
          );
        }
      }
      NearInt64BE;
      class Float extends Layout {
        constructor(property) {
          super(4, property);
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readFloatLE(offset);
        }
        encode(src, b, offset = 0) {
          return uint8ArrayToBuffer(b).writeFloatLE(src, offset), 4;
        }
      }
      Float;
      class FloatBE extends Layout {
        constructor(property) {
          super(4, property);
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readFloatBE(offset);
        }
        encode(src, b, offset = 0) {
          return uint8ArrayToBuffer(b).writeFloatBE(src, offset), 4;
        }
      }
      FloatBE;
      class Double extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readDoubleLE(offset);
        }
        encode(src, b, offset = 0) {
          return uint8ArrayToBuffer(b).writeDoubleLE(src, offset), 8;
        }
      }
      Double;
      class DoubleBE extends Layout {
        constructor(property) {
          super(8, property);
        }
        decode(b, offset = 0) {
          return uint8ArrayToBuffer(b).readDoubleBE(offset);
        }
        encode(src, b, offset = 0) {
          return uint8ArrayToBuffer(b).writeDoubleBE(src, offset), 8;
        }
      }
      DoubleBE;
      class Sequence extends Layout {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout))
            throw new TypeError("elementLayout must be a Layout");
          if (
            !(
              (count instanceof ExternalLayout && count.isCount()) ||
              (Number.isInteger(count) && 0 <= count)
            )
          )
            throw new TypeError(
              "count must be non-negative integer or an unsigned integer ExternalLayout"
            );
          let span = -1;
          super(
            (span =
              !(count instanceof ExternalLayout) && 0 < elementLayout.span
                ? count * elementLayout.span
                : span),
            property
          ),
            (this.elementLayout = elementLayout),
            (this.count = count);
        }
        getSpan(b, offset = 0) {
          if (0 <= this.span) return this.span;
          let span = 0,
            count = this.count;
          if (
            (count instanceof ExternalLayout &&
              (count = count.decode(b, offset)),
            0 < this.elementLayout.span)
          )
            span = count * this.elementLayout.span;
          else {
            let idx = 0;
            for (; idx < count; )
              (span += this.elementLayout.getSpan(b, offset + span)), ++idx;
          }
          return span;
        }
        decode(b, offset = 0) {
          var rv = [];
          let i = 0,
            count = this.count;
          for (
            count instanceof ExternalLayout &&
            (count = count.decode(b, offset));
            i < count;

          )
            rv.push(this.elementLayout.decode(b, offset)),
              (offset += this.elementLayout.getSpan(b, offset)),
              (i += 1);
          return rv;
        }
        encode(src, b, offset = 0) {
          const elo = this.elementLayout;
          var span = src.reduce(
            (span, v) => span + elo.encode(v, b, offset + span),
            0
          );
          return (
            this.count instanceof ExternalLayout &&
              this.count.encode(src.length, b, offset),
            span
          );
        }
      }
      Sequence;
      class Structure extends Layout {
        constructor(fields, property, decodePrefixes) {
          if (
            !Array.isArray(fields) ||
            !fields.reduce((acc, v) => acc && v instanceof Layout, !0)
          )
            throw new TypeError("fields must be array of Layout instances");
          "boolean" == typeof property &&
            void 0 === decodePrefixes &&
            ((decodePrefixes = property), (property = void 0));
          for (const fd of fields)
            if (fd.span < 0 && void 0 === fd.property)
              throw new Error(
                "fields cannot contain unnamed variable-length layout"
              );
          let span = -1;
          try {
            span = fields.reduce((span, fd) => span + fd.getSpan(), 0);
          } catch (e) {}
          super(span, property),
            (this.fields = fields),
            (this.decodePrefixes = !!decodePrefixes);
        }
        getSpan(b, offset = 0) {
          if (0 <= this.span) return this.span;
          let span = 0;
          try {
            span = this.fields.reduce((span, fd) => {
              fd = fd.getSpan(b, offset);
              return (offset += fd), span + fd;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        decode(b, offset = 0) {
          checkUint8Array(b);
          var dest = this.makeDestinationObject();
          for (const fd of this.fields)
            if (
              (void 0 !== fd.property &&
                (dest[fd.property] = fd.decode(b, offset)),
              (offset += fd.getSpan(b, offset)),
              this.decodePrefixes && b.length === offset)
            )
              break;
          return dest;
        }
        encode(src, b, offset = 0) {
          var fv,
            firstOffset = offset;
          let lastOffset = 0,
            lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            (lastWrote = 0 < span ? span : 0),
              void 0 !== fd.property &&
                void 0 !== (fv = src[fd.property]) &&
                ((lastWrote = fd.encode(fv, b, offset)), span < 0) &&
                (span = fd.getSpan(b, offset)),
              (lastOffset = offset),
              (offset += span);
          }
          return lastOffset + lastWrote - firstOffset;
        }
        fromArray(values) {
          var dest = this.makeDestinationObject();
          for (const fd of this.fields)
            void 0 !== fd.property &&
              0 < values.length &&
              (dest[fd.property] = values.shift());
          return dest;
        }
        layoutFor(property) {
          if ("string" != typeof property)
            throw new TypeError("property must be string");
          for (const fd of this.fields) if (fd.property === property) return fd;
        }
        offsetOf(property) {
          if ("string" != typeof property)
            throw new TypeError("property must be string");
          let offset = 0;
          for (const fd of this.fields) {
            if (fd.property === property) return offset;
            fd.span < 0 ? (offset = -1) : 0 <= offset && (offset += fd.span);
          }
        }
      }
      Structure;
      class UnionDiscriminator {
        constructor(property) {
          this.property = property;
        }
        decode(b, offset) {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode(src, b, offset) {
          throw new Error("UnionDiscriminator is abstract");
        }
      }
      class UnionLayoutDiscriminator extends UnionDiscriminator {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout && layout.isCount()))
            throw new TypeError(
              "layout must be an unsigned integer ExternalLayout"
            );
          super(property || layout.property || "variant"),
            (this.layout = layout);
        }
        decode(b, offset) {
          return this.layout.decode(b, offset);
        }
        encode(src, b, offset) {
          return this.layout.encode(src, b, offset);
        }
      }
      UnionLayoutDiscriminator;
      class Union extends Layout {
        constructor(discr, defaultLayout, property) {
          let discriminator;
          if (discr instanceof UInt || discr instanceof UIntBE)
            discriminator = new UnionLayoutDiscriminator(
              new OffsetLayout(discr)
            );
          else if (discr instanceof ExternalLayout && discr.isCount())
            discriminator = new UnionLayoutDiscriminator(discr);
          else {
            if (!(discr instanceof UnionDiscriminator))
              throw new TypeError(
                "discr must be a UnionDiscriminator or an unsigned integer layout"
              );
            discriminator = discr;
          }
          if (
            !(
              null ===
                (defaultLayout =
                  void 0 === defaultLayout ? null : defaultLayout) ||
              defaultLayout instanceof Layout
            )
          )
            throw new TypeError("defaultLayout must be null or a Layout");
          if (null !== defaultLayout) {
            if (defaultLayout.span < 0)
              throw new Error("defaultLayout must have constant span");
            void 0 === defaultLayout.property &&
              (defaultLayout = defaultLayout.replicate("content"));
          }
          let span = -1,
            boundGetSourceVariant =
              (defaultLayout &&
                0 <= (span = defaultLayout.span) &&
                (discr instanceof UInt || discr instanceof UIntBE) &&
                (span += discriminator.layout.span),
              super(span, property),
              (this.discriminator = discriminator),
              (this.usesPrefixDiscriminator =
                discr instanceof UInt || discr instanceof UIntBE),
              (this.defaultLayout = defaultLayout),
              (this.registry = {}),
              this.defaultGetSourceVariant.bind(this));
          (this.getSourceVariant = function (src) {
            return boundGetSourceVariant(src);
          }),
            (this.configGetSourceVariant = function (gsv) {
              boundGetSourceVariant = gsv.bind(this);
            });
        }
        getSpan(b, offset = 0) {
          if (0 <= this.span) return this.span;
          var vlo = this.getVariant(b, offset);
          if (vlo) return vlo.getSpan(b, offset);
          throw new Error("unable to determine span for unrecognized variant");
        }
        defaultGetSourceVariant(src) {
          if (
            Object.prototype.hasOwnProperty.call(
              src,
              this.discriminator.property
            )
          ) {
            if (
              this.defaultLayout &&
              this.defaultLayout.property &&
              Object.prototype.hasOwnProperty.call(
                src,
                this.defaultLayout.property
              )
            )
              return;
            var vlo = this.registry[src[this.discriminator.property]];
            if (
              vlo &&
              (!vlo.layout ||
                (vlo.property &&
                  Object.prototype.hasOwnProperty.call(src, vlo.property)))
            )
              return vlo;
          } else
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (
                vlo.property &&
                Object.prototype.hasOwnProperty.call(src, vlo.property)
              )
                return vlo;
            }
          throw new Error("unable to infer src variant");
        }
        decode(b, offset = 0) {
          let dest;
          var dlo = this.discriminator,
            discr = dlo.decode(b, offset),
            clo = this.registry[discr];
          if (void 0 === clo) {
            var defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            this.usesPrefixDiscriminator && (contentOffset = dlo.layout.span),
              ((dest = this.makeDestinationObject())[dlo.property] = discr),
              (dest[defaultLayout.property] = defaultLayout.decode(
                b,
                offset + contentOffset
              ));
          } else dest = clo.decode(b, offset);
          return dest;
        }
        encode(src, b, offset = 0) {
          var vlo = this.getSourceVariant(src);
          if (void 0 !== vlo) return vlo.encode(src, b, offset);
          {
            var vlo = this.discriminator,
              clo = this.defaultLayout;
            let contentOffset = 0;
            return (
              this.usesPrefixDiscriminator && (contentOffset = vlo.layout.span),
              vlo.encode(src[vlo.property], b, offset),
              contentOffset +
                clo.encode(src[clo.property], b, offset + contentOffset)
            );
          }
        }
        addVariant(variant, layout, property) {
          layout = new VariantLayout(this, variant, layout, property);
          return (this.registry[variant] = layout);
        }
        getVariant(vb, offset = 0) {
          let variant;
          return (
            (variant =
              vb instanceof Uint8Array
                ? this.discriminator.decode(vb, offset)
                : vb),
            this.registry[variant]
          );
        }
      }
      Union;
      class VariantLayout extends Layout {
        constructor(union, variant, layout, property) {
          if (!(union instanceof Union))
            throw new TypeError("union must be a Union");
          if (!Number.isInteger(variant) || variant < 0)
            throw new TypeError("variant must be a (non-negative) integer");
          if (
            ("string" == typeof layout &&
              void 0 === property &&
              ((property = layout), (layout = null)),
            layout)
          ) {
            if (!(layout instanceof Layout))
              throw new TypeError("layout must be a Layout");
            if (
              null !== union.defaultLayout &&
              0 <= layout.span &&
              layout.span > union.defaultLayout.span
            )
              throw new Error("variant span exceeds span of containing union");
            if ("string" != typeof property)
              throw new TypeError("variant must have a String property");
          }
          let span = union.span;
          union.span < 0 &&
            0 <= (span = layout ? layout.span : 0) &&
            union.usesPrefixDiscriminator &&
            (span += union.discriminator.layout.span),
            super(span, property),
            (this.union = union),
            (this.variant = variant),
            (this.layout = layout || null);
        }
        getSpan(b, offset = 0) {
          if (0 <= this.span) return this.span;
          let contentOffset = 0,
            span =
              (this.union.usesPrefixDiscriminator &&
                (contentOffset = this.union.discriminator.layout.span),
              0);
          return (
            this.layout &&
              (span = this.layout.getSpan(b, offset + contentOffset)),
            contentOffset + span
          );
        }
        decode(b, offset = 0) {
          var dest = this.makeDestinationObject();
          if (this !== this.union.getVariant(b, offset))
            throw new Error("variant mismatch");
          let contentOffset = 0;
          return (
            this.union.usesPrefixDiscriminator &&
              (contentOffset = this.union.discriminator.layout.span),
            this.layout
              ? (dest[this.property] = this.layout.decode(
                  b,
                  offset + contentOffset
                ))
              : this.property
              ? (dest[this.property] = !0)
              : this.union.usesPrefixDiscriminator &&
                (dest[this.union.discriminator.property] = this.variant),
            dest
          );
        }
        encode(src, b, offset = 0) {
          let contentOffset = 0;
          if (
            (this.union.usesPrefixDiscriminator &&
              (contentOffset = this.union.discriminator.layout.span),
            this.layout &&
              !Object.prototype.hasOwnProperty.call(src, this.property))
          )
            throw new TypeError("variant lacks property " + this.property);
          this.union.discriminator.encode(this.variant, b, offset);
          let span = contentOffset;
          if (
            this.layout &&
            (this.layout.encode(src[this.property], b, offset + contentOffset),
            (span += this.layout.getSpan(b, offset + contentOffset)),
            0 <= this.union.span) &&
            span > this.union.span
          )
            throw new Error("encoded variant overruns containing union");
          return span;
        }
        fromArray(values) {
          if (this.layout) return this.layout.fromArray(values);
        }
      }
      function fixBitwiseResult(v) {
        return v < 0 && (v += 4294967296), v;
      }
      VariantLayout;
      class BitStructure extends Layout {
        constructor(word, msb, property) {
          if (!(word instanceof UInt || word instanceof UIntBE))
            throw new TypeError("word must be a UInt or UIntBE layout");
          if (
            ("string" == typeof msb &&
              void 0 === property &&
              ((property = msb), (msb = !1)),
            4 < word.span)
          )
            throw new RangeError("word cannot exceed 32 bits");
          super(word.span, property),
            (this.word = word),
            (this.msb = !!msb),
            (this.fields = []);
          let value = 0;
          (this._packedSetValue = function (v) {
            return (value = fixBitwiseResult(v)), this;
          }),
            (this._packedGetValue = function () {
              return value;
            });
        }
        decode(b, offset = 0) {
          var dest = this.makeDestinationObject(),
            offset = this.word.decode(b, offset);
          this._packedSetValue(offset);
          for (const fd of this.fields)
            void 0 !== fd.property && (dest[fd.property] = fd.decode(b));
          return dest;
        }
        encode(src, b, offset = 0) {
          var fv,
            value = this.word.decode(b, offset);
          this._packedSetValue(value);
          for (const fd of this.fields)
            void 0 !== fd.property &&
              void 0 !== (fv = src[fd.property]) &&
              fd.encode(fv);
          return this.word.encode(this._packedGetValue(), b, offset);
        }
        addField(bits, property) {
          bits = new BitField(this, bits, property);
          return this.fields.push(bits), bits;
        }
        addBoolean(property) {
          property = new Boolean(this, property);
          return this.fields.push(property), property;
        }
        fieldFor(property) {
          if ("string" != typeof property)
            throw new TypeError("property must be string");
          for (const fd of this.fields) if (fd.property === property) return fd;
        }
      }
      BitStructure;
      class BitField {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure))
            throw new TypeError("container must be a BitStructure");
          if (!Number.isInteger(bits) || bits <= 0)
            throw new TypeError("bits must be positive integer");
          var totalBits = 8 * container.span,
            usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (totalBits < bits + usedBits)
            throw new Error(
              "bits too long for span remainder (" +
                (totalBits - usedBits) +
                " of " +
                totalBits +
                " remain)"
            );
          (this.container = container),
            (this.bits = bits),
            (this.valueMask = (1 << bits) - 1),
            32 === bits && (this.valueMask = 4294967295),
            (this.start = usedBits),
            this.container.msb && (this.start = totalBits - usedBits - bits),
            (this.wordMask = fixBitwiseResult(this.valueMask << this.start)),
            (this.property = property);
        }
        decode(b, offset) {
          return (
            fixBitwiseResult(
              this.container._packedGetValue() & this.wordMask
            ) >>> this.start
          );
        }
        encode(value) {
          if (
            "number" != typeof value ||
            !Number.isInteger(value) ||
            value !== fixBitwiseResult(value & this.valueMask)
          )
            throw new TypeError(
              nameWithProperty("BitField.encode", this) +
                " value must be integer not exceeding " +
                this.valueMask
            );
          var word = this.container._packedGetValue(),
            value = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(
            fixBitwiseResult(word & ~this.wordMask) | value
          );
        }
      }
      class Boolean extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        decode(b, offset) {
          return !!super.decode(b, offset);
        }
        encode(value) {
          super.encode((value = "boolean" == typeof value ? +value : value));
        }
      }
      Boolean;
      class Blob extends Layout {
        constructor(length, property) {
          if (
            !(
              (length instanceof ExternalLayout && length.isCount()) ||
              (Number.isInteger(length) && 0 <= length)
            )
          )
            throw new TypeError(
              "length must be positive integer or an unsigned integer ExternalLayout"
            );
          let span = -1;
          super(
            (span = length instanceof ExternalLayout ? span : length),
            property
          ),
            (this.length = length);
        }
        getSpan(b, offset) {
          let span = this.span;
          return (span = span < 0 ? this.length.decode(b, offset) : span);
        }
        decode(b, offset = 0) {
          let span = this.span;
          return (
            span < 0 && (span = this.length.decode(b, offset)),
            uint8ArrayToBuffer(b).slice(offset, offset + span)
          );
        }
        encode(src, b, offset) {
          let span = this.length;
          if (
            (this.length instanceof ExternalLayout && (span = src.length),
            !(src instanceof Uint8Array && span === src.length))
          )
            throw new TypeError(
              nameWithProperty("Blob.encode", this) +
                " requires (length " +
                span +
                ") Uint8Array as src"
            );
          if (offset + span > b.length)
            throw new RangeError("encoding overruns Uint8Array");
          src = uint8ArrayToBuffer(src);
          return (
            uint8ArrayToBuffer(b).write(
              src.toString("hex"),
              offset,
              span,
              "hex"
            ),
            this.length instanceof ExternalLayout &&
              this.length.encode(span, b, offset),
            span
          );
        }
      }
      Blob;
      class CString extends Layout {
        constructor(property) {
          super(-1, property);
        }
        getSpan(b, offset = 0) {
          checkUint8Array(b);
          let idx = offset;
          for (; idx < b.length && 0 !== b[idx]; ) idx += 1;
          return 1 + idx - offset;
        }
        decode(b, offset = 0) {
          var span = this.getSpan(b, offset);
          return uint8ArrayToBuffer(b)
            .slice(offset, offset + span - 1)
            .toString("utf-8");
        }
        encode(src, b, offset = 0) {
          "string" != typeof src && (src = String(src));
          var src = buffer_1.Buffer.from(src, "utf8"),
            span = src.length;
          if (offset + span > b.length)
            throw new RangeError("encoding overruns Buffer");
          b = uint8ArrayToBuffer(b);
          return src.copy(b, offset), (b[offset + span] = 0), span + 1;
        }
      }
      CString;
      class UTF8 extends Layout {
        constructor(maxSpan, property) {
          if (
            ("string" == typeof maxSpan &&
              void 0 === property &&
              ((property = maxSpan), (maxSpan = void 0)),
            void 0 === maxSpan)
          )
            maxSpan = -1;
          else if (!Number.isInteger(maxSpan))
            throw new TypeError("maxSpan must be an integer");
          super(-1, property), (this.maxSpan = maxSpan);
        }
        getSpan(b, offset = 0) {
          return checkUint8Array(b), b.length - offset;
        }
        decode(b, offset = 0) {
          var span = this.getSpan(b, offset);
          if (0 <= this.maxSpan && this.maxSpan < span)
            throw new RangeError("text length exceeds maxSpan");
          return uint8ArrayToBuffer(b)
            .slice(offset, offset + span)
            .toString("utf-8");
        }
        encode(src, b, offset = 0) {
          "string" != typeof src && (src = String(src));
          var src = buffer_1.Buffer.from(src, "utf8"),
            span = src.length;
          if (0 <= this.maxSpan && this.maxSpan < span)
            throw new RangeError("text length exceeds maxSpan");
          if (offset + span > b.length)
            throw new RangeError("encoding overruns Buffer");
          return src.copy(uint8ArrayToBuffer(b), offset), span;
        }
      }
      UTF8;
      class Constant extends Layout {
        constructor(value, property) {
          super(0, property), (this.value = value);
        }
        decode(b, offset) {
          return this.value;
        }
        encode(src, b, offset) {
          return 0;
        }
      }
      Constant,
        (exports.cY = (layout, offset, property) =>
          new OffsetLayout(layout, offset, property)),
        (exports.u8 = (property) => new UInt(1, property)),
        (exports.NX = (property) => new UInt(2, property)),
        (exports.DH = (property) => new UInt(4, property)),
        (exports.I0 = (property) => new NearUInt64(property)),
        (exports.Wg = (property) => new NearInt64(property)),
        (exports.w3 = (fields, property, decodePrefixes) =>
          new Structure(fields, property, decodePrefixes)),
        (exports.O6 = (elementLayout, count, property) =>
          new Sequence(elementLayout, count, property)),
        (exports.av = (length, property) => new Blob(length, property));
    },
    8769: (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Ng: () => Connection,
        J3: () => PublicKey,
        P3: () => SIGNATURE_LENGTH_IN_BYTES,
        ZX: () => Transaction,
        B2: () => VersionedMessage,
        Kt: () => VersionedTransaction,
        Kw: () =>
          function clusterApiUrl(cluster, tls) {
            tls = !1 === tls ? "http" : "https";
            if (!cluster) return endpoint[tls].devnet;
            var url = endpoint[tls][cluster];
            if (url) return url;
            throw new Error(`Unknown ${tls} cluster: ` + cluster);
          },
      });
      var __webpack_exports__ = {},
        node_modules_buffer =
          (__webpack_require__.r(__webpack_exports__),
          __webpack_require__.d(__webpack_exports__, {
            DO: () => utils_abytes,
            OG: () => bitMask,
            My: () => abstract_utils_bytesToHex,
            bytesToNumberBE: () => utils_bytesToNumberBE,
            lX: () => utils_bytesToNumberLE,
            Id: () => abstract_utils_concatBytes,
            fg: () => createHmacDrbg,
            qj: () => utils_ensureBytes,
            hexToBytes: () => utils_hexToBytes,
            aY: () => abstract_utils_isBytes,
            lq: () => utils_numberToBytesBE,
            z: () => utils_numberToBytesLE,
            Q5: () => validateObject,
          }),
          __webpack_require__(8891));
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error("positive integer expected, not " + n);
      }
      function bytes(b, ...lengths) {
        if (
          !(function isBytes(a) {
            return (
              a instanceof Uint8Array ||
              (null != a &&
                "object" == typeof a &&
                "Uint8Array" === a.constructor.name)
            );
          })(b)
        )
          throw new Error("Uint8Array expected");
        if (0 < lengths.length && !lengths.includes(b.length))
          throw new Error(
            `Uint8Array expected of length ${lengths}, not of length=` +
              b.length
          );
      }
      function _assert_hash(h) {
        if ("function" != typeof h || "function" != typeof h.create)
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(h.outputLen), number(h.blockLen);
      }
      function exists(instance, checkFinished = !0) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function output(out, instance) {
        bytes(out);
        instance = instance.outputLen;
        if (out.length < instance)
          throw new Error(
            "digestInto() expects output buffer of length at least " + instance
          );
      }
      const crypto_crypto =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      const createView = (arr) =>
          new DataView(arr.buffer, arr.byteOffset, arr.byteLength),
        rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
      const isLE =
          68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
        byteSwap = (word) =>
          ((word << 24) & 4278190080) |
          ((word << 8) & 16711680) |
          ((word >>> 8) & 65280) |
          ((word >>> 24) & 255);
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) arr[i] = byteSwap(arr[i]);
      }
      function utils_utf8ToBytes(str) {
        if ("string" != typeof str)
          throw new Error("utf8ToBytes expected string, got " + typeof str);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function toBytes(data) {
        return (
          bytes(
            (data = "string" == typeof data ? utils_utf8ToBytes(data) : data)
          ),
          data
        );
      }
      function utils_concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          var a = arrays[i];
          bytes(a), (sum += a.length);
        }
        var res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad), (pad += a.length);
        }
        return res;
      }
      class Hash {
        clone() {
          return this._cloneInto();
        }
      }
      function utils_wrapConstructor(hashCons) {
        var hashC = (msg) => hashCons().update(toBytes(msg)).digest(),
          tmp = hashCons();
        return (
          (hashC.outputLen = tmp.outputLen),
          (hashC.blockLen = tmp.blockLen),
          (hashC.create = () => hashCons()),
          hashC
        );
      }
      function utils_randomBytes(bytesLength = 32) {
        if (crypto_crypto && "function" == typeof crypto_crypto.getRandomValues)
          return crypto_crypto.getRandomValues(new Uint8Array(bytesLength));
        throw new Error("crypto.getRandomValues must be defined");
      }
      class HashMD extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super(),
            (this.blockLen = blockLen),
            (this.outputLen = outputLen),
            (this.padOffset = padOffset),
            (this.isLE = isLE),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(blockLen)),
            (this.view = createView(this.buffer));
        }
        update(data) {
          exists(this);
          var { view, buffer, blockLen } = this,
            len = (data = toBytes(data)).length;
          for (let pos = 0; pos < len; ) {
            var take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen)
              for (
                var dataView = createView(data);
                blockLen <= len - pos;
                pos += blockLen
              )
                this.process(dataView, pos);
            else
              buffer.set(data.subarray(pos, pos + take), this.pos),
                (this.pos += take),
                (pos += take),
                this.pos === blockLen &&
                  (this.process(view, 0), (this.pos = 0));
          }
          return (this.length += data.length), this.roundClean(), this;
        }
        digestInto(out) {
          exists(this), output(out, this), (this.finished = !0);
          var { buffer, view, blockLen, isLE } = this;
          let pos = this["pos"];
          (buffer[pos++] = 128),
            this.buffer.subarray(pos).fill(0),
            this.padOffset > blockLen - pos &&
              (this.process(view, 0), (pos = 0));
          for (let i = pos; i < blockLen; i++) buffer[i] = 0;
          !(function setBigUint64(view, byteOffset, value, isLE) {
            if ("function" == typeof view.setBigUint64)
              return view.setBigUint64(byteOffset, value, isLE);
            var _32n = BigInt(32),
              _u32_max = BigInt(4294967295),
              _32n = Number((value >> _32n) & _u32_max),
              value = Number(value & _u32_max),
              _u32_max = isLE ? 0 : 4;
            view.setUint32(byteOffset + (isLE ? 4 : 0), _32n, isLE),
              view.setUint32(byteOffset + _u32_max, value, isLE);
          })(view, blockLen - 8, BigInt(8 * this.length), isLE),
            this.process(view, 0);
          var oview = createView(out),
            view = this.outputLen;
          if (view % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          var outLen = view / 4,
            state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          var { buffer, outputLen } = this,
            buffer = (this.digestInto(buffer), buffer.slice(0, outputLen));
          return this.destroy(), buffer;
        }
        _cloneInto(to) {
          (to = to || new this.constructor()).set(...this.get());
          var { blockLen, buffer, length, finished, destroyed, pos } = this;
          return (
            (to.length = length),
            (to.pos = pos),
            (to.finished = finished),
            (to.destroyed = destroyed),
            length % blockLen && to.buffer.set(buffer),
            to
          );
        }
      }
      const U32_MASK64 = BigInt(2 ** 32 - 1),
        _32n = BigInt(32);
      function fromBig(n, le = !1) {
        return le
          ? { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) }
          : {
              h: 0 | Number((n >> _32n) & U32_MASK64),
              l: 0 | Number(n & U32_MASK64),
            };
      }
      function split(lst, le = !1) {
        var Ah = new Uint32Array(lst.length),
          Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          var { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s)),
        rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s)),
        rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s)),
        rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
      const _u64 = {
          fromBig: fromBig,
          split: split,
          toBig: (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0),
          shrSH: (h, _l, s) => h >>> s,
          shrSL: (h, l, s) => (h << (32 - s)) | (l >>> s),
          rotrSH: (h, l, s) => (h >>> s) | (l << (32 - s)),
          rotrSL: (h, l, s) => (h << (32 - s)) | (l >>> s),
          rotrBH: (h, l, s) => (h << (64 - s)) | (l >>> (s - 32)),
          rotrBL: (h, l, s) => (h >>> (s - 32)) | (l << (64 - s)),
          rotr32H: (_h, l) => l,
          rotr32L: (h, _l) => h,
          rotlSH: rotlSH,
          rotlSL: rotlSL,
          rotlBH: rotlBH,
          rotlBL: rotlBL,
          add: function add(Ah, Al, Bh, Bl) {
            return {
              h:
                (Ah + Bh + (((Al = (Al >>> 0) + (Bl >>> 0)) / 2 ** 32) | 0)) |
                0,
              l: 0 | Al,
            };
          },
          add3L: (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0),
          add3H: (low, Ah, Bh, Ch) =>
            (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0,
          add4L: (Al, Bl, Cl, Dl) =>
            (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0),
          add4H: (low, Ah, Bh, Ch, Dh) =>
            (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0,
          add5H: (low, Ah, Bh, Ch, Dh, Eh) =>
            (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0,
          add5L: (Al, Bl, Cl, Dl, El) =>
            (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0),
        },
        [SHA512_Kh, SHA512_Kl] = (() =>
          _u64.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((n) => BigInt(n))
          ))(),
        SHA512_W_H = new Uint32Array(80),
        SHA512_W_L = new Uint32Array(80);
      class SHA512 extends HashMD {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          var {
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl,
          } = this;
          return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl,
          ];
        }
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          (this.Ah = 0 | Ah),
            (this.Al = 0 | Al),
            (this.Bh = 0 | Bh),
            (this.Bl = 0 | Bl),
            (this.Ch = 0 | Ch),
            (this.Cl = 0 | Cl),
            (this.Dh = 0 | Dh),
            (this.Dl = 0 | Dl),
            (this.Eh = 0 | Eh),
            (this.El = 0 | El),
            (this.Fh = 0 | Fh),
            (this.Fl = 0 | Fl),
            (this.Gh = 0 | Gh),
            (this.Gl = 0 | Gl),
            (this.Hh = 0 | Hh),
            (this.Hl = 0 | Hl);
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            (SHA512_W_H[i] = view.getUint32(offset)),
              (SHA512_W_L[i] = view.getUint32((offset += 4)));
          for (let i = 16; i < 80; i++) {
            var W15h = 0 | SHA512_W_H[i - 15],
              W15l = 0 | SHA512_W_L[i - 15],
              s0h =
                _u64.rotrSH(W15h, W15l, 1) ^
                _u64.rotrSH(W15h, W15l, 8) ^
                _u64.shrSH(W15h, W15l, 7),
              W15h =
                _u64.rotrSL(W15h, W15l, 1) ^
                _u64.rotrSL(W15h, W15l, 8) ^
                _u64.shrSL(W15h, W15l, 7),
              W15l = 0 | SHA512_W_H[i - 2],
              W2l = 0 | SHA512_W_L[i - 2],
              s1h =
                _u64.rotrSH(W15l, W2l, 19) ^
                _u64.rotrBH(W15l, W2l, 61) ^
                _u64.shrSH(W15l, W2l, 6),
              W15l =
                _u64.rotrSL(W15l, W2l, 19) ^
                _u64.rotrBL(W15l, W2l, 61) ^
                _u64.shrSL(W15l, W2l, 6),
              W2l = _u64.add4L(
                W15h,
                W15l,
                SHA512_W_L[i - 7],
                SHA512_W_L[i - 16]
              ),
              W15h = _u64.add4H(
                W2l,
                s0h,
                s1h,
                SHA512_W_H[i - 7],
                SHA512_W_H[i - 16]
              );
            (SHA512_W_H[i] = 0 | W15h), (SHA512_W_L[i] = 0 | W2l);
          }
          let {
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl,
          } = this;
          for (let i = 0; i < 80; i++) {
            var sigma1h =
                _u64.rotrSH(Eh, El, 14) ^
                _u64.rotrSH(Eh, El, 18) ^
                _u64.rotrBH(Eh, El, 41),
              sigma1l =
                _u64.rotrSL(Eh, El, 14) ^
                _u64.rotrSL(Eh, El, 18) ^
                _u64.rotrBL(Eh, El, 41),
              CHIh = (Eh & Fh) ^ (~Eh & Gh),
              CHIl = (El & Fl) ^ (~El & Gl),
              sigma1l = _u64.add5L(
                Hl,
                sigma1l,
                CHIl,
                SHA512_Kl[i],
                SHA512_W_L[i]
              ),
              CHIl = _u64.add5H(
                sigma1l,
                Hh,
                sigma1h,
                CHIh,
                SHA512_Kh[i],
                SHA512_W_H[i]
              ),
              sigma1h = 0 | sigma1l,
              CHIh =
                _u64.rotrSH(Ah, Al, 28) ^
                _u64.rotrBH(Ah, Al, 34) ^
                _u64.rotrBH(Ah, Al, 39),
              sigma1l =
                _u64.rotrSL(Ah, Al, 28) ^
                _u64.rotrBL(Ah, Al, 34) ^
                _u64.rotrBL(Ah, Al, 39),
              MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch),
              MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl),
              sigma1h =
                ((Hh = 0 | Gh),
                (Hl = 0 | Gl),
                (Gh = 0 | Fh),
                (Gl = 0 | Fl),
                (Fh = 0 | Eh),
                (Fl = 0 | El),
                ({ h: Eh, l: El } = _u64.add(
                  0 | Dh,
                  0 | Dl,
                  0 | CHIl,
                  0 | sigma1h
                )),
                (Dh = 0 | Ch),
                (Dl = 0 | Cl),
                (Ch = 0 | Bh),
                (Cl = 0 | Bl),
                (Bh = 0 | Ah),
                (Bl = 0 | Al),
                _u64.add3L(sigma1h, sigma1l, MAJl));
            (Ah = _u64.add3H(sigma1h, CHIl, CHIh, MAJh)), (Al = 0 | sigma1h);
          }
          ({ h: Ah, l: Al } = _u64.add(
            0 | this.Ah,
            0 | this.Al,
            0 | Ah,
            0 | Al
          )),
            ({ h: Bh, l: Bl } = _u64.add(
              0 | this.Bh,
              0 | this.Bl,
              0 | Bh,
              0 | Bl
            )),
            ({ h: Ch, l: Cl } = _u64.add(
              0 | this.Ch,
              0 | this.Cl,
              0 | Ch,
              0 | Cl
            )),
            ({ h: Dh, l: Dl } = _u64.add(
              0 | this.Dh,
              0 | this.Dl,
              0 | Dh,
              0 | Dl
            )),
            ({ h: Eh, l: El } = _u64.add(
              0 | this.Eh,
              0 | this.El,
              0 | Eh,
              0 | El
            )),
            ({ h: Fh, l: Fl } = _u64.add(
              0 | this.Fh,
              0 | this.Fl,
              0 | Fh,
              0 | Fl
            )),
            ({ h: Gh, l: Gl } = _u64.add(
              0 | this.Gh,
              0 | this.Gl,
              0 | Gh,
              0 | Gl
            )),
            ({ h: Hh, l: Hl } = _u64.add(
              0 | this.Hh,
              0 | this.Hl,
              0 | Hh,
              0 | Hl
            )),
            this.set(
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl
            );
        }
        roundClean() {
          SHA512_W_H.fill(0), SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      SHA512;
      SHA512;
      SHA512;
      var sha512_sha512 = utils_wrapConstructor(() => new SHA512());
      BigInt(0);
      const _1n = BigInt(1),
        _2n = BigInt(2);
      function abstract_utils_isBytes(a) {
        return (
          a instanceof Uint8Array ||
          (null != a &&
            "object" == typeof a &&
            "Uint8Array" === a.constructor.name)
        );
      }
      function utils_abytes(item) {
        if (!abstract_utils_isBytes(item))
          throw new Error("Uint8Array expected");
      }
      const utils_hexes = Array.from({ length: 256 }, (_, i) =>
        i.toString(16).padStart(2, "0")
      );
      function abstract_utils_bytesToHex(bytes) {
        utils_abytes(bytes);
        let hex = "";
        for (let i = 0; i < bytes.length; i++) hex += utils_hexes[bytes[i]];
        return hex;
      }
      function hexToNumber(hex) {
        if ("string" != typeof hex)
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt("" === hex ? "0" : "0x" + hex);
      }
      const utils_asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function utils_asciiToBase16(char) {
        return char >= utils_asciis._0 && char <= utils_asciis._9
          ? char - utils_asciis._0
          : char >= utils_asciis._A && char <= utils_asciis._F
          ? char - (utils_asciis._A - 10)
          : char >= utils_asciis._a && char <= utils_asciis._f
          ? char - (utils_asciis._a - 10)
          : void 0;
      }
      function utils_hexToBytes(hex) {
        if ("string" != typeof hex)
          throw new Error("hex string expected, got " + typeof hex);
        var hl = hex.length,
          al = hl / 2;
        if (hl % 2)
          throw new Error(
            "padded hex string expected, got unpadded hex of length " + hl
          );
        var array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          var char,
            n1 = utils_asciiToBase16(hex.charCodeAt(hi)),
            n2 = utils_asciiToBase16(hex.charCodeAt(hi + 1));
          if (void 0 === n1 || void 0 === n2)
            throw (
              ((char = hex[hi] + hex[hi + 1]),
              new Error(
                'hex string expected, got non-hex character "' +
                  char +
                  '" at index ' +
                  hi
              ))
            );
          array[ai] = 16 * n1 + n2;
        }
        return array;
      }
      function utils_bytesToNumberBE(bytes) {
        return hexToNumber(abstract_utils_bytesToHex(bytes));
      }
      function utils_bytesToNumberLE(bytes) {
        return (
          utils_abytes(bytes),
          hexToNumber(
            abstract_utils_bytesToHex(Uint8Array.from(bytes).reverse())
          )
        );
      }
      function utils_numberToBytesBE(n, len) {
        return utils_hexToBytes(n.toString(16).padStart(2 * len, "0"));
      }
      function utils_numberToBytesLE(n, len) {
        return utils_numberToBytesBE(n, len).reverse();
      }
      function utils_ensureBytes(title, hex, expectedLength) {
        let res;
        if ("string" == typeof hex)
          try {
            res = utils_hexToBytes(hex);
          } catch (e) {
            throw new Error(
              title + ` must be valid hex string, got "${hex}". Cause: ` + e
            );
          }
        else {
          if (!abstract_utils_isBytes(hex))
            throw new Error(title + " must be hex string or Uint8Array");
          res = Uint8Array.from(hex);
        }
        hex = res.length;
        if ("number" == typeof expectedLength && hex !== expectedLength)
          throw new Error(
            title + ` expected ${expectedLength} bytes, got ` + hex
          );
        return res;
      }
      function abstract_utils_concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          var a = arrays[i];
          utils_abytes(a), (sum += a.length);
        }
        var res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad), (pad += a.length);
        }
        return res;
      }
      const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n,
        u8n = (data) => new Uint8Array(data),
        u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if ("number" != typeof hashLen || hashLen < 2)
          throw new Error("hashLen must be a number");
        if ("number" != typeof qByteLen || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if ("function" != typeof hmacFn)
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen),
          k = u8n(hashLen),
          i = 0;
        const reset = () => {
            v.fill(1), k.fill(0), (i = 0);
          },
          h = (...b) => hmacFn(k, v, ...b),
          reseed = (seed = u8n()) => {
            (k = h(u8fr([0]), seed)),
              (v = h()),
              0 !== seed.length && ((k = h(u8fr([1]), seed)), (v = h()));
          };
        return (seed, pred) => {
          reset(), reseed(seed);
          let res = void 0;
          for (
            ;
            !(res = pred(
              (() => {
                if (1e3 <= i++) throw new Error("drbg: tried 1000 values");
                let len = 0;
                for (var out = []; len < qByteLen; ) {
                  var sl = (v = h()).slice();
                  out.push(sl), (len += v.length);
                }
                return abstract_utils_concatBytes(...out);
              })()
            ));

          )
            reseed();
          return reset(), res;
        };
      }
      const validatorFns = {
        bigint: (val) => "bigint" == typeof val,
        function: (val) => "function" == typeof val,
        boolean: (val) => "boolean" == typeof val,
        string: (val) => "string" == typeof val,
        stringOrUint8Array: (val) =>
          "string" == typeof val || abstract_utils_isBytes(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) =>
          "function" == typeof val && Number.isSafeInteger(val.outputLen),
      };
      function validateObject(object, validators, optValidators = {}) {
        var fieldName,
          type,
          checkField = (fieldName, type, isOptional) => {
            var checkVal = validatorFns[type];
            if ("function" != typeof checkVal)
              throw new Error(`Invalid validator "${type}", expected function`);
            var val = object[fieldName];
            if (!((isOptional && void 0 === val) || checkVal(val, object)))
              throw new Error(
                `Invalid param ${String(
                  fieldName
                )}=${val} (${typeof val}), expected ` + type
              );
          };
        for ([fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, !1);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, !0);
        return object;
      }
      const modular_0n = BigInt(0),
        modular_1n = BigInt(1),
        modular_2n = BigInt(2),
        _3n = BigInt(3),
        _4n = BigInt(4),
        _5n = BigInt(5),
        _8n = BigInt(8),
        _9n = BigInt(9),
        _16n = BigInt(16);
      function modular_mod(a, b) {
        a %= b;
        return a >= modular_0n ? a : b + a;
      }
      function modular_pow2(x, power, modulo) {
        let res = x;
        for (; power-- > modular_0n; ) res = (res * res) % modulo;
        return res;
      }
      function invert(number, modulo) {
        if (number === modular_0n || modulo <= modular_0n)
          throw new Error(
            `invert: expected positive integers, got n=${number} mod=` + modulo
          );
        let a = modular_mod(number, modulo),
          b = modulo,
          x = modular_0n,
          y = modular_1n,
          u = modular_1n,
          v = modular_0n;
        for (; a !== modular_0n; ) {
          var q = b / a,
            r = b % a,
            m = x - u * q,
            q = y - v * q;
          (b = a), (a = r), (x = u), (y = v), (u = m), (v = q);
        }
        if (b !== modular_1n) throw new Error("invert: does not exist");
        return modular_mod(x, modulo);
      }
      function tonelliShanks(P) {
        const legendreC = (P - modular_1n) / modular_2n;
        let Q, S, Z;
        for (
          Q = P - modular_1n, S = 0;
          Q % modular_2n === modular_0n;
          Q /= modular_2n, S++
        );
        for (
          Z = modular_2n;
          Z < P &&
          (function pow(num, power, modulo) {
            if (modulo <= modular_0n || power < modular_0n)
              throw new Error("Expected power/modulo > 0");
            if (modulo === modular_1n) return modular_0n;
            let res = modular_1n;
            for (; power > modular_0n; )
              power & modular_1n && (res = (res * num) % modulo),
                (num = (num * num) % modulo),
                (power >>= modular_1n);
            return res;
          })(Z, legendreC, P) !==
            P - modular_1n;
          Z++
        );
        if (1 === S) {
          const p1div4 = (P + modular_1n) / _4n;
          return function tonelliFast(Fp, n) {
            var root = Fp.pow(n, p1div4);
            if (Fp.eql(Fp.sqr(root), n)) return root;
            throw new Error("Cannot find square root");
          };
        }
        const Q1div2 = (Q + modular_1n) / modular_2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error("Cannot find square root");
          let r = S,
            g = Fp.pow(Fp.mul(Fp.ONE, Z), Q),
            x = Fp.pow(n, Q1div2),
            b = Fp.pow(n, Q);
          for (; !Fp.eql(b, Fp.ONE); ) {
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r && !Fp.eql(t2, Fp.ONE); m++)
              t2 = Fp.sqr(t2);
            var ge = Fp.pow(g, modular_1n << BigInt(r - m - 1));
            (g = Fp.sqr(ge)), (x = Fp.mul(x, ge)), (b = Fp.mul(b, g)), (r = m);
          }
          return x;
        };
      }
      const FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function nLength(n, nBitLength) {
        nBitLength = void 0 !== nBitLength ? nBitLength : n.toString(2).length;
        return {
          nBitLength: nBitLength,
          nByteLength: Math.ceil(nBitLength / 8),
        };
      }
      function Field(ORDER, bitLen, isLE = !1, redef = {}) {
        if (ORDER <= modular_0n)
          throw new Error("Expected Field ORDER > 0, got " + ORDER);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (2048 < BYTES)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = (function FpSqrt(P) {
            if (P % _4n === _3n) {
              const p1div4 = (P + modular_1n) / _4n;
              return function sqrt3mod4(Fp, n) {
                var root = Fp.pow(n, p1div4);
                if (Fp.eql(Fp.sqr(root), n)) return root;
                throw new Error("Cannot find square root");
              };
            }
            if (P % _8n !== _5n) return _16n, _9n, tonelliShanks(P);
            {
              const c1 = (P - _5n) / _8n;
              return function sqrt5mod8(Fp, n) {
                var n2 = Fp.mul(n, modular_2n),
                  n2 = Fp.pow(n2, c1),
                  nv = Fp.mul(n, n2),
                  n2 = Fp.mul(Fp.mul(nv, modular_2n), n2),
                  nv = Fp.mul(nv, Fp.sub(n2, Fp.ONE));
                if (Fp.eql(Fp.sqr(nv), n)) return nv;
                throw new Error("Cannot find square root");
              };
            }
          })(ORDER),
          f = Object.freeze({
            ORDER: ORDER,
            BITS: BITS,
            BYTES: BYTES,
            MASK: bitMask(BITS),
            ZERO: modular_0n,
            ONE: modular_1n,
            create: (num) => modular_mod(num, ORDER),
            isValid: (num) => {
              if ("bigint" != typeof num)
                throw new Error(
                  "Invalid field element: expected bigint, got " + typeof num
                );
              return modular_0n <= num && num < ORDER;
            },
            is0: (num) => num === modular_0n,
            isOdd: (num) => (num & modular_1n) === modular_1n,
            neg: (num) => modular_mod(-num, ORDER),
            eql: (lhs, rhs) => lhs === rhs,
            sqr: (num) => modular_mod(num * num, ORDER),
            add: (lhs, rhs) => modular_mod(lhs + rhs, ORDER),
            sub: (lhs, rhs) => modular_mod(lhs - rhs, ORDER),
            mul: (lhs, rhs) => modular_mod(lhs * rhs, ORDER),
            pow: (num, power) =>
              (function FpPow(f, num, power) {
                if (power < modular_0n) throw new Error("Expected power > 0");
                if (power === modular_0n) return f.ONE;
                if (power === modular_1n) return num;
                let p = f.ONE,
                  d = num;
                for (; power > modular_0n; )
                  power & modular_1n && (p = f.mul(p, d)),
                    (d = f.sqr(d)),
                    (power >>= modular_1n);
                return p;
              })(f, num, power),
            div: (lhs, rhs) => modular_mod(lhs * invert(rhs, ORDER), ORDER),
            sqrN: (num) => num * num,
            addN: (lhs, rhs) => lhs + rhs,
            subN: (lhs, rhs) => lhs - rhs,
            mulN: (lhs, rhs) => lhs * rhs,
            inv: (num) => invert(num, ORDER),
            sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
            invertBatch: (lst) =>
              (function FpInvertBatch(f, nums) {
                const tmp = new Array(nums.length);
                var lastMultiplied = nums.reduce(
                    (acc, num, i) =>
                      f.is0(num) ? acc : ((tmp[i] = acc), f.mul(acc, num)),
                    f.ONE
                  ),
                  lastMultiplied = f.inv(lastMultiplied);
                return (
                  nums.reduceRight(
                    (acc, num, i) =>
                      f.is0(num)
                        ? acc
                        : ((tmp[i] = f.mul(acc, tmp[i])), f.mul(acc, num)),
                    lastMultiplied
                  ),
                  tmp
                );
              })(f, lst),
            cmov: (a, b, c) => (c ? b : a),
            toBytes: (num) =>
              (isLE ? utils_numberToBytesLE : utils_numberToBytesBE)(
                num,
                BYTES
              ),
            fromBytes: (bytes) => {
              if (bytes.length !== BYTES)
                throw new Error(
                  `Fp.fromBytes: expected ${BYTES}, got ` + bytes.length
                );
              return (isLE ? utils_bytesToNumberLE : utils_bytesToNumberBE)(
                bytes
              );
            },
          });
        return Object.freeze(f);
      }
      function getFieldBytesLength(fieldOrder) {
        if ("bigint" != typeof fieldOrder)
          throw new Error("field order must be bigint");
        fieldOrder = fieldOrder.toString(2).length;
        return Math.ceil(fieldOrder / 8);
      }
      function getMinHashLength(fieldOrder) {
        fieldOrder = getFieldBytesLength(fieldOrder);
        return fieldOrder + Math.ceil(fieldOrder / 2);
      }
      const curve_0n = BigInt(0),
        curve_1n = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
            var neg = item.negate();
            return condition ? neg : item;
          },
          opts = (W) => {
            return {
              windows: Math.ceil(bits / W) + 1,
              windowSize: 2 ** (W - 1),
            };
          };
        return {
          constTimeNegate: constTimeNegate,
          unsafeLadder(elm, n) {
            let p = c.ZERO,
              d = elm;
            for (; n > curve_0n; )
              n & curve_1n && (p = p.add(d)),
                (d = d.double()),
                (n >>= curve_1n);
            return p;
          },
          precomputeWindow(elm, W) {
            var { windows, windowSize } = opts(W),
              points = [];
            let p = elm,
              base = p;
            for (let window = 0; window < windows; window++) {
              (base = p), points.push(base);
              for (let i = 1; i < windowSize; i++)
                (base = base.add(p)), points.push(base);
              p = base.double();
            }
            return points;
          },
          wNAF(W, precomputes, n) {
            var { windows, windowSize } = opts(W);
            let p = c.ZERO,
              f = c.BASE;
            var mask = BigInt(2 ** W - 1),
              maxNumber = 2 ** W,
              shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
              var offset = window * windowSize;
              let wbits = Number(n & mask);
              (n >>= shiftBy),
                wbits > windowSize && ((wbits -= maxNumber), (n += curve_1n));
              var offset1 = offset,
                offset = offset + Math.abs(wbits) - 1,
                cond1 = window % 2 != 0,
                cond2 = wbits < 0;
              0 === wbits
                ? (f = f.add(constTimeNegate(cond1, precomputes[offset1])))
                : (p = p.add(constTimeNegate(cond2, precomputes[offset])));
            }
            return { p: p, f: f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            var W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            return (
              comp ||
                ((comp = this.precomputeWindow(P, W)),
                1 !== W && precomputesMap.set(P, transform(comp))),
              this.wNAF(W, comp, n)
            );
          },
        };
      }
      function validateBasic(curve) {
        return (
          (function validateField(field) {
            validateObject(
              field,
              FIELD_FIELDS.reduce(
                (map, val) => ((map[val] = "function"), map),
                {
                  ORDER: "bigint",
                  MASK: "bigint",
                  BYTES: "isSafeInteger",
                  BITS: "isSafeInteger",
                }
              )
            );
          })(curve.Fp),
          validateObject(
            curve,
            { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
            { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
          ),
          Object.freeze({
            ...nLength(curve.n, curve.nBitLength),
            ...curve,
            p: curve.Fp.ORDER,
          })
        );
      }
      const edwards_0n = BigInt(0),
        edwards_1n = BigInt(1),
        edwards_2n = BigInt(2),
        edwards_8n = BigInt(8),
        VERIFY_DEFAULT = { zip215: !0 };
      function twistedEdwards(curveDef) {
        const CURVE = (function validateOpts(curve) {
            var opts = validateBasic(curve);
            return (
              validateObject(
                curve,
                {
                  hash: "function",
                  a: "bigint",
                  d: "bigint",
                  randomBytes: "function",
                },
                {
                  adjustScalarBytes: "function",
                  domain: "function",
                  uvRatio: "function",
                  mapToCurve: "function",
                }
              ),
              Object.freeze({ ...opts })
            );
          })(curveDef),
          {
            Fp,
            n: CURVE_ORDER,
            prehash,
            hash: cHash,
            randomBytes,
            nByteLength,
            h: cofactor,
          } = CURVE,
          MASK = edwards_2n << (BigInt(8 * nByteLength) - edwards_1n),
          modP = Fp.create,
          uvRatio =
            CURVE.uvRatio ||
            ((u, v) => {
              try {
                return { isValid: !0, value: Fp.sqrt(u * Fp.inv(v)) };
              } catch (e) {
                return { isValid: !1, value: edwards_0n };
              }
            }),
          adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes),
          domain =
            CURVE.domain ||
            ((data, ctx, phflag) => {
              if (ctx.length || phflag)
                throw new Error("Contexts/pre-hash are not supported");
              return data;
            }),
          inBig = (n) => "bigint" == typeof n && edwards_0n < n,
          inRange = (n, max) => inBig(n) && inBig(max) && n < max,
          in0MaskRange = (n) => n === edwards_0n || inRange(n, MASK);
        function assertInRange(n, max) {
          if (inRange(n, max)) return n;
          throw new Error(
            `Expected valid scalar < ${max}, got ${typeof n} ` + n
          );
        }
        function assertGE0(n) {
          return n === edwards_0n ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes = new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            if (
              ((this.ex = ex),
              (this.ey = ey),
              (this.ez = ez),
              (this.et = et),
              !in0MaskRange(ex))
            )
              throw new Error("x required");
            if (!in0MaskRange(ey)) throw new Error("y required");
            if (!in0MaskRange(ez)) throw new Error("z required");
            if (!in0MaskRange(et)) throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            var { x: p, y } = p || {};
            if (in0MaskRange(p) && in0MaskRange(y))
              return new Point(p, y, edwards_1n, modP(p * y));
            throw new Error("invalid affine point");
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points
              .map((p, i) => p.toAffine(toInv[i]))
              .map(Point.fromAffine);
          }
          _setWindowSize(windowSize) {
            (this._WINDOW_SIZE = windowSize), pointPrecomputes.delete(this);
          }
          assertValidity() {
            var { a, d } = CURVE;
            if (this.is0()) throw new Error("bad point: ZERO");
            var { ex: X, ey: Y, ez: Z, et: T } = this,
              X2 = modP(X * X),
              Y2 = modP(Y * Y),
              Z2 = modP(Z * Z),
              Z4 = modP(Z2 * Z2),
              a = modP(X2 * a);
            if (modP(Z2 * modP(a + Y2)) !== modP(Z4 + modP(d * modP(X2 * Y2))))
              throw new Error("bad point: equation left != right (1)");
            if (modP(X * Y) !== modP(Z * T))
              throw new Error("bad point: equation left != right (2)");
          }
          equals(other) {
            isPoint(other);
            var { ex: X1, ey: Y1, ez: Z1 } = this,
              { ex: other, ey: Y2, ez: Z2 } = other,
              X1 = modP(X1 * Z2),
              other = modP(other * Z1),
              Y1 = modP(Y1 * Z2),
              Z2 = modP(Y2 * Z1);
            return X1 === other && Y1 === Z2;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          double() {
            var a = CURVE["a"],
              { ex: X1, ey: Y1, ez: Z1 } = this,
              A = modP(X1 * X1),
              B = modP(Y1 * Y1),
              Z1 = modP(edwards_2n * modP(Z1 * Z1)),
              a = modP(a * A),
              X1 = X1 + Y1,
              Y1 = modP(modP(X1 * X1) - A - B),
              X1 = a + B,
              A = X1 - Z1,
              Z1 = a - B,
              a = modP(Y1 * A),
              B = modP(X1 * Z1),
              Y1 = modP(Y1 * Z1),
              Z1 = modP(A * X1);
            return new Point(a, B, Z1, Y1);
          }
          add(other) {
            isPoint(other);
            var { a, d } = CURVE,
              { ex: X1, ey: Y1, ez: Z1, et: T1 } = this,
              { ex: other, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A = modP((Y1 - X1) * (Y2 + other)),
                B = modP((Y1 + X1) * (Y2 - other)),
                F = modP(B - A);
              if (F === edwards_0n) return this.double();
              const C = modP(Z1 * edwards_2n * T2),
                D = modP(T1 * edwards_2n * Z2),
                E = D + C,
                G = B + A,
                H = D - C,
                X3 = modP(E * F),
                Y3 = modP(G * H),
                T3 = modP(E * H),
                Z3 = modP(F * G);
              return new Point(X3, Y3, Z3, T3);
            }
            const A = modP(X1 * other),
              B = modP(Y1 * Y2),
              C = modP(T1 * d * T2),
              D = modP(Z1 * Z2),
              E = modP((X1 + Y1) * (other + Y2) - A - B),
              F = D - C,
              G = D + C,
              H = modP(B - a * A),
              X3 = modP(E * F),
              Y3 = modP(G * H),
              T3 = modP(E * H),
              Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
          }
          multiply(scalar) {
            var { p: scalar, f } = this.wNAF(
              assertInRange(scalar, CURVE_ORDER)
            );
            return Point.normalizeZ([scalar, f])[0];
          }
          multiplyUnsafe(scalar) {
            scalar = assertGE0(scalar);
            return scalar === edwards_0n
              ? I
              : this.equals(I) || scalar === edwards_1n
              ? this
              : this.equals(G)
              ? this.wNAF(scalar).p
              : wnaf.unsafeLadder(this, scalar);
          }
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          toAffine(iz) {
            var { ex: x, ey: y, ez: z } = this,
              is0 = this.is0(),
              x =
                (null == iz && (iz = is0 ? edwards_8n : Fp.inv(z)),
                modP(x * iz)),
              y = modP(y * iz),
              z = modP(z * iz);
            if (is0) return { x: edwards_0n, y: edwards_1n };
            if (z !== edwards_1n) throw new Error("invZ was invalid");
            return { x: x, y: y };
          }
          clearCofactor() {
            var cofactor = CURVE["h"];
            return cofactor === edwards_1n
              ? this
              : this.multiplyUnsafe(cofactor);
          }
          static fromHex(hex, zip215 = !1) {
            var { d, a } = CURVE,
              len = Fp.BYTES,
              normed = (hex = utils_ensureBytes("pointHex", hex, len)).slice(),
              hex = hex[len - 1],
              len =
                ((normed[len - 1] = -129 & hex), utils_bytesToNumberLE(normed)),
              normed =
                (len !== edwards_0n &&
                  assertInRange(len, zip215 ? MASK : Fp.ORDER),
                modP(len * len)),
              u = modP(normed - edwards_1n),
              d = modP(d * normed - a);
            let { isValid, value: x } = uvRatio(u, d);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            (normed = (x & edwards_1n) === edwards_1n), (a = 0 != (128 & hex));
            if (!zip215 && x === edwards_0n && a)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            return (
              a != normed && (x = modP(-x)), Point.fromAffine({ x: x, y: len })
            );
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            var { x, y } = this.toAffine(),
              y = utils_numberToBytesLE(y, Fp.BYTES);
            return (y[y.length - 1] |= x & edwards_1n ? 128 : 0), y;
          }
          toHex() {
            return abstract_utils_bytesToHex(this.toRawBytes());
          }
        }
        (Point.BASE = new Point(
          CURVE.Gx,
          CURVE.Gy,
          edwards_1n,
          modP(CURVE.Gx * CURVE.Gy)
        )),
          (Point.ZERO = new Point(
            edwards_0n,
            edwards_1n,
            edwards_1n,
            edwards_0n
          ));
        const { BASE: G, ZERO: I } = Point,
          wnaf = wNAF(Point, 8 * nByteLength);
        function modN(a) {
          return modular_mod(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(utils_bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          var len = nByteLength,
            key =
              ((key = utils_ensureBytes("private key", key, len)),
              utils_ensureBytes("hashed private key", cHash(key), 2 * len)),
            head = adjustScalarBytes(key.slice(0, len)),
            key = key.slice(len, 2 * len),
            len = modN_LE(head),
            point = G.multiply(len),
            pointBytes = point.toRawBytes();
          return {
            head: head,
            prefix: key,
            scalar: len,
            point: point,
            pointBytes: pointBytes,
          };
        }
        function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
          msgs = abstract_utils_concatBytes(...msgs);
          return modN_LE(
            cHash(
              domain(msgs, utils_ensureBytes("context", context), !!prehash)
            )
          );
        }
        const verifyOpts = VERIFY_DEFAULT;
        return (
          G._setWindowSize(8),
          {
            CURVE: CURVE,
            getPublicKey: function getPublicKey(privKey) {
              return getExtendedPublicKey(privKey).pointBytes;
            },
            sign: function sign(msg, privKey, options = {}) {
              (msg = utils_ensureBytes("message", msg)),
                prehash && (msg = prehash(msg));
              var {
                  prefix: privKey,
                  scalar,
                  pointBytes,
                } = getExtendedPublicKey(privKey),
                privKey = hashDomainToScalar(options.context, privKey, msg),
                R = G.multiply(privKey).toRawBytes();
              return (
                assertGE0(
                  (privKey = modN(
                    privKey +
                      hashDomainToScalar(options.context, R, pointBytes, msg) *
                        scalar
                  ))
                ),
                utils_ensureBytes(
                  "result",
                  (options = abstract_utils_concatBytes(
                    R,
                    utils_numberToBytesLE(privKey, Fp.BYTES)
                  )),
                  2 * nByteLength
                )
              );
            },
            verify: function verify(sig, msg, publicKey, options = verifyOpts) {
              var { context: options, zip215 } = options,
                len = Fp.BYTES,
                s =
                  ((sig = utils_ensureBytes("signature", sig, 2 * len)),
                  (msg = utils_ensureBytes("message", msg)),
                  prehash && (msg = prehash(msg)),
                  utils_bytesToNumberLE(sig.slice(len, 2 * len)));
              let A, R, SB;
              try {
                (A = Point.fromHex(publicKey, zip215)),
                  (R = Point.fromHex(sig.slice(0, len), zip215)),
                  (SB = G.multiplyUnsafe(s));
              } catch (error) {
                return !1;
              }
              return (
                !(!zip215 && A.isSmallOrder()) &&
                ((publicKey = hashDomainToScalar(
                  options,
                  R.toRawBytes(),
                  A.toRawBytes(),
                  msg
                )),
                R.add(A.multiplyUnsafe(publicKey))
                  .subtract(SB)
                  .clearCofactor()
                  .equals(Point.ZERO))
              );
            },
            ExtendedPoint: Point,
            utils: {
              getExtendedPublicKey: getExtendedPublicKey,
              randomPrivateKey: () => randomBytes(Fp.BYTES),
              precompute(windowSize = 8, point = Point.BASE) {
                return (
                  point._setWindowSize(windowSize),
                  point.multiply(BigInt(3)),
                  point
                );
              },
            },
          }
        );
      }
      const ED25519_P = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        ),
        ED25519_SQRT_M1 = BigInt(
          "19681161376707505956807079304988542015446066515923890162744021073123829784752"
        ),
        ed25519_1n = (BigInt(0), BigInt(1)),
        ed25519_2n = BigInt(2),
        ed25519_5n = BigInt(5),
        _10n = BigInt(10),
        _20n = BigInt(20),
        _40n = BigInt(40),
        _80n = BigInt(80);
      function ed25519_pow_2_252_3(x) {
        var P = ED25519_P,
          b2 = (((x * x) % P) * x) % P,
          b4 = (modular_pow2(b2, ed25519_2n, P) * b2) % P,
          b4 = (modular_pow2(b4, ed25519_1n, P) * x) % P,
          b4 = (modular_pow2(b4, ed25519_5n, P) * b4) % P,
          b20 = (modular_pow2(b4, _10n, P) * b4) % P,
          b20 = (modular_pow2(b20, _20n, P) * b20) % P,
          b20 = (modular_pow2(b20, _40n, P) * b20) % P,
          b160 = (modular_pow2(b20, _80n, P) * b20) % P,
          b160 = (modular_pow2(b160, _80n, P) * b20) % P,
          b20 = (modular_pow2(b160, _10n, P) * b4) % P;
        return {
          pow_p_5_8: (modular_pow2(b20, ed25519_2n, P) * x) % P,
          b2: b2,
        };
      }
      function adjustScalarBytes(bytes) {
        return (bytes[0] &= 248), (bytes[31] &= 127), (bytes[31] |= 64), bytes;
      }
      function uvRatio(u, v) {
        var P = ED25519_P,
          v3 = modular_mod(v * v * v, P),
          v7 = modular_mod(v3 * v3 * v, P);
        let x = modular_mod(u * v3 * ed25519_pow_2_252_3(u * v7).pow_p_5_8, P);
        var v3 = modular_mod(v * x * x, P),
          v7 = x,
          v = modular_mod(x * ED25519_SQRT_M1, P),
          useRoot1 = v3 === u,
          useRoot2 = v3 === modular_mod(-u, P),
          v3 = v3 === modular_mod(-u * ED25519_SQRT_M1, P);
        return (
          useRoot1 && (x = v7),
          {
            isValid: useRoot1 || useRoot2,
            value: (x =
              (modular_mod((x = useRoot2 || v3 ? v : x), P) & modular_1n) ===
              modular_1n
                ? modular_mod(-x, P)
                : x),
          }
        );
      }
      const Fp = Field(ED25519_P, void 0, !0),
        ed25519Defaults = {
          a: BigInt(-1),
          d: BigInt(
            "37095705934669439343138083508754565189542113879843219016388785533085940283555"
          ),
          Fp: Fp,
          n: BigInt(
            "7237005577332262213973186563042994240857116359379907606001950938285454250989"
          ),
          h: BigInt(8),
          Gx: BigInt(
            "15112221349535400772501151409588531511454012693041857206046113283949847762202"
          ),
          Gy: BigInt(
            "46316835694926478169428394003475163141307993866256225615783033603165251855960"
          ),
          hash: sha512_sha512,
          randomBytes: utils_randomBytes,
          adjustScalarBytes: adjustScalarBytes,
          uvRatio: uvRatio,
        },
        ed25519 = twistedEdwards(ed25519Defaults);
      ({ ...ed25519Defaults }), { ...ed25519Defaults };
      sha512_sha512 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      Fp.pow(ed25519_2n, sha512_sha512),
        Fp.sqrt(Fp.neg(Fp.ONE)),
        Fp.ORDER,
        BigInt(5),
        BigInt(8),
        BigInt(486662);
      !(function FpSqrtEven(Fp, elm) {
        if (Fp.isOdd) return (elm = Fp.sqrt(elm)), Fp.isOdd(elm) && Fp.neg(elm);
        throw new Error("Field doesn't have isOdd");
      })(Fp, Fp.neg(BigInt(486664)));
      BigInt(
        "25063068953384623474111414158702152701244531502492656460079210482610430750235"
      ),
        BigInt(
          "54469307008909316920995813868745141605393597292927456921205312896311721017578"
        ),
        BigInt(
          "1159843021668779879193775521855586647937357759715417654439879720876111806838"
        ),
        BigInt(
          "40440834346308536858101042469323190826248399146238708352240133220865137265952"
        ),
        BigInt(
          "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      var sha512_sha512 = __webpack_require__(7240),
        bn_default = __webpack_require__.n(sha512_sha512),
        sha512_sha512 = __webpack_require__(3718),
        bs58_default = __webpack_require__.n(sha512_sha512);
      const SHA256_K = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]),
        SHA256_IV = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]),
        SHA256_W = new Uint32Array(64);
      class SHA256 extends HashMD {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | SHA256_IV[0]),
            (this.B = 0 | SHA256_IV[1]),
            (this.C = 0 | SHA256_IV[2]),
            (this.D = 0 | SHA256_IV[3]),
            (this.E = 0 | SHA256_IV[4]),
            (this.F = 0 | SHA256_IV[5]),
            (this.G = 0 | SHA256_IV[6]),
            (this.H = 0 | SHA256_IV[7]);
        }
        get() {
          var { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        set(A, B, C, D, E, F, G, H) {
          (this.A = 0 | A),
            (this.B = 0 | B),
            (this.C = 0 | C),
            (this.D = 0 | D),
            (this.E = 0 | E),
            (this.F = 0 | F),
            (this.G = 0 | G),
            (this.H = 0 | H);
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, !1);
          for (let i = 16; i < 64; i++) {
            var W15 = SHA256_W[i - 15],
              W2 = SHA256_W[i - 2],
              W15 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3),
              W2 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (W2 + SHA256_W[i - 7] + W15 + SHA256_W[i - 16]) | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            var sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25),
              b =
                (H +
                  sigma1 +
                  ((sigma1 = E),
                  (b = F),
                  (c = G),
                  (sigma1 & b) ^ (~sigma1 & c)) +
                  SHA256_K[i] +
                  SHA256_W[i]) |
                0,
              sigma1 =
                ((rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)) +
                  ((a, b, c) => (a & b) ^ (a & c) ^ (b & c))(A, B, C)) |
                0;
            (H = G),
              (G = F),
              (F = E),
              (E = (D + b) | 0),
              (D = C),
              (C = B),
              (B = A),
              (A = (b + sigma1) | 0);
          }
          var b, c;
          (A = (A + this.A) | 0),
            (B = (B + this.B) | 0),
            (C = (C + this.C) | 0),
            (D = (D + this.D) | 0),
            (E = (E + this.E) | 0),
            (F = (F + this.F) | 0),
            (G = (G + this.G) | 0),
            (H = (H + this.H) | 0),
            this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      SHA256;
      const sha256_sha256 = utils_wrapConstructor(() => new SHA256());
      var lib = __webpack_require__(5375),
        Layout = __webpack_require__(9829),
        browser = __webpack_require__(1740);
      class StructError extends TypeError {
        constructor(failure, failures) {
          let cached;
          const { message, explanation, ...rest } = failure;
          var path = failure["path"],
            path =
              0 === path.length
                ? message
                : `At path: ${path.join(".")} -- ` + message;
          super(explanation ?? path),
            null != explanation && (this.cause = path),
            Object.assign(this, rest),
            (this.name = this.constructor.name),
            (this.failures = () =>
              (cached = cached ?? [failure, ...failures()]));
        }
      }
      function isObject(x) {
        return "object" == typeof x && null != x;
      }
      function print(value) {
        return "symbol" == typeof value
          ? value.toString()
          : "string" == typeof value
          ? JSON.stringify(value)
          : "" + value;
      }
      function* toFailures(result, context, struct, value) {
        for (const r of (result = !(function isIterable(x) {
          return isObject(x) && "function" == typeof x[Symbol.iterator];
        })(result)
          ? [result]
          : result)) {
          var failure = (function toFailure(result, context, struct, value) {
            var branch, refinement, message;
            if (!0 !== result)
              return (
                !1 === result
                  ? (result = {})
                  : "string" == typeof result && (result = { message: result }),
                ({ path: context, branch } = context),
                (struct = struct["type"]),
                ({
                  refinement,
                  message = `Expected a value of type \`${struct}\`${
                    refinement ? ` with refinement \`${refinement}\`` : ""
                  }, but received: \`${print(value)}\``,
                } = result),
                {
                  value: value,
                  type: struct,
                  refinement: refinement,
                  key: context[context.length - 1],
                  path: context,
                  branch: branch,
                  ...result,
                  message: message,
                }
              );
          })(r, context, struct, value);
          failure && (yield failure);
        }
      }
      function* run(value, struct, options = {}) {
        var k,
          v,
          s,
          { path = [], branch = [value], coerce = !1, mask = !1 } = options,
          ctx = { path: path, branch: branch };
        if (
          coerce &&
          ((value = struct.coercer(value, ctx)), mask) &&
          "type" !== struct.type &&
          isObject(struct.schema) &&
          isObject(value) &&
          !Array.isArray(value)
        )
          for (const key in value)
            void 0 === struct.schema[key] && delete value[key];
        let status = "valid";
        for (const failure of struct.validator(value, ctx))
          (failure.explanation = options.message),
            (status = "not_valid"),
            yield [failure, void 0];
        for ([k, v, s] of struct.entries(value, ctx))
          for (const t of run(v, s, {
            path: void 0 === k ? path : [...path, k],
            branch: void 0 === k ? branch : [...branch, v],
            coerce: coerce,
            mask: mask,
            message: options.message,
          }))
            t[0]
              ? ((status =
                  null != t[0].refinement ? "not_refined" : "not_valid"),
                yield [t[0], void 0])
              : coerce &&
                ((v = t[1]),
                void 0 === k
                  ? (value = v)
                  : value instanceof Map
                  ? value.set(k, v)
                  : value instanceof Set
                  ? value.add(v)
                  : isObject(value) &&
                    (void 0 !== v || k in value) &&
                    (value[k] = v));
        if ("not_valid" !== status)
          for (const failure of struct.refiner(value, ctx))
            (failure.explanation = options.message),
              (status = "not_refined"),
              yield [failure, void 0];
        "valid" === status && (yield [void 0, value]);
      }
      class Struct {
        constructor(props) {
          const {
            type,
            schema,
            validator,
            refiner,
            coercer = (value) => value,
            entries = function* () {},
          } = props;
          (this.type = type),
            (this.schema = schema),
            (this.entries = entries),
            (this.coercer = coercer),
            validator
              ? (this.validator = (value, context) => {
                  return toFailures(
                    validator(value, context),
                    context,
                    this,
                    value
                  );
                })
              : (this.validator = () => []),
            refiner
              ? (this.refiner = (value, context) => {
                  return toFailures(
                    refiner(value, context),
                    context,
                    this,
                    value
                  );
                })
              : (this.refiner = () => []);
        }
        assert(value, message) {
          return (function dist_assert(value, struct, message) {
            value = validate(value, struct, { message: message });
            if (value[0]) throw value[0];
          })(value, this, message);
        }
        create(value, message) {
          return create(value, this, message);
        }
        is(value) {
          return is(value, this);
        }
        mask(value, message) {
          return (function mask(value, struct, message) {
            value = validate(value, struct, {
              coerce: !0,
              mask: !0,
              message: message,
            });
            {
              if (value[0]) throw value[0];
              return value[1];
            }
          })(value, this, message);
        }
        validate(value, options = {}) {
          return validate(value, this, options);
        }
      }
      function create(value, struct, message) {
        value = validate(value, struct, { coerce: !0, message: message });
        if (value[0]) throw value[0];
        return value[1];
      }
      function is(value, struct) {
        return !validate(value, struct)[0];
      }
      function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        value = (function shiftIterator(input) {
          var { done: input, value } = input.next();
          return input ? void 0 : value;
        })(tuples);
        return value[0]
          ? [
              new StructError(value[0], function* () {
                for (const t of tuples) t[0] && (yield t[0]);
              }),
              void 0,
            ]
          : [void 0, value[1]];
      }
      function dist_define(name, validator) {
        return new Struct({ type: name, schema: null, validator: validator });
      }
      function array(Element) {
        return new Struct({
          type: "array",
          schema: Element,
          *entries(value) {
            if (Element && Array.isArray(value))
              for (var [i, v] of value.entries()) yield [i, v, Element];
          },
          coercer(value) {
            return Array.isArray(value) ? value.slice() : value;
          },
          validator(value) {
            return (
              Array.isArray(value) ||
              "Expected an array value, but received: " + print(value)
            );
          },
        });
      }
      function dist_boolean() {
        return dist_define("boolean", (value) => "boolean" == typeof value);
      }
      function instance(Class) {
        return dist_define(
          "instance",
          (value) =>
            value instanceof Class ||
            `Expected a \`${Class.name}\` instance, but received: ` +
              print(value)
        );
      }
      function literal(constant) {
        const description = print(constant);
        var t = typeof constant;
        return new Struct({
          type: "literal",
          schema:
            "string" == t || "number" == t || "boolean" == t ? constant : null,
          validator(value) {
            return (
              value === constant ||
              `Expected the literal \`${description}\`, but received: ` +
                print(value)
            );
          },
        });
      }
      function never() {
        return dist_define("never", () => !1);
      }
      function nullable(struct) {
        return new Struct({
          ...struct,
          validator: (value, ctx) =>
            null === value || struct.validator(value, ctx),
          refiner: (value, ctx) => null === value || struct.refiner(value, ctx),
        });
      }
      function dist_number() {
        return dist_define(
          "number",
          (value) =>
            ("number" == typeof value && !isNaN(value)) ||
            "Expected a number, but received: " + print(value)
        );
      }
      function optional(struct) {
        return new Struct({
          ...struct,
          validator: (value, ctx) =>
            void 0 === value || struct.validator(value, ctx),
          refiner: (value, ctx) =>
            void 0 === value || struct.refiner(value, ctx),
        });
      }
      function record(Key, Value) {
        return new Struct({
          type: "record",
          schema: null,
          *entries(value) {
            if (isObject(value))
              for (const k in value) {
                var v = value[k];
                yield [k, k, Key], yield [k, v, Value];
              }
          },
          validator(value) {
            return (
              isObject(value) ||
              "Expected an object, but received: " + print(value)
            );
          },
        });
      }
      function string() {
        return dist_define(
          "string",
          (value) =>
            "string" == typeof value ||
            "Expected a string, but received: " + print(value)
        );
      }
      function tuple(Structs) {
        const Never = never();
        return new Struct({
          type: "tuple",
          schema: null,
          *entries(value) {
            if (Array.isArray(value)) {
              var length = Math.max(Structs.length, value.length);
              for (let i = 0; i < length; i++)
                yield [i, value[i], Structs[i] || Never];
            }
          },
          validator(value) {
            return (
              Array.isArray(value) ||
              "Expected an array, but received: " + print(value)
            );
          },
        });
      }
      function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
          type: "type",
          schema: schema,
          *entries(value) {
            if (isObject(value))
              for (const k of keys) yield [k, value[k], schema[k]];
          },
          validator(value) {
            return (
              isObject(value) ||
              "Expected an object, but received: " + print(value)
            );
          },
          coercer(value) {
            return isObject(value) ? { ...value } : value;
          },
        });
      }
      function union(Structs) {
        const description = Structs.map((s) => s.type).join(" | ");
        return new Struct({
          type: "union",
          schema: null,
          coercer(value) {
            for (const S of Structs) {
              var [error, coerced] = S.validate(value, { coerce: !0 });
              if (!error) return coerced;
            }
            return value;
          },
          validator(value, ctx) {
            var failures = [];
            for (const S of Structs) {
              var failure,
                [...tuples] = run(value, S, ctx),
                [first] = tuples;
              if (!first[0]) return [];
              for ([failure] of tuples) failure && failures.push(failure);
            }
            return [
              `Expected the value to satisfy a union of \`${description}\`, but received: ` +
                print(value),
              ...failures,
            ];
          },
        });
      }
      function unknown() {
        return dist_define("unknown", () => !0);
      }
      function coerce(struct, condition, coercer) {
        return new Struct({
          ...struct,
          coercer: (value, ctx) =>
            is(value, condition)
              ? struct.coercer(coercer(value, ctx), ctx)
              : struct.coercer(value, ctx),
        });
      }
      var sha512_sha512 = __webpack_require__(4706),
        browser_default = __webpack_require__.n(sha512_sha512),
        sha512_sha512 = __webpack_require__(1293),
        websocket_browser = __webpack_require__(5859);
      const SHA3_PI = [],
        SHA3_ROTL = [];
      var _SHA3_IOTA = [],
        sha3_0n = BigInt(0),
        sha3_1n = BigInt(1),
        sha3_2n = BigInt(2),
        _7n = BigInt(7),
        _256n = BigInt(256),
        _0x71n = BigInt(113);
      for (let round = 0, R = sha3_1n, x = 1, y = 0; round < 24; round++) {
        ([x, y] = [y, (2 * x + 3 * y) % 5]),
          SHA3_PI.push(2 * (5 * y + x)),
          SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
        let t = sha3_0n;
        for (let j = 0; j < 7; j++)
          (R = ((R << sha3_1n) ^ ((R >> _7n) * _0x71n)) % _256n) & sha3_2n &&
            (t ^= sha3_1n << ((sha3_1n << BigInt(j)) - sha3_1n));
        _SHA3_IOTA.push(t);
      }
      const [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, !0),
        rotlH = (h, l, s) => (32 < s ? rotlBH : rotlSH)(h, l, s),
        rotlL = (h, l, s) => (32 < s ? rotlBL : rotlSL)(h, l, s);
      class Keccak extends Hash {
        constructor(blockLen, suffix, outputLen, enableXOF = !1, rounds = 24) {
          if (
            (super(),
            (this.blockLen = blockLen),
            (this.suffix = suffix),
            (this.outputLen = outputLen),
            (this.enableXOF = enableXOF),
            (this.rounds = rounds),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            number(outputLen),
            this.blockLen <= 0 || 200 <= this.blockLen)
          )
            throw new Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 =
              ((blockLen = this.state),
              new Uint32Array(
                blockLen.buffer,
                blockLen.byteOffset,
                Math.floor(blockLen.byteLength / 4)
              )));
        }
        keccak() {
          isLE || byteSwap32(this.state32),
            (function keccakP(s, rounds = 24) {
              var B = new Uint32Array(10);
              for (let round = 24 - rounds; round < 24; round++) {
                for (let x = 0; x < 10; x++)
                  B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
                for (let x = 0; x < 10; x += 2) {
                  var idx1 = (x + 8) % 10,
                    idx0 = (x + 2) % 10,
                    B0 = B[idx0],
                    idx0 = B[1 + idx0],
                    Th = rotlH(B0, idx0, 1) ^ B[idx1],
                    Tl = rotlL(B0, idx0, 1) ^ B[1 + idx1];
                  for (let y = 0; y < 50; y += 10)
                    (s[x + y] ^= Th), (s[x + y + 1] ^= Tl);
                }
                let curH = s[2],
                  curL = s[3];
                for (let t = 0; t < 24; t++) {
                  var shift = SHA3_ROTL[t];
                  const Th = rotlH(curH, curL, shift),
                    Tl = rotlL(curH, curL, shift);
                  shift = SHA3_PI[t];
                  (curH = s[shift]),
                    (curL = s[shift + 1]),
                    (s[shift] = Th),
                    (s[shift + 1] = Tl);
                }
                for (let y = 0; y < 50; y += 10) {
                  for (let x = 0; x < 10; x++) B[x] = s[y + x];
                  for (let x = 0; x < 10; x++)
                    s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
                }
                (s[0] ^= SHA3_IOTA_H[round]), (s[1] ^= SHA3_IOTA_L[round]);
              }
              B.fill(0);
            })(this.state32, this.rounds),
            isLE || byteSwap32(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(data) {
          exists(this);
          var { blockLen, state } = this,
            len = (data = toBytes(data)).length;
          for (let pos = 0; pos < len; ) {
            var take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
            this.pos === blockLen && this.keccak();
          }
          return this;
        }
        finish() {
          var state, suffix, pos, blockLen;
          this.finished ||
            ((this.finished = !0),
            ({ state, suffix, pos, blockLen } = this),
            (state[pos] ^= suffix),
            0 != (128 & suffix) && pos === blockLen - 1 && this.keccak(),
            (state[blockLen - 1] ^= 128),
            this.keccak());
        }
        writeInto(out) {
          exists(this, !1), bytes(out), this.finish();
          var bufferOut = this.state,
            blockLen = this["blockLen"];
          for (let pos = 0, len = out.length; pos < len; ) {
            this.posOut >= blockLen && this.keccak();
            var take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos),
              (this.posOut += take),
              (pos += take);
          }
          return out;
        }
        xofInto(out) {
          if (this.enableXOF) return this.writeInto(out);
          throw new Error("XOF is not possible for this instance");
        }
        xof(bytes) {
          return number(bytes), this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          if ((output(out, this), this.finished))
            throw new Error("digest() was already called");
          return this.writeInto(out), this.destroy(), out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(to) {
          var { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          return (
            (to =
              to ||
              new Keccak(
                blockLen,
                suffix,
                outputLen,
                enableXOF,
                rounds
              )).state32.set(this.state32),
            (to.pos = this.pos),
            (to.posOut = this.posOut),
            (to.finished = this.finished),
            (to.rounds = rounds),
            (to.suffix = suffix),
            (to.outputLen = outputLen),
            (to.enableXOF = enableXOF),
            (to.destroyed = this.destroyed),
            to
          );
        }
      }
      __webpack_require__ = (suffix, blockLen, outputLen) =>
        utils_wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      const keccak_256 = __webpack_require__(1, 136, 32);
      class HMAC extends Hash {
        constructor(hash, _key) {
          super(),
            (this.finished = !1),
            (this.destroyed = !1),
            _assert_hash(hash);
          _key = toBytes(_key);
          if (
            ((this.iHash = hash.create()),
            "function" != typeof this.iHash.update)
          )
            throw new Error(
              "Expected instance of class which extends utils.Hash"
            );
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          var blockLen = this.blockLen,
            pad = new Uint8Array(blockLen);
          pad.set(
            _key.length > blockLen ? hash.create().update(_key).digest() : _key
          );
          for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
          this.iHash.update(pad), (this.oHash = hash.create());
          for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
          this.oHash.update(pad), pad.fill(0);
        }
        update(buf) {
          return exists(this), this.iHash.update(buf), this;
        }
        digestInto(out) {
          exists(this),
            bytes(out, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(out),
            this.oHash.update(out),
            this.oHash.digestInto(out),
            this.destroy();
        }
        digest() {
          var out = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(out), out;
        }
        _cloneInto(to) {
          var { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          return (
            ((to =
              to || Object.create(Object.getPrototypeOf(this), {})).finished =
              finished),
            (to.destroyed = destroyed),
            (to.blockLen = blockLen),
            (to.outputLen = outputLen),
            (to.oHash = oHash._cloneInto(to.oHash)),
            (to.iHash = iHash._cloneInto(to.iHash)),
            to
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      const hmac = (hash, key, message) =>
        new HMAC(hash, key).update(message).digest();
      hmac.create = (hash, key) => new HMAC(hash, key);
      const { bytesToNumberBE: b2n, hexToBytes: h2b } = __webpack_exports__,
        DER = {
          Err: class DERErr extends Error {
            constructor(m = "") {
              super(m);
            }
          },
          _parseInt(data) {
            var E = DER["Err"];
            if (data.length < 2 || 2 !== data[0])
              throw new E("Invalid signature integer tag");
            var len = data[1],
              res = data.subarray(2, len + 2);
            if (!len || res.length !== len)
              throw new E("Invalid signature integer: wrong length");
            if (128 & res[0])
              throw new E("Invalid signature integer: negative");
            if (0 !== res[0] || 128 & res[1])
              return { d: b2n(res), l: data.subarray(len + 2) };
            throw new E("Invalid signature integer: unnecessary leading zero");
          },
          toSig(hex) {
            var E = DER["Err"],
              hex = "string" == typeof hex ? h2b(hex) : hex,
              l = (utils_abytes(hex), hex.length);
            if (l < 2 || 48 != hex[0]) throw new E("Invalid signature tag");
            if (hex[1] !== l - 2)
              throw new E("Invalid signature: incorrect length");
            var { d: l, l: hex } = DER._parseInt(hex.subarray(2)),
              { d: hex, l: rBytesLeft } = DER._parseInt(hex);
            if (rBytesLeft.length)
              throw new E("Invalid signature: left bytes after parsing");
            return { r: l, s: hex };
          },
          hexFromSig(sig) {
            var slice = (s) => (8 & Number.parseInt(s[0], 16) ? "00" + s : s),
              h = (num) => {
                num = num.toString(16);
                return 1 & num.length ? "0" + num : num;
              },
              s = slice(h(sig.s)),
              slice = slice(h(sig.r)),
              sig = s.length / 2,
              rhl = slice.length / 2,
              sl = h(sig),
              rl = h(rhl);
            return `30${h(rhl + sig + 4)}02${rl}${slice}02` + sl + s;
          },
        },
        weierstrass_0n = BigInt(0),
        weierstrass_1n = BigInt(1),
        weierstrass_3n = (BigInt(2), BigInt(3));
      BigInt(4);
      function weierstrassPoints(opts) {
        const CURVE = (function validatePointOpts(curve) {
            validateObject(
              (curve = validateBasic(curve)),
              { a: "field", b: "field" },
              {
                allowedPrivateKeyLengths: "array",
                wrapPrivateKey: "boolean",
                isTorsionFree: "function",
                clearCofactor: "function",
                allowInfinityPoint: "boolean",
                fromBytes: "function",
                toBytes: "function",
              }
            );
            var { endo, Fp, a } = curve;
            if (endo) {
              if (!Fp.eql(a, Fp.ZERO))
                throw new Error(
                  "Endomorphism can only be defined for Koblitz curves that have a=0"
                );
              if (
                "object" != typeof endo ||
                "bigint" != typeof endo.beta ||
                "function" != typeof endo.splitScalar
              )
                throw new Error(
                  "Expected endomorphism with beta: bigint and splitScalar: function"
                );
            }
            return Object.freeze({ ...curve });
          })(opts),
          Fp = CURVE["Fp"],
          toBytes =
            CURVE.toBytes ||
            ((_c, point, _isCompressed) => {
              point = point.toAffine();
              return abstract_utils_concatBytes(
                Uint8Array.from([4]),
                Fp.toBytes(point.x),
                Fp.toBytes(point.y)
              );
            }),
          fromBytes =
            CURVE.fromBytes ||
            ((bytes) => {
              bytes = bytes.subarray(1);
              return {
                x: Fp.fromBytes(bytes.subarray(0, Fp.BYTES)),
                y: Fp.fromBytes(bytes.subarray(Fp.BYTES, 2 * Fp.BYTES)),
              };
            });
        function weierstrassEquation(x) {
          var { a, b } = CURVE,
            x2 = Fp.sqr(x),
            x2 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x2, Fp.mul(x, a)), b);
        }
        if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
          throw new Error("bad generator point: equation left != right");
        function isWithinCurveOrder(num) {
          return (
            "bigint" == typeof num && weierstrass_0n < num && num < CURVE.n
          );
        }
        function assertGE(num) {
          if (!isWithinCurveOrder(num))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n");
        }
        function normPrivateKeyToScalar(key) {
          var {
            allowedPrivateKeyLengths: lengths,
            nByteLength,
            wrapPrivateKey,
            n,
          } = CURVE;
          if (lengths && "bigint" != typeof key) {
            if (
              "string" !=
                typeof (key = abstract_utils_isBytes(key)
                  ? abstract_utils_bytesToHex(key)
                  : key) ||
              !lengths.includes(key.length)
            )
              throw new Error("Invalid key");
            key = key.padStart(2 * nByteLength, "0");
          }
          let num;
          try {
            num =
              "bigint" == typeof key
                ? key
                : utils_bytesToNumberBE(
                    utils_ensureBytes("private key", key, nByteLength)
                  );
          } catch (error) {
            throw new Error(
              `private key must be ${nByteLength} bytes, hex or bigint, not ` +
                typeof key
            );
          }
          return (
            assertGE((num = wrapPrivateKey ? modular_mod(num, n) : num)), num
          );
        }
        const pointPrecomputes = new Map();
        function assertPrjPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ProjectivePoint expected");
        }
        class Point {
          constructor(px, py, pz) {
            if (
              ((this.px = px),
              (this.py = py),
              (this.pz = pz),
              null == px || !Fp.isValid(px))
            )
              throw new Error("x required");
            if (null == py || !Fp.isValid(py)) throw new Error("y required");
            if (null == pz || !Fp.isValid(pz)) throw new Error("z required");
          }
          static fromAffine(p) {
            var { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point)
              throw new Error("projective point not allowed");
            p = (i) => Fp.eql(i, Fp.ZERO);
            return p(x) && p(y) ? Point.ZERO : new Point(x, y, Fp.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points
              .map((p, i) => p.toAffine(toInv[i]))
              .map(Point.fromAffine);
          }
          static fromHex(hex) {
            hex = Point.fromAffine(
              fromBytes(utils_ensureBytes("pointHex", hex))
            );
            return hex.assertValidity(), hex;
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
          _setWindowSize(windowSize) {
            (this._WINDOW_SIZE = windowSize), pointPrecomputes.delete(this);
          }
          assertValidity() {
            if (this.is0()) {
              if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
              throw new Error("bad point: ZERO");
            }
            var { x, y } = this.toAffine();
            if (!Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("bad point: x or y not FE");
            (y = Fp.sqr(y)), (x = weierstrassEquation(x));
            if (!Fp.eql(y, x))
              throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
              throw new Error("bad point: not in prime-order subgroup");
          }
          hasEvenY() {
            var y = this.toAffine()["y"];
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
          }
          equals(other) {
            assertPrjPoint(other);
            var { px: X1, py: Y1, pz: Z1 } = this,
              { px: other, py: Y2, pz: Z2 } = other,
              X1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(other, Z1)),
              other = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return X1 && other;
          }
          negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
          }
          double() {
            var X3,
              Y3,
              { a, b } = CURVE,
              b = Fp.mul(b, weierstrass_3n),
              { px: X1, py: Y1, pz: Z1 } = this,
              t0 = (Fp.ZERO, Fp.ZERO, Fp.ZERO, Fp.mul(X1, X1)),
              t1 = Fp.mul(Y1, Y1),
              t2 = Fp.mul(Z1, Z1),
              t3 = Fp.mul(X1, Y1),
              t3 = Fp.add(t3, t3),
              X1 = Fp.mul(X1, Z1);
            return (
              (X1 = Fp.add(X1, X1)),
              (X3 = Fp.mul(a, X1)),
              (Y3 = Fp.mul(b, t2)),
              (Y3 = Fp.add(X3, Y3)),
              (X3 = Fp.sub(t1, Y3)),
              (Y3 = Fp.add(t1, Y3)),
              (Y3 = Fp.mul(X3, Y3)),
              (X3 = Fp.mul(t3, X3)),
              (X1 = Fp.mul(b, X1)),
              (t2 = Fp.mul(a, t2)),
              (t3 = Fp.sub(t0, t2)),
              (t3 = Fp.mul(a, t3)),
              (t3 = Fp.add(t3, X1)),
              (X1 = Fp.add(t0, t0)),
              (t0 = Fp.add(X1, t0)),
              (t0 = Fp.add(t0, t2)),
              (t0 = Fp.mul(t0, t3)),
              (Y3 = Fp.add(Y3, t0)),
              (t2 = Fp.mul(Y1, Z1)),
              (t2 = Fp.add(t2, t2)),
              (t0 = Fp.mul(t2, t3)),
              (X3 = Fp.sub(X3, t0)),
              (X1 = Fp.mul(t2, t1)),
              (X1 = Fp.add(X1, X1)),
              (X1 = Fp.add(X1, X1)),
              new Point(X3, Y3, X1)
            );
          }
          add(other) {
            assertPrjPoint(other);
            var { px: X1, py: Y1, pz: Z1 } = this,
              { px: other, py: Y2, pz: Z2 } = other,
              a = (Fp.ZERO, Fp.ZERO, Fp.ZERO, CURVE.a),
              b3 = Fp.mul(CURVE.b, weierstrass_3n),
              t0 = Fp.mul(X1, other),
              t1 = Fp.mul(Y1, Y2),
              t2 = Fp.mul(Z1, Z2),
              t3 = Fp.add(X1, Y1),
              t4 = Fp.add(other, Y2),
              t3 = Fp.mul(t3, t4),
              t4 = Fp.add(t0, t1),
              X1 =
                ((t3 = Fp.sub(t3, t4)),
                (t4 = Fp.add(X1, Z1)),
                Fp.add(other, Z2));
            return (
              (t4 = Fp.mul(t4, X1)),
              (X1 = Fp.add(t0, t2)),
              (t4 = Fp.sub(t4, X1)),
              (X1 = Fp.add(Y1, Z1)),
              (other = Fp.add(Y2, Z2)),
              (X1 = Fp.mul(X1, other)),
              (other = Fp.add(t1, t2)),
              (X1 = Fp.sub(X1, other)),
              (Y1 = Fp.mul(a, t4)),
              (other = Fp.mul(b3, t2)),
              (Y1 = Fp.add(other, Y1)),
              (other = Fp.sub(t1, Y1)),
              (Y1 = Fp.add(t1, Y1)),
              (Z1 = Fp.mul(other, Y1)),
              (t1 = Fp.add(t0, t0)),
              (t1 = Fp.add(t1, t0)),
              (t2 = Fp.mul(a, t2)),
              (t4 = Fp.mul(b3, t4)),
              (t1 = Fp.add(t1, t2)),
              (t2 = Fp.sub(t0, t2)),
              (t2 = Fp.mul(a, t2)),
              (t4 = Fp.add(t4, t2)),
              (t0 = Fp.mul(t1, t4)),
              (Z1 = Fp.add(Z1, t0)),
              (t0 = Fp.mul(X1, t4)),
              (other = Fp.mul(t3, other)),
              (other = Fp.sub(other, t0)),
              (t0 = Fp.mul(t3, t1)),
              (Y1 = Fp.mul(X1, Y1)),
              (Y1 = Fp.add(Y1, t0)),
              new Point(other, Z1, Y1)
            );
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
              const toInv = Fp.invertBatch(comp.map((p) => p.pz));
              return comp
                .map((p, i) => p.toAffine(toInv[i]))
                .map(Point.fromAffine);
            });
          }
          multiplyUnsafe(n) {
            var I = Point.ZERO;
            if (n === weierstrass_0n) return I;
            if ((assertGE(n), n === weierstrass_1n)) return this;
            var endo = CURVE["endo"];
            if (!endo) return wnaf.unsafeLadder(this, n);
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n),
              k1p = I,
              k2p = I,
              d = this;
            for (; k1 > weierstrass_0n || k2 > weierstrass_0n; )
              k1 & weierstrass_1n && (k1p = k1p.add(d)),
                k2 & weierstrass_1n && (k2p = k2p.add(d)),
                (d = d.double()),
                (k1 >>= weierstrass_1n),
                (k2 >>= weierstrass_1n);
            return (
              k1neg && (k1p = k1p.negate()),
              k2neg && (k2p = k2p.negate()),
              (k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz)),
              k1p.add(k2p)
            );
          }
          multiply(scalar) {
            assertGE(scalar);
            let point, fake;
            var f1p,
              f2p,
              k1,
              k2,
              k1neg,
              k2neg,
              endo = CURVE["endo"];
            return (
              (fake = endo
                ? (({ k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar)),
                  ({ p: k1, f: f1p } = this.wNAF(k1)),
                  ({ p: k2, f: f2p } = this.wNAF(k2)),
                  (k1 = wnaf.constTimeNegate(k1neg, k1)),
                  (k2 = wnaf.constTimeNegate(k2neg, k2)),
                  (k2 = new Point(Fp.mul(k2.px, endo.beta), k2.py, k2.pz)),
                  (point = k1.add(k2)),
                  f1p.add(f2p))
                : (({ p: k1neg, f: k2neg } = this.wNAF(scalar)),
                  (point = k1neg),
                  k2neg)),
              Point.normalizeZ([point, fake])[0]
            );
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE;
            var mul = (P, a) =>
                a !== weierstrass_0n && a !== weierstrass_1n && P.equals(G)
                  ? P.multiply(a)
                  : P.multiplyUnsafe(a),
              a = mul(this, a).add(mul(Q, b));
            return a.is0() ? void 0 : a;
          }
          toAffine(iz) {
            var { px: x, py: y, pz: z } = this,
              is0 = this.is0(),
              x =
                (null == iz && (iz = is0 ? Fp.ONE : Fp.inv(z)), Fp.mul(x, iz)),
              y = Fp.mul(y, iz),
              z = Fp.mul(z, iz);
            if (is0) return { x: Fp.ZERO, y: Fp.ZERO };
            if (Fp.eql(z, Fp.ONE)) return { x: x, y: y };
            throw new Error("invZ was invalid");
          }
          isTorsionFree() {
            var { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === weierstrass_1n) return !0;
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error(
              "isTorsionFree() has not been declared for the elliptic curve"
            );
          }
          clearCofactor() {
            var { h: cofactor, clearCofactor } = CURVE;
            return cofactor === weierstrass_1n
              ? this
              : clearCofactor
              ? clearCofactor(Point, this)
              : this.multiplyUnsafe(CURVE.h);
          }
          toRawBytes(isCompressed = !0) {
            return this.assertValidity(), toBytes(Point, this, isCompressed);
          }
          toHex(isCompressed = !0) {
            return abstract_utils_bytesToHex(this.toRawBytes(isCompressed));
          }
        }
        (Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE)),
          (Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO));
        opts = CURVE.nBitLength;
        const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(opts / 2) : opts);
        return {
          CURVE: CURVE,
          ProjectivePoint: Point,
          normPrivateKeyToScalar: normPrivateKeyToScalar,
          weierstrassEquation: weierstrassEquation,
          isWithinCurveOrder: isWithinCurveOrder,
        };
      }
      function weierstrass(curveDef) {
        const CURVE = (function weierstrass_validateOpts(curve) {
            return (
              validateObject(
                (curve = validateBasic(curve)),
                { hash: "hash", hmac: "function", randomBytes: "function" },
                {
                  bits2int: "function",
                  bits2int_modN: "function",
                  lowS: "boolean",
                }
              ),
              Object.freeze({ lowS: !0, ...curve })
            );
          })(curveDef),
          { Fp, n: CURVE_ORDER } = CURVE,
          compressedLen = Fp.BYTES + 1,
          uncompressedLen = 2 * Fp.BYTES + 1;
        function modN(a) {
          return modular_mod(a, CURVE_ORDER);
        }
        function invN(a) {
          return invert(a, CURVE_ORDER);
        }
        const {
            ProjectivePoint: Point,
            normPrivateKeyToScalar,
            weierstrassEquation,
            isWithinCurveOrder,
          } = weierstrassPoints({
            ...CURVE,
            toBytes(_c, point, isCompressed) {
              var a = point.toAffine(),
                x = Fp.toBytes(a.x),
                cat = abstract_utils_concatBytes;
              return isCompressed
                ? cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x)
                : cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
            },
            fromBytes(bytes) {
              var len = bytes.length,
                head = bytes[0],
                bytes = bytes.subarray(1);
              if (len !== compressedLen || (2 !== head && 3 !== head)) {
                if (len !== uncompressedLen || 4 !== head)
                  throw new Error(
                    `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`
                  );
                {
                  const x = Fp.fromBytes(bytes.subarray(0, Fp.BYTES));
                  return {
                    x: x,
                    y: Fp.fromBytes(bytes.subarray(Fp.BYTES, 2 * Fp.BYTES)),
                  };
                }
              }
              {
                len = utils_bytesToNumberBE(bytes);
                if (
                  !(function isValidFieldElement(num) {
                    return weierstrass_0n < num && num < Fp.ORDER;
                  })(len)
                )
                  throw new Error("Point is not on curve");
                bytes = weierstrassEquation(len);
                let y;
                try {
                  y = Fp.sqrt(bytes);
                } catch (sqrtError) {
                  bytes =
                    sqrtError instanceof Error ? ": " + sqrtError.message : "";
                  throw new Error("Point is not on curve" + bytes);
                }
                bytes = (y & weierstrass_1n) === weierstrass_1n;
                return {
                  x: len,
                  y: (y = (1 == (1 & head)) != bytes ? Fp.neg(y) : y),
                };
              }
            },
          }),
          numToNByteStr = (num) =>
            abstract_utils_bytesToHex(
              utils_numberToBytesBE(num, CURVE.nByteLength)
            );
        function isBiggerThanHalfOrder(number) {
          return CURVE_ORDER >> weierstrass_1n < number;
        }
        const slcNum = (b, from, to) =>
          utils_bytesToNumberBE(b.slice(from, to));
        class Signature {
          constructor(r, s, recovery) {
            (this.r = r),
              (this.s = s),
              (this.recovery = recovery),
              this.assertValidity();
          }
          static fromCompact(hex) {
            var l = CURVE.nByteLength;
            return (
              (hex = utils_ensureBytes("compactSignature", hex, 2 * l)),
              new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l))
            );
          }
          static fromDER(hex) {
            var { r: hex, s } = DER.toSig(utils_ensureBytes("DER", hex));
            return new Signature(hex, s);
          }
          assertValidity() {
            if (!isWithinCurveOrder(this.r))
              throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s))
              throw new Error("s must be 0 < s < CURVE.n");
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(msgHash) {
            var { r, s, recovery: rec } = this,
              msgHash = bits2int_modN(utils_ensureBytes("msgHash", msgHash));
            if (null == rec || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            r = 2 === rec || 3 === rec ? r + CURVE.n : r;
            if (r >= Fp.ORDER) throw new Error("recovery id 2 or 3 invalid");
            (rec = 0 == (1 & rec) ? "02" : "03"),
              (rec = Point.fromHex(rec + numToNByteStr(r))),
              (r = invN(r)),
              (msgHash = modN(-msgHash * r)),
              (s = modN(s * r)),
              (r = Point.BASE.multiplyAndAddUnsafe(rec, msgHash, s));
            if (r) return r.assertValidity(), r;
            throw new Error("point at infinify");
          }
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          normalizeS() {
            return this.hasHighS()
              ? new Signature(this.r, modN(-this.s), this.recovery)
              : this;
          }
          toDERRawBytes() {
            return utils_hexToBytes(this.toDERHex());
          }
          toDERHex() {
            return DER.hexFromSig({ r: this.r, s: this.s });
          }
          toCompactRawBytes() {
            return utils_hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
        }
        curveDef = {
          isValidPrivateKey(privateKey) {
            try {
              return normPrivateKeyToScalar(privateKey), !0;
            } catch (error) {
              return !1;
            }
          },
          normPrivateKeyToScalar: normPrivateKeyToScalar,
          randomPrivateKey: () => {
            var length = getMinHashLength(CURVE.n);
            return (function mapHashToField(key, fieldOrder, isLE = !1) {
              var len = key.length,
                fieldLen = getFieldBytesLength(fieldOrder),
                minLen = getMinHashLength(fieldOrder);
              if (len < 16 || len < minLen || 1024 < len)
                throw new Error(
                  `expected ${minLen}-1024 bytes of input, got ` + len
                );
              return (
                (minLen =
                  modular_mod(
                    (isLE ? utils_bytesToNumberBE : utils_bytesToNumberLE)(key),
                    fieldOrder - modular_1n
                  ) + modular_1n),
                (isLE ? utils_numberToBytesLE : utils_numberToBytesBE)(
                  minLen,
                  fieldLen
                )
              );
            })(CURVE.randomBytes(length), CURVE.n);
          },
          precompute(windowSize = 8, point = Point.BASE) {
            return (
              point._setWindowSize(windowSize), point.multiply(BigInt(3)), point
            );
          },
        };
        function isProbPub(item) {
          var arr = abstract_utils_isBytes(item),
            str = "string" == typeof item,
            len = (arr || str) && item.length;
          return arr
            ? len === compressedLen || len === uncompressedLen
            : str
            ? len === 2 * compressedLen || len === 2 * uncompressedLen
            : item instanceof Point;
        }
        const bits2int =
            CURVE.bits2int ||
            function (bytes) {
              var num = utils_bytesToNumberBE(bytes),
                bytes = 8 * bytes.length - CURVE.nBitLength;
              return 0 < bytes ? num >> BigInt(bytes) : num;
            },
          bits2int_modN =
            CURVE.bits2int_modN ||
            function (bytes) {
              return modN(bits2int(bytes));
            },
          ORDER_MASK = bitMask(CURVE.nBitLength);
        function int2octets(num) {
          if ("bigint" != typeof num) throw new Error("bigint expected");
          if (weierstrass_0n <= num && num < ORDER_MASK)
            return utils_numberToBytesBE(num, CURVE.nByteLength);
          throw new Error("bigint expected < 2^" + CURVE.nBitLength);
        }
        function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          var { hash, randomBytes } = CURVE;
          let { lowS, prehash, extraEntropy: ent } = opts;
          null == lowS && (lowS = !0),
            (msgHash = utils_ensureBytes("msgHash", msgHash)),
            prehash &&
              (msgHash = utils_ensureBytes("prehashed msgHash", hash(msgHash)));
          hash = bits2int_modN(msgHash);
          const d = normPrivateKeyToScalar(privateKey);
          (msgHash = [int2octets(d), int2octets(hash)]),
            null != ent &&
              !1 !== ent &&
              ((privateKey = !0 === ent ? randomBytes(Fp.BYTES) : ent),
              msgHash.push(utils_ensureBytes("extraEntropy", privateKey))),
            (randomBytes = abstract_utils_concatBytes(...msgHash));
          const m = hash;
          return {
            seed: randomBytes,
            k2sig: function k2sig(kBytes) {
              if (((kBytes = bits2int(kBytes)), isWithinCurveOrder(kBytes))) {
                var ik = invN(kBytes),
                  kBytes = Point.BASE.multiply(kBytes).toAffine(),
                  r = modN(kBytes.x);
                if (r !== weierstrass_0n) {
                  ik = modN(ik * modN(m + r * d));
                  if (ik !== weierstrass_0n) {
                    let recovery =
                        (kBytes.x === r ? 0 : 2) |
                        Number(kBytes.y & weierstrass_1n),
                      normS = ik;
                    return (
                      lowS &&
                        isBiggerThanHalfOrder(ik) &&
                        ((normS = (function normalizeS(s) {
                          return isBiggerThanHalfOrder(s) ? modN(-s) : s;
                        })(ik)),
                        (recovery ^= 1)),
                      new Signature(r, normS, recovery)
                    );
                  }
                }
              }
            },
          };
        }
        const defaultSigOpts = { lowS: CURVE.lowS, prehash: !1 },
          defaultVerOpts = { lowS: CURVE.lowS, prehash: !1 };
        return (
          Point.BASE._setWindowSize(8),
          {
            CURVE: CURVE,
            getPublicKey: function getPublicKey(privateKey, isCompressed = !0) {
              return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
            },
            getSharedSecret: function getSharedSecret(
              privateA,
              publicB,
              isCompressed = !0
            ) {
              if (isProbPub(privateA))
                throw new Error("first arg must be private key");
              if (isProbPub(publicB))
                return Point.fromHex(publicB)
                  .multiply(normPrivateKeyToScalar(privateA))
                  .toRawBytes(isCompressed);
              throw new Error("second arg must be public key");
            },
            sign: function sign(msgHash, privKey, opts = defaultSigOpts) {
              var { seed: msgHash, k2sig: privKey } = prepSig(
                msgHash,
                privKey,
                opts
              );
              return createHmacDrbg(
                (opts = CURVE).hash.outputLen,
                opts.nByteLength,
                opts.hmac
              )(msgHash, privKey);
            },
            verify: function verify(
              signature,
              msgHash,
              publicKey,
              opts = defaultVerOpts
            ) {
              if (
                ((msgHash = utils_ensureBytes("msgHash", msgHash)),
                (publicKey = utils_ensureBytes("publicKey", publicKey)),
                "strict" in opts)
              )
                throw new Error("options.strict was renamed to lowS");
              var { lowS: opts, prehash } = opts;
              let _sig = void 0,
                P;
              try {
                if (
                  "string" == typeof signature ||
                  abstract_utils_isBytes(signature)
                )
                  try {
                    _sig = Signature.fromDER(signature);
                  } catch (derError) {
                    if (!(derError instanceof DER.Err)) throw derError;
                    _sig = Signature.fromCompact(signature);
                  }
                else {
                  if (
                    "object" != typeof signature ||
                    "bigint" != typeof signature.r ||
                    "bigint" != typeof signature.s
                  )
                    throw new Error("PARSE");
                  {
                    const { r, s } = signature;
                    _sig = new Signature(r, s);
                  }
                }
                P = Point.fromHex(publicKey);
              } catch (error) {
                if ("PARSE" === error.message)
                  throw new Error(
                    "signature must be Signature instance, Uint8Array or hex string"
                  );
                return !1;
              }
              if (opts && _sig.hasHighS()) return !1;
              prehash && (msgHash = CURVE.hash(msgHash));
              const { r, s } = _sig;
              return (
                (signature = bits2int_modN(msgHash)),
                (publicKey = invN(s)),
                (opts = modN(signature * publicKey)),
                (prehash = modN(r * publicKey)),
                !!(msgHash = Point.BASE.multiplyAndAddUnsafe(
                  P,
                  opts,
                  prehash
                )?.toAffine()) && modN(msgHash.x) === r
              );
            },
            ProjectivePoint: Point,
            Signature: Signature,
            utils: curveDef,
          }
        );
      }
      const secp256k1P = BigInt(
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
        ),
        secp256k1N = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        ),
        secp256k1_1n = BigInt(1),
        secp256k1_2n = BigInt(2),
        divNearest = (a, b) => (a + b / secp256k1_2n) / b;
      function sqrtMod(y) {
        var P = secp256k1P,
          _3n = BigInt(3),
          _6n = BigInt(6),
          _11n = BigInt(11),
          _22n = BigInt(22),
          _23n = BigInt(23),
          _44n = BigInt(44),
          _88n = BigInt(88),
          b2 = (y * y * y) % P,
          b3 = (b2 * b2 * y) % P,
          b6 = (modular_pow2(b3, _3n, P) * b3) % P,
          b6 = (modular_pow2(b6, _3n, P) * b3) % P,
          b6 = (modular_pow2(b6, secp256k1_2n, P) * b2) % P,
          _11n = (modular_pow2(b6, _11n, P) * b6) % P,
          b6 = (modular_pow2(_11n, _22n, P) * _11n) % P,
          _22n = (modular_pow2(b6, _44n, P) * b6) % P,
          _88n = (modular_pow2(_22n, _88n, P) * _22n) % P,
          _22n = (modular_pow2(_88n, _44n, P) * b6) % P,
          _88n = (modular_pow2(_22n, _3n, P) * b3) % P,
          _44n = (modular_pow2(_88n, _23n, P) * _11n) % P,
          b6 = (modular_pow2(_44n, _6n, P) * b2) % P,
          _22n = modular_pow2(b6, secp256k1_2n, P);
        if (secp256k1_Fp.eql(secp256k1_Fp.sqr(_22n), y)) return _22n;
        throw new Error("Cannot find square root");
      }
      const secp256k1_Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }),
        secp256k1 = (function createCurve(curveDef, defHash) {
          var create = (hash) =>
            weierstrass({
              ...curveDef,
              ...(function getHash(hash) {
                return {
                  hash: hash,
                  hmac: (key, ...msgs) =>
                    hmac(hash, key, utils_concatBytes(...msgs)),
                  randomBytes: utils_randomBytes,
                };
              })(hash),
            });
          return Object.freeze({ ...create(defHash), create: create });
        })(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: secp256k1_Fp,
            n: secp256k1N,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
              ),
              splitScalar: (k) => {
                var n = secp256k1N,
                  a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  b1 =
                    -secp256k1_1n *
                    BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  b2 = a1,
                  POW_2_128 = BigInt("0x100000000000000000000000000000000"),
                  c1 = divNearest(b2 * k, n),
                  c2 = divNearest(-b1 * k, n);
                let k1 = modular_mod(k - c1 * a1 - c2 * a2, n),
                  k2 = modular_mod(-c1 * b1 - c2 * b2, n);
                (a1 = k1 > POW_2_128), (a2 = k2 > POW_2_128);
                if (
                  (a1 && (k1 = n - k1),
                  a2 && (k2 = n - k2),
                  k1 > POW_2_128 || k2 > POW_2_128)
                )
                  throw new Error("splitScalar: Endomorphism failed, k=" + k);
                return { k1neg: a1, k1: k1, k2neg: a2, k2: k2 };
              },
            },
          },
          sha256_sha256
        );
      BigInt(0);
      secp256k1.ProjectivePoint;
      ed25519.utils.randomPrivateKey;
      const generateKeypair = () => {
          var privateScalar = ed25519.utils.randomPrivateKey(),
            publicKey = getPublicKey(privateScalar),
            secretKey = new Uint8Array(64);
          return (
            secretKey.set(privateScalar),
            secretKey.set(publicKey, 32),
            { publicKey: publicKey, secretKey: secretKey }
          );
        },
        getPublicKey = ed25519.getPublicKey;
      function isOnCurve(publicKey) {
        try {
          return ed25519.ExtendedPoint.fromHex(publicKey), !0;
        } catch {
          return !1;
        }
      }
      const sign = (message, secretKey) =>
          ed25519.sign(message, secretKey.slice(0, 32)),
        verify = ed25519.verify,
        toBuffer = (arr) =>
          node_modules_buffer.Buffer.isBuffer(arr)
            ? arr
            : arr instanceof Uint8Array
            ? node_modules_buffer.Buffer.from(
                arr.buffer,
                arr.byteOffset,
                arr.byteLength
              )
            : node_modules_buffer.Buffer.from(arr);
      class index_browser_esm_Struct {
        constructor(properties) {
          Object.assign(this, properties);
        }
        encode() {
          return node_modules_buffer.Buffer.from(
            (0, lib.serialize)(SOLANA_SCHEMA, this)
          );
        }
        static decode(data) {
          return (0, lib.deserialize)(SOLANA_SCHEMA, this, data);
        }
        static decodeUnchecked(data) {
          return (0, lib.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
        }
      }
      const SOLANA_SCHEMA = new Map();
      let uniquePublicKeyCounter = 1;
      class PublicKey extends index_browser_esm_Struct {
        constructor(value) {
          if (
            (super({}),
            (this._bn = void 0),
            (function isPublicKeyData(value) {
              return void 0 !== value._bn;
            })(value))
          )
            this._bn = value._bn;
          else {
            if ("string" == typeof value) {
              var decoded = bs58_default().decode(value);
              if (32 != decoded.length)
                throw new Error("Invalid public key input");
              this._bn = new (bn_default())(decoded);
            } else this._bn = new (bn_default())(value);
            if (32 < this._bn.byteLength())
              throw new Error("Invalid public key input");
          }
        }
        static unique() {
          var key = new PublicKey(uniquePublicKeyCounter);
          return (uniquePublicKeyCounter += 1), new PublicKey(key.toBuffer());
        }
        equals(publicKey) {
          return this._bn.eq(publicKey._bn);
        }
        toBase58() {
          return bs58_default().encode(this.toBytes());
        }
        toJSON() {
          return this.toBase58();
        }
        toBytes() {
          var buf = this.toBuffer();
          return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        toBuffer() {
          var zeroPad,
            b = this._bn.toArrayLike(node_modules_buffer.Buffer);
          return 32 === b.length
            ? b
            : ((zeroPad = node_modules_buffer.Buffer.alloc(32)),
              b.copy(zeroPad, 32 - b.length),
              zeroPad);
        }
        get [Symbol.toStringTag]() {
          return `PublicKey(${this.toString()})`;
        }
        toString() {
          return this.toBase58();
        }
        static async createWithSeed(fromPublicKey, seed, programId) {
          (fromPublicKey = node_modules_buffer.Buffer.concat([
            fromPublicKey.toBuffer(),
            node_modules_buffer.Buffer.from(seed),
            programId.toBuffer(),
          ])),
            (seed = sha256_sha256(fromPublicKey));
          return new PublicKey(seed);
        }
        static createProgramAddressSync(seeds, programId) {
          let buffer = node_modules_buffer.Buffer.alloc(0);
          seeds.forEach(function (seed) {
            if (32 < seed.length)
              throw new TypeError("Max seed length exceeded");
            buffer = node_modules_buffer.Buffer.concat([
              buffer,
              toBuffer(seed),
            ]);
          }),
            (buffer = node_modules_buffer.Buffer.concat([
              buffer,
              programId.toBuffer(),
              node_modules_buffer.Buffer.from("ProgramDerivedAddress"),
            ]));
          seeds = sha256_sha256(buffer);
          if (isOnCurve(seeds))
            throw new Error("Invalid seeds, address must fall off the curve");
          return new PublicKey(seeds);
        }
        static async createProgramAddress(seeds, programId) {
          return this.createProgramAddressSync(seeds, programId);
        }
        static findProgramAddressSync(seeds, programId) {
          let nonce = 255,
            address;
          for (; 0 != nonce; ) {
            try {
              var seedsWithNonce = seeds.concat(
                node_modules_buffer.Buffer.from([nonce])
              );
              address = this.createProgramAddressSync(
                seedsWithNonce,
                programId
              );
            } catch (err) {
              if (err instanceof TypeError) throw err;
              nonce--;
              continue;
            }
            return [address, nonce];
          }
          throw new Error("Unable to find a viable program address nonce");
        }
        static async findProgramAddress(seeds, programId) {
          return this.findProgramAddressSync(seeds, programId);
        }
        static isOnCurve(pubkeyData) {
          return isOnCurve(new PublicKey(pubkeyData).toBytes());
        }
      }
      (PublicKey.default = new PublicKey("11111111111111111111111111111111")),
        SOLANA_SCHEMA.set(PublicKey, {
          kind: "struct",
          fields: [["_bn", "u256"]],
        });
      new PublicKey("BPFLoader1111111111111111111111111111111111");
      const SIGNATURE_LENGTH_IN_BYTES = 64;
      class TransactionExpiredBlockheightExceededError extends Error {
        constructor(signature) {
          super(`Signature ${signature} has expired: block height exceeded.`),
            (this.signature = void 0),
            (this.signature = signature);
        }
      }
      Object.defineProperty(
        TransactionExpiredBlockheightExceededError.prototype,
        "name",
        { value: "TransactionExpiredBlockheightExceededError" }
      );
      class TransactionExpiredTimeoutError extends Error {
        constructor(signature, timeoutSeconds) {
          super(
            `Transaction was not confirmed in ${timeoutSeconds.toFixed(
              2
            )} seconds. It is ` +
              "unknown if it succeeded or failed. Check signature " +
              signature +
              " using the Solana Explorer or CLI tools."
          ),
            (this.signature = void 0),
            (this.signature = signature);
        }
      }
      Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
        value: "TransactionExpiredTimeoutError",
      });
      class TransactionExpiredNonceInvalidError extends Error {
        constructor(signature) {
          super(
            `Signature ${signature} has expired: the nonce is no longer valid.`
          ),
            (this.signature = void 0),
            (this.signature = signature);
        }
      }
      Object.defineProperty(
        TransactionExpiredNonceInvalidError.prototype,
        "name",
        { value: "TransactionExpiredNonceInvalidError" }
      );
      class MessageAccountKeys {
        constructor(staticAccountKeys, accountKeysFromLookups) {
          (this.staticAccountKeys = void 0),
            (this.accountKeysFromLookups = void 0),
            (this.staticAccountKeys = staticAccountKeys),
            (this.accountKeysFromLookups = accountKeysFromLookups);
        }
        keySegments() {
          var keySegments = [this.staticAccountKeys];
          return (
            this.accountKeysFromLookups &&
              (keySegments.push(this.accountKeysFromLookups.writable),
              keySegments.push(this.accountKeysFromLookups.readonly)),
            keySegments
          );
        }
        get(index) {
          for (const keySegment of this.keySegments()) {
            if (index < keySegment.length) return keySegment[index];
            index -= keySegment.length;
          }
        }
        get length() {
          return this.keySegments().flat().length;
        }
        compileInstructions(instructions) {
          if (256 < this.length)
            throw new Error(
              "Account index overflow encountered during compilation"
            );
          const keyIndexMap = new Map(),
            findKeyIndex =
              (this.keySegments()
                .flat()
                .forEach((key, index) => {
                  keyIndexMap.set(key.toBase58(), index);
                }),
              (key) => {
                key = keyIndexMap.get(key.toBase58());
                if (void 0 === key)
                  throw new Error(
                    "Encountered an unknown instruction account key during compilation"
                  );
                return key;
              });
          return instructions.map((instruction) => ({
            programIdIndex: findKeyIndex(instruction.programId),
            accountKeyIndexes: instruction.keys.map((meta) =>
              findKeyIndex(meta.pubkey)
            ),
            data: instruction.data,
          }));
        }
      }
      const publicKey = (property = "publicKey") => Layout.av(32, property),
        rustString = (property = "string") => {
          property = Layout.w3(
            [
              Layout.DH("length"),
              Layout.DH("lengthPadding"),
              Layout.av(Layout.cY(Layout.DH(), -8), "chars"),
            ],
            property
          );
          const _decode = property.decode.bind(property),
            _encode = property.encode.bind(property);
          return (
            (property.decode = (b, offset) => {
              return _decode(b, offset).chars.toString();
            }),
            (property.encode = (str, b, offset) => {
              str = { chars: node_modules_buffer.Buffer.from(str, "utf8") };
              return _encode(str, b, offset);
            }),
            (property.alloc = (str) =>
              Layout.DH().span +
              Layout.DH().span +
              node_modules_buffer.Buffer.from(str, "utf8").length),
            property
          );
        };
      function decodeLength(bytes) {
        let len = 0,
          size = 0;
        for (;;) {
          var elem = bytes.shift();
          if (
            ((len |= (127 & elem) << (7 * size)),
            (size += 1),
            0 == (128 & elem))
          )
            break;
        }
        return len;
      }
      function encodeLength(bytes, len) {
        let rem_len = len;
        for (;;) {
          var elem = 127 & rem_len;
          if (0 == (rem_len >>= 7)) {
            bytes.push(elem);
            break;
          }
          (elem |= 128), bytes.push(elem);
        }
      }
      function index_browser_esm_assert(condition, message) {
        if (!condition) throw new Error(message || "Assertion failed");
      }
      class CompiledKeys {
        constructor(payer, keyMetaMap) {
          (this.payer = void 0),
            (this.keyMetaMap = void 0),
            (this.payer = payer),
            (this.keyMetaMap = keyMetaMap);
        }
        static compile(instructions, payer) {
          const keyMetaMap = new Map();
          var getOrInsertDefault = (pubkey) => {
              pubkey = pubkey.toBase58();
              let keyMeta = keyMetaMap.get(pubkey);
              return (
                void 0 === keyMeta &&
                  ((keyMeta = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
                  keyMetaMap.set(pubkey, keyMeta)),
                keyMeta
              );
            },
            payerKeyMeta = getOrInsertDefault(payer);
          (payerKeyMeta.isSigner = !0), (payerKeyMeta.isWritable = !0);
          for (const ix of instructions) {
            getOrInsertDefault(ix.programId).isInvoked = !0;
            for (const accountMeta of ix.keys) {
              var keyMeta = getOrInsertDefault(accountMeta.pubkey);
              (keyMeta.isSigner ||= accountMeta.isSigner),
                (keyMeta.isWritable ||= accountMeta.isWritable);
            }
          }
          return new CompiledKeys(payer, keyMetaMap);
        }
        getMessageComponents() {
          var mapEntries = [...this.keyMetaMap.entries()],
            writableSigners =
              (index_browser_esm_assert(
                mapEntries.length <= 256,
                "Max static account keys length exceeded"
              ),
              mapEntries.filter(
                ([, meta]) => meta.isSigner && meta.isWritable
              )),
            readonlySigners = mapEntries.filter(
              ([, meta]) => meta.isSigner && !meta.isWritable
            ),
            writableNonSigners = mapEntries.filter(
              ([, meta]) => !meta.isSigner && meta.isWritable
            ),
            mapEntries = mapEntries.filter(
              ([, meta]) => !meta.isSigner && !meta.isWritable
            ),
            header = {
              numRequiredSignatures:
                writableSigners.length + readonlySigners.length,
              numReadonlySignedAccounts: readonlySigners.length,
              numReadonlyUnsignedAccounts: mapEntries.length,
            },
            [payerAddress] =
              (index_browser_esm_assert(
                0 < writableSigners.length,
                "Expected at least one writable signer key"
              ),
              writableSigners[0]),
            payerAddress =
              (index_browser_esm_assert(
                payerAddress === this.payer.toBase58(),
                "Expected first writable signer key to be the fee payer"
              ),
              [
                ...writableSigners.map(([address]) => new PublicKey(address)),
                ...readonlySigners.map(([address]) => new PublicKey(address)),
                ...writableNonSigners.map(
                  ([address]) => new PublicKey(address)
                ),
                ...mapEntries.map(([address]) => new PublicKey(address)),
              ]);
          return [header, payerAddress];
        }
        extractTableLookup(lookupTable) {
          var [writableIndexes, drainedWritableKeys] =
              this.drainKeysFoundInLookupTable(
                lookupTable.state.addresses,
                (keyMeta) =>
                  !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable
              ),
            [readonlyIndexes, drainedReadonlyKeys] =
              this.drainKeysFoundInLookupTable(
                lookupTable.state.addresses,
                (keyMeta) =>
                  !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable
              );
          if (0 !== writableIndexes.length || 0 !== readonlyIndexes.length)
            return [
              {
                accountKey: lookupTable.key,
                writableIndexes: writableIndexes,
                readonlyIndexes: readonlyIndexes,
              },
              { writable: drainedWritableKeys, readonly: drainedReadonlyKeys },
            ];
        }
        drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
          var address,
            keyMeta,
            lookupTableIndexes = new Array(),
            drainedKeys = new Array();
          for ([address, keyMeta] of this.keyMetaMap.entries())
            if (keyMetaFilter(keyMeta)) {
              const key = new PublicKey(address);
              var lookupTableIndex = lookupTableEntries.findIndex((entry) =>
                entry.equals(key)
              );
              0 <= lookupTableIndex &&
                (index_browser_esm_assert(
                  lookupTableIndex < 256,
                  "Max lookup table index exceeded"
                ),
                lookupTableIndexes.push(lookupTableIndex),
                drainedKeys.push(key),
                this.keyMetaMap.delete(address));
            }
          return [lookupTableIndexes, drainedKeys];
        }
      }
      function guardedShift(byteArray) {
        if (0 === byteArray.length)
          throw new Error("Reached end of buffer unexpectedly");
        return byteArray.shift();
      }
      function guardedSplice(byteArray, ...args) {
        var [start] = args;
        if (
          2 === args.length
            ? start + (args[1] ?? 0) > byteArray.length
            : start >= byteArray.length
        )
          throw new Error("Reached end of buffer unexpectedly");
        return byteArray.splice(...args);
      }
      class Message {
        constructor(args) {
          (this.header = void 0),
            (this.accountKeys = void 0),
            (this.recentBlockhash = void 0),
            (this.instructions = void 0),
            (this.indexToProgramIds = new Map()),
            (this.header = args.header),
            (this.accountKeys = args.accountKeys.map(
              (account) => new PublicKey(account)
            )),
            (this.recentBlockhash = args.recentBlockhash),
            (this.instructions = args.instructions),
            this.instructions.forEach((ix) =>
              this.indexToProgramIds.set(
                ix.programIdIndex,
                this.accountKeys[ix.programIdIndex]
              )
            );
        }
        get version() {
          return "legacy";
        }
        get staticAccountKeys() {
          return this.accountKeys;
        }
        get compiledInstructions() {
          return this.instructions.map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58_default().decode(ix.data),
          }));
        }
        get addressTableLookups() {
          return [];
        }
        getAccountKeys() {
          return new MessageAccountKeys(this.staticAccountKeys);
        }
        static compile(args) {
          var [header, staticAccountKeys] = CompiledKeys.compile(
              args.instructions,
              args.payerKey
            ).getMessageComponents(),
            instructions = new MessageAccountKeys(staticAccountKeys)
              .compileInstructions(args.instructions)
              .map((ix) => ({
                programIdIndex: ix.programIdIndex,
                accounts: ix.accountKeyIndexes,
                data: bs58_default().encode(ix.data),
              }));
          return new Message({
            header: header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions: instructions,
          });
        }
        isAccountSigner(index) {
          return index < this.header.numRequiredSignatures;
        }
        isAccountWritable(index) {
          var numSignedAccounts = this.header.numRequiredSignatures;
          return index >= this.header.numRequiredSignatures
            ? index - numSignedAccounts <
                this.accountKeys.length -
                  numSignedAccounts -
                  this.header.numReadonlyUnsignedAccounts
            : index < numSignedAccounts - this.header.numReadonlySignedAccounts;
        }
        isProgramId(index) {
          return this.indexToProgramIds.has(index);
        }
        programIds() {
          return [...this.indexToProgramIds.values()];
        }
        nonProgramIds() {
          return this.accountKeys.filter(
            (_, index) => !this.isProgramId(index)
          );
        }
        serialize() {
          var numKeys = this.accountKeys.length,
            keyCount = [],
            instructions =
              (encodeLength(keyCount, numKeys),
              this.instructions.map((instruction) => {
                var { accounts, programIdIndex } = instruction,
                  instruction = Array.from(
                    bs58_default().decode(instruction.data)
                  ),
                  keyIndicesCount = [],
                  dataCount =
                    (encodeLength(keyIndicesCount, accounts.length), []);
                return (
                  encodeLength(dataCount, instruction.length),
                  {
                    programIdIndex: programIdIndex,
                    keyIndicesCount:
                      node_modules_buffer.Buffer.from(keyIndicesCount),
                    keyIndices: accounts,
                    dataLength: node_modules_buffer.Buffer.from(dataCount),
                    data: instruction,
                  }
                );
              })),
            instructionCount = [];
          encodeLength(instructionCount, instructions.length);
          let instructionBuffer = node_modules_buffer.Buffer.alloc(1232),
            instructionBufferLength =
              (node_modules_buffer.Buffer.from(instructionCount).copy(
                instructionBuffer
              ),
              instructionCount.length);
          instructions.forEach((instruction) => {
            instruction = Layout.w3([
              Layout.u8("programIdIndex"),
              Layout.av(instruction.keyIndicesCount.length, "keyIndicesCount"),
              Layout.O6(
                Layout.u8("keyIndex"),
                instruction.keyIndices.length,
                "keyIndices"
              ),
              Layout.av(instruction.dataLength.length, "dataLength"),
              Layout.O6(
                Layout.u8("userdatum"),
                instruction.data.length,
                "data"
              ),
            ]).encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += instruction;
          }),
            (instructionBuffer = instructionBuffer.slice(
              0,
              instructionBufferLength
            ));
          (instructionCount = Layout.w3([
            Layout.av(1, "numRequiredSignatures"),
            Layout.av(1, "numReadonlySignedAccounts"),
            Layout.av(1, "numReadonlyUnsignedAccounts"),
            Layout.av(keyCount.length, "keyCount"),
            Layout.O6(publicKey("key"), numKeys, "keys"),
            publicKey("recentBlockhash"),
          ])),
            (instructions = {
              numRequiredSignatures: node_modules_buffer.Buffer.from([
                this.header.numRequiredSignatures,
              ]),
              numReadonlySignedAccounts: node_modules_buffer.Buffer.from([
                this.header.numReadonlySignedAccounts,
              ]),
              numReadonlyUnsignedAccounts: node_modules_buffer.Buffer.from([
                this.header.numReadonlyUnsignedAccounts,
              ]),
              keyCount: node_modules_buffer.Buffer.from(keyCount),
              keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
              recentBlockhash: bs58_default().decode(this.recentBlockhash),
            }),
            (numKeys = node_modules_buffer.Buffer.alloc(2048)),
            (keyCount = instructionCount.encode(instructions, numKeys));
          return (
            instructionBuffer.copy(numKeys, keyCount),
            numKeys.slice(0, keyCount + instructionBuffer.length)
          );
        }
        static from(buffer) {
          var byteArray = [...buffer],
            buffer = guardedShift(byteArray);
          if (buffer !== (127 & buffer))
            throw new Error(
              "Versioned messages must be deserialized with VersionedMessage.deserialize()"
            );
          var numReadonlySignedAccounts = guardedShift(byteArray),
            numReadonlyUnsignedAccounts = guardedShift(byteArray);
          const accountCount = decodeLength(byteArray);
          var accountKeys = [];
          for (let i = 0; i < accountCount; i++) {
            var account = guardedSplice(byteArray, 0, 32);
            accountKeys.push(
              new PublicKey(node_modules_buffer.Buffer.from(account))
            );
          }
          var recentBlockhash = guardedSplice(byteArray, 0, 32),
            instructionCount = decodeLength(byteArray),
            instructions = [];
          for (let i = 0; i < instructionCount; i++) {
            var programIdIndex = guardedShift(byteArray);
            const accountCount = decodeLength(byteArray);
            var accounts = guardedSplice(byteArray, 0, accountCount),
              dataSlice = guardedSplice(byteArray, 0, decodeLength(byteArray)),
              dataSlice = bs58_default().encode(
                node_modules_buffer.Buffer.from(dataSlice)
              );
            instructions.push({
              programIdIndex: programIdIndex,
              accounts: accounts,
              data: dataSlice,
            });
          }
          buffer = {
            header: {
              numRequiredSignatures: buffer,
              numReadonlySignedAccounts: numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts,
            },
            recentBlockhash: bs58_default().encode(
              node_modules_buffer.Buffer.from(recentBlockhash)
            ),
            accountKeys: accountKeys,
            instructions: instructions,
          };
          return new Message(buffer);
        }
      }
      class MessageV0 {
        constructor(args) {
          (this.header = void 0),
            (this.staticAccountKeys = void 0),
            (this.recentBlockhash = void 0),
            (this.compiledInstructions = void 0),
            (this.addressTableLookups = void 0),
            (this.header = args.header),
            (this.staticAccountKeys = args.staticAccountKeys),
            (this.recentBlockhash = args.recentBlockhash),
            (this.compiledInstructions = args.compiledInstructions),
            (this.addressTableLookups = args.addressTableLookups);
        }
        get version() {
          return 0;
        }
        get numAccountKeysFromLookups() {
          let count = 0;
          for (const lookup of this.addressTableLookups)
            count +=
              lookup.readonlyIndexes.length + lookup.writableIndexes.length;
          return count;
        }
        getAccountKeys(args) {
          let accountKeysFromLookups;
          if (
            args &&
            "accountKeysFromLookups" in args &&
            args.accountKeysFromLookups
          ) {
            if (
              this.numAccountKeysFromLookups !=
              args.accountKeysFromLookups.writable.length +
                args.accountKeysFromLookups.readonly.length
            )
              throw new Error(
                "Failed to get account keys because of a mismatch in the number of account keys from lookups"
              );
            accountKeysFromLookups = args.accountKeysFromLookups;
          } else if (
            args &&
            "addressLookupTableAccounts" in args &&
            args.addressLookupTableAccounts
          )
            accountKeysFromLookups = this.resolveAddressTableLookups(
              args.addressLookupTableAccounts
            );
          else if (0 < this.addressTableLookups.length)
            throw new Error(
              "Failed to get account keys because address table lookups were not resolved"
            );
          return new MessageAccountKeys(
            this.staticAccountKeys,
            accountKeysFromLookups
          );
        }
        isAccountSigner(index) {
          return index < this.header.numRequiredSignatures;
        }
        isAccountWritable(index) {
          var numSignedAccounts = this.header.numRequiredSignatures,
            numStaticAccountKeys = this.staticAccountKeys.length;
          return numStaticAccountKeys <= index
            ? index - numStaticAccountKeys <
                this.addressTableLookups.reduce(
                  (count, lookup) => count + lookup.writableIndexes.length,
                  0
                )
            : index >= this.header.numRequiredSignatures
            ? index - numSignedAccounts <
              numStaticAccountKeys -
                numSignedAccounts -
                this.header.numReadonlyUnsignedAccounts
            : index < numSignedAccounts - this.header.numReadonlySignedAccounts;
        }
        resolveAddressTableLookups(addressLookupTableAccounts) {
          var accountKeysFromLookups = { writable: [], readonly: [] };
          for (const tableLookup of this.addressTableLookups) {
            var tableAccount = addressLookupTableAccounts.find((account) =>
              account.key.equals(tableLookup.accountKey)
            );
            if (!tableAccount)
              throw new Error(
                "Failed to find address lookup table account for table key " +
                  tableLookup.accountKey.toBase58()
              );
            for (const index of tableLookup.writableIndexes) {
              if (!(index < tableAccount.state.addresses.length))
                throw new Error(
                  `Failed to find address for index ${index} in address lookup table ` +
                    tableLookup.accountKey.toBase58()
                );
              accountKeysFromLookups.writable.push(
                tableAccount.state.addresses[index]
              );
            }
            for (const index of tableLookup.readonlyIndexes) {
              if (!(index < tableAccount.state.addresses.length))
                throw new Error(
                  `Failed to find address for index ${index} in address lookup table ` +
                    tableLookup.accountKey.toBase58()
                );
              accountKeysFromLookups.readonly.push(
                tableAccount.state.addresses[index]
              );
            }
          }
          return accountKeysFromLookups;
        }
        static compile(args) {
          var compiledKeys = CompiledKeys.compile(
              args.instructions,
              args.payerKey
            ),
            addressTableLookups = new Array(),
            accountKeysFromLookups = {
              writable: new Array(),
              readonly: new Array(),
            };
          for (const lookupTable of args.addressLookupTableAccounts || []) {
            var writable,
              readonly,
              extractResult = compiledKeys.extractTableLookup(lookupTable);
            void 0 !== extractResult &&
              (([extractResult, { writable, readonly }] = extractResult),
              addressTableLookups.push(extractResult),
              accountKeysFromLookups.writable.push(...writable),
              accountKeysFromLookups.readonly.push(...readonly));
          }
          var [header, staticAccountKeys] = compiledKeys.getMessageComponents(),
            compiledInstructions = new MessageAccountKeys(
              staticAccountKeys,
              accountKeysFromLookups
            ).compileInstructions(args.instructions);
          return new MessageV0({
            header: header,
            staticAccountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions: compiledInstructions,
            addressTableLookups: addressTableLookups,
          });
        }
        serialize() {
          var encodedStaticAccountKeysLength = Array(),
            serializedInstructions =
              (encodeLength(
                encodedStaticAccountKeysLength,
                this.staticAccountKeys.length
              ),
              this.serializeInstructions()),
            encodedInstructionsLength = Array(),
            serializedAddressTableLookups =
              (encodeLength(
                encodedInstructionsLength,
                this.compiledInstructions.length
              ),
              this.serializeAddressTableLookups()),
            encodedAddressTableLookupsLength = Array(),
            messageLayout =
              (encodeLength(
                encodedAddressTableLookupsLength,
                this.addressTableLookups.length
              ),
              Layout.w3([
                Layout.u8("prefix"),
                Layout.w3(
                  [
                    Layout.u8("numRequiredSignatures"),
                    Layout.u8("numReadonlySignedAccounts"),
                    Layout.u8("numReadonlyUnsignedAccounts"),
                  ],
                  "header"
                ),
                Layout.av(
                  encodedStaticAccountKeysLength.length,
                  "staticAccountKeysLength"
                ),
                Layout.O6(
                  publicKey(),
                  this.staticAccountKeys.length,
                  "staticAccountKeys"
                ),
                publicKey("recentBlockhash"),
                Layout.av(
                  encodedInstructionsLength.length,
                  "instructionsLength"
                ),
                Layout.av(
                  serializedInstructions.length,
                  "serializedInstructions"
                ),
                Layout.av(
                  encodedAddressTableLookupsLength.length,
                  "addressTableLookupsLength"
                ),
                Layout.av(
                  serializedAddressTableLookups.length,
                  "serializedAddressTableLookups"
                ),
              ])),
            serializedMessage = new Uint8Array(1232),
            messageLayout = messageLayout.encode(
              {
                prefix: 128,
                header: this.header,
                staticAccountKeysLength: new Uint8Array(
                  encodedStaticAccountKeysLength
                ),
                staticAccountKeys: this.staticAccountKeys.map((key) =>
                  key.toBytes()
                ),
                recentBlockhash: bs58_default().decode(this.recentBlockhash),
                instructionsLength: new Uint8Array(encodedInstructionsLength),
                serializedInstructions: serializedInstructions,
                addressTableLookupsLength: new Uint8Array(
                  encodedAddressTableLookupsLength
                ),
                serializedAddressTableLookups: serializedAddressTableLookups,
              },
              serializedMessage
            );
          return serializedMessage.slice(0, messageLayout);
        }
        serializeInstructions() {
          let serializedLength = 0;
          var serializedInstructions = new Uint8Array(1232);
          for (const instruction of this.compiledInstructions) {
            var encodedAccountKeyIndexesLength = Array(),
              encodedDataLength =
                (encodeLength(
                  encodedAccountKeyIndexesLength,
                  instruction.accountKeyIndexes.length
                ),
                Array()),
              instructionLayout =
                (encodeLength(encodedDataLength, instruction.data.length),
                Layout.w3([
                  Layout.u8("programIdIndex"),
                  Layout.av(
                    encodedAccountKeyIndexesLength.length,
                    "encodedAccountKeyIndexesLength"
                  ),
                  Layout.O6(
                    Layout.u8(),
                    instruction.accountKeyIndexes.length,
                    "accountKeyIndexes"
                  ),
                  Layout.av(encodedDataLength.length, "encodedDataLength"),
                  Layout.av(instruction.data.length, "data"),
                ]));
            serializedLength += instructionLayout.encode(
              {
                programIdIndex: instruction.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(
                  encodedAccountKeyIndexesLength
                ),
                accountKeyIndexes: instruction.accountKeyIndexes,
                encodedDataLength: new Uint8Array(encodedDataLength),
                data: instruction.data,
              },
              serializedInstructions,
              serializedLength
            );
          }
          return serializedInstructions.slice(0, serializedLength);
        }
        serializeAddressTableLookups() {
          let serializedLength = 0;
          var serializedAddressTableLookups = new Uint8Array(1232);
          for (const lookup of this.addressTableLookups) {
            var encodedWritableIndexesLength = Array(),
              encodedReadonlyIndexesLength =
                (encodeLength(
                  encodedWritableIndexesLength,
                  lookup.writableIndexes.length
                ),
                Array()),
              addressTableLookupLayout =
                (encodeLength(
                  encodedReadonlyIndexesLength,
                  lookup.readonlyIndexes.length
                ),
                Layout.w3([
                  publicKey("accountKey"),
                  Layout.av(
                    encodedWritableIndexesLength.length,
                    "encodedWritableIndexesLength"
                  ),
                  Layout.O6(
                    Layout.u8(),
                    lookup.writableIndexes.length,
                    "writableIndexes"
                  ),
                  Layout.av(
                    encodedReadonlyIndexesLength.length,
                    "encodedReadonlyIndexesLength"
                  ),
                  Layout.O6(
                    Layout.u8(),
                    lookup.readonlyIndexes.length,
                    "readonlyIndexes"
                  ),
                ]));
            serializedLength += addressTableLookupLayout.encode(
              {
                accountKey: lookup.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(
                  encodedWritableIndexesLength
                ),
                writableIndexes: lookup.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(
                  encodedReadonlyIndexesLength
                ),
                readonlyIndexes: lookup.readonlyIndexes,
              },
              serializedAddressTableLookups,
              serializedLength
            );
          }
          return serializedAddressTableLookups.slice(0, serializedLength);
        }
        static deserialize(serializedMessage) {
          var byteArray = [...serializedMessage],
            serializedMessage = guardedShift(byteArray),
            maskedPrefix = 127 & serializedMessage,
            serializedMessage =
              (index_browser_esm_assert(
                serializedMessage !== maskedPrefix,
                "Expected versioned message but received legacy message"
              ),
              maskedPrefix),
            maskedPrefix =
              (index_browser_esm_assert(
                0 == serializedMessage,
                "Expected versioned message with version 0 but found version " +
                  serializedMessage
              ),
              {
                numRequiredSignatures: guardedShift(byteArray),
                numReadonlySignedAccounts: guardedShift(byteArray),
                numReadonlyUnsignedAccounts: guardedShift(byteArray),
              }),
            staticAccountKeys = [],
            staticAccountKeysLength = decodeLength(byteArray);
          for (let i = 0; i < staticAccountKeysLength; i++)
            staticAccountKeys.push(
              new PublicKey(guardedSplice(byteArray, 0, 32))
            );
          var serializedMessage = bs58_default().encode(
              guardedSplice(byteArray, 0, 32)
            ),
            instructionCount = decodeLength(byteArray),
            compiledInstructions = [];
          for (let i = 0; i < instructionCount; i++) {
            var programIdIndex = guardedShift(byteArray),
              accountKeyIndexes = guardedSplice(
                byteArray,
                0,
                decodeLength(byteArray)
              ),
              dataLength = decodeLength(byteArray),
              dataLength = new Uint8Array(
                guardedSplice(byteArray, 0, dataLength)
              );
            compiledInstructions.push({
              programIdIndex: programIdIndex,
              accountKeyIndexes: accountKeyIndexes,
              data: dataLength,
            });
          }
          var addressTableLookupsCount = decodeLength(byteArray),
            addressTableLookups = [];
          for (let i = 0; i < addressTableLookupsCount; i++) {
            var accountKey = new PublicKey(guardedSplice(byteArray, 0, 32)),
              writableIndexes = guardedSplice(
                byteArray,
                0,
                decodeLength(byteArray)
              ),
              readonlyIndexes = guardedSplice(
                byteArray,
                0,
                decodeLength(byteArray)
              );
            addressTableLookups.push({
              accountKey: accountKey,
              writableIndexes: writableIndexes,
              readonlyIndexes: readonlyIndexes,
            });
          }
          return new MessageV0({
            header: maskedPrefix,
            staticAccountKeys: staticAccountKeys,
            recentBlockhash: serializedMessage,
            compiledInstructions: compiledInstructions,
            addressTableLookups: addressTableLookups,
          });
        }
      }
      const VersionedMessage = {
        deserializeMessageVersion(serializedMessage) {
          var serializedMessage = serializedMessage[0],
            maskedPrefix = 127 & serializedMessage;
          return maskedPrefix === serializedMessage ? "legacy" : maskedPrefix;
        },
        deserialize: (serializedMessage) => {
          var version =
            VersionedMessage.deserializeMessageVersion(serializedMessage);
          if ("legacy" === version) return Message.from(serializedMessage);
          if (0 === version) return MessageV0.deserialize(serializedMessage);
          throw new Error(
            `Transaction message version ${version} deserialization is not supported`
          );
        },
      };
      let TransactionStatus = (function (TransactionStatus) {
        return (
          (TransactionStatus[(TransactionStatus.BLOCKHEIGHT_EXCEEDED = 0)] =
            "BLOCKHEIGHT_EXCEEDED"),
          (TransactionStatus[(TransactionStatus.PROCESSED = 1)] = "PROCESSED"),
          (TransactionStatus[(TransactionStatus.TIMED_OUT = 2)] = "TIMED_OUT"),
          (TransactionStatus[(TransactionStatus.NONCE_INVALID = 3)] =
            "NONCE_INVALID"),
          TransactionStatus
        );
      })({});
      const DEFAULT_SIGNATURE = node_modules_buffer.Buffer.alloc(
        SIGNATURE_LENGTH_IN_BYTES
      ).fill(0);
      class TransactionInstruction {
        constructor(opts) {
          (this.keys = void 0),
            (this.programId = void 0),
            (this.data = node_modules_buffer.Buffer.alloc(0)),
            (this.programId = opts.programId),
            (this.keys = opts.keys),
            opts.data && (this.data = opts.data);
        }
        toJSON() {
          return {
            keys: this.keys.map(({ pubkey, isSigner, isWritable }) => ({
              pubkey: pubkey.toJSON(),
              isSigner: isSigner,
              isWritable: isWritable,
            })),
            programId: this.programId.toJSON(),
            data: [...this.data],
          };
        }
      }
      class Transaction {
        get signature() {
          return 0 < this.signatures.length
            ? this.signatures[0].signature
            : null;
        }
        constructor(opts) {
          if (
            ((this.signatures = []),
            (this.feePayer = void 0),
            (this.instructions = []),
            (this.recentBlockhash = void 0),
            (this.lastValidBlockHeight = void 0),
            (this.nonceInfo = void 0),
            (this.minNonceContextSlot = void 0),
            (this._message = void 0),
            (this._json = void 0),
            opts)
          )
            if (
              (opts.feePayer && (this.feePayer = opts.feePayer),
              opts.signatures && (this.signatures = opts.signatures),
              Object.prototype.hasOwnProperty.call(opts, "nonceInfo"))
            ) {
              var { minContextSlot, nonceInfo } = opts;
              (this.minNonceContextSlot = minContextSlot),
                (this.nonceInfo = nonceInfo);
            } else if (
              Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")
            ) {
              var {
                blockhash: minContextSlot,
                lastValidBlockHeight: nonceInfo,
              } = opts;
              (this.recentBlockhash = minContextSlot),
                (this.lastValidBlockHeight = nonceInfo);
            } else {
              const { recentBlockhash, nonceInfo } = opts;
              nonceInfo && (this.nonceInfo = nonceInfo),
                (this.recentBlockhash = recentBlockhash);
            }
        }
        toJSON() {
          return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo
              ? {
                  nonce: this.nonceInfo.nonce,
                  nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
                }
              : null,
            instructions: this.instructions.map((instruction) =>
              instruction.toJSON()
            ),
            signers: this.signatures.map(({ publicKey }) => publicKey.toJSON()),
          };
        }
        add(...items) {
          if (0 === items.length) throw new Error("No instructions");
          return (
            items.forEach((item) => {
              "instructions" in item
                ? (this.instructions = this.instructions.concat(
                    item.instructions
                  ))
                : "data" in item && "programId" in item && "keys" in item
                ? this.instructions.push(item)
                : this.instructions.push(new TransactionInstruction(item));
            }),
            this
          );
        }
        compileMessage() {
          if (
            this._message &&
            JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
          )
            return this._message;
          let recentBlockhash, instructions;
          if (
            ((instructions = this.nonceInfo
              ? ((recentBlockhash = this.nonceInfo.nonce),
                this.instructions[0] != this.nonceInfo.nonceInstruction
                  ? [this.nonceInfo.nonceInstruction, ...this.instructions]
                  : this.instructions)
              : ((recentBlockhash = this.recentBlockhash), this.instructions)),
            !recentBlockhash)
          )
            throw new Error("Transaction recentBlockhash required");
          instructions.length < 1 && console.warn("No instructions provided");
          let feePayer;
          if (this.feePayer) feePayer = this.feePayer;
          else {
            if (!(0 < this.signatures.length && this.signatures[0].publicKey))
              throw new Error("Transaction fee payer required");
            feePayer = this.signatures[0].publicKey;
          }
          for (let i = 0; i < instructions.length; i++)
            if (void 0 === instructions[i].programId)
              throw new Error(
                `Transaction instruction index ${i} has undefined program id`
              );
          const programIds = [],
            accountMetas = [],
            uniqueMetas =
              (instructions.forEach((instruction) => {
                instruction.keys.forEach((accountMeta) => {
                  accountMetas.push({ ...accountMeta });
                });
                instruction = instruction.programId.toString();
                programIds.includes(instruction) ||
                  programIds.push(instruction);
              }),
              programIds.forEach((programId) => {
                accountMetas.push({
                  pubkey: new PublicKey(programId),
                  isSigner: !1,
                  isWritable: !1,
                });
              }),
              []);
          accountMetas.forEach((accountMeta) => {
            const pubkeyString = accountMeta.pubkey.toString();
            var uniqueIndex = uniqueMetas.findIndex(
              (x) => x.pubkey.toString() === pubkeyString
            );
            -1 < uniqueIndex
              ? ((uniqueMetas[uniqueIndex].isWritable =
                  uniqueMetas[uniqueIndex].isWritable ||
                  accountMeta.isWritable),
                (uniqueMetas[uniqueIndex].isSigner =
                  uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner))
              : uniqueMetas.push(accountMeta);
          }),
            uniqueMetas.sort(function (x, y) {
              return x.isSigner !== y.isSigner
                ? x.isSigner
                  ? -1
                  : 1
                : x.isWritable !== y.isWritable
                ? x.isWritable
                  ? -1
                  : 1
                : x.pubkey
                    .toBase58()
                    .localeCompare(y.pubkey.toBase58(), "en", {
                      localeMatcher: "best fit",
                      usage: "sort",
                      sensitivity: "variant",
                      ignorePunctuation: !1,
                      numeric: !1,
                      caseFirst: "lower",
                    });
            });
          var feePayerIndex = uniqueMetas.findIndex((x) =>
            x.pubkey.equals(feePayer)
          );
          -1 < feePayerIndex
            ? (([feePayerIndex] = uniqueMetas.splice(feePayerIndex, 1)),
              (feePayerIndex.isSigner = !0),
              (feePayerIndex.isWritable = !0),
              uniqueMetas.unshift(feePayerIndex))
            : uniqueMetas.unshift({
                pubkey: feePayer,
                isSigner: !0,
                isWritable: !0,
              });
          for (const signature of this.signatures) {
            var uniqueIndex = uniqueMetas.findIndex((x) =>
              x.pubkey.equals(signature.publicKey)
            );
            if (!(-1 < uniqueIndex))
              throw new Error(
                "unknown signer: " + signature.publicKey.toString()
              );
            uniqueMetas[uniqueIndex].isSigner ||
              ((uniqueMetas[uniqueIndex].isSigner = !0),
              console.warn(
                "Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."
              ));
          }
          let numRequiredSignatures = 0,
            numReadonlySignedAccounts = 0,
            numReadonlyUnsignedAccounts = 0;
          const signedKeys = [],
            unsignedKeys = [],
            accountKeys =
              (uniqueMetas.forEach(({ pubkey, isSigner, isWritable }) => {
                isSigner
                  ? (signedKeys.push(pubkey.toString()),
                    (numRequiredSignatures += 1),
                    isWritable || (numReadonlySignedAccounts += 1))
                  : (unsignedKeys.push(pubkey.toString()),
                    isWritable || (numReadonlyUnsignedAccounts += 1));
              }),
              signedKeys.concat(unsignedKeys));
          feePayerIndex = instructions.map((instruction) => {
            var { data, programId } = instruction;
            return {
              programIdIndex: accountKeys.indexOf(programId.toString()),
              accounts: instruction.keys.map((meta) =>
                accountKeys.indexOf(meta.pubkey.toString())
              ),
              data: bs58_default().encode(data),
            };
          });
          return (
            feePayerIndex.forEach((instruction) => {
              index_browser_esm_assert(0 <= instruction.programIdIndex),
                instruction.accounts.forEach((keyIndex) =>
                  index_browser_esm_assert(0 <= keyIndex)
                );
            }),
            new Message({
              header: {
                numRequiredSignatures: numRequiredSignatures,
                numReadonlySignedAccounts: numReadonlySignedAccounts,
                numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts,
              },
              accountKeys: accountKeys,
              recentBlockhash: recentBlockhash,
              instructions: feePayerIndex,
            })
          );
        }
        _compile() {
          var message = this.compileMessage();
          const signedKeys = message.accountKeys.slice(
            0,
            message.header.numRequiredSignatures
          );
          if (
            this.signatures.length === signedKeys.length &&
            this.signatures.every((pair, index) =>
              signedKeys[index].equals(pair.publicKey)
            )
          )
            return message;
          return (
            (this.signatures = signedKeys.map((publicKey) => ({
              signature: null,
              publicKey: publicKey,
            }))),
            message
          );
        }
        serializeMessage() {
          return this._compile().serialize();
        }
        async getEstimatedFee(connection) {
          return (await connection.getFeeForMessage(this.compileMessage()))
            .value;
        }
        setSigners(...signers) {
          if (0 === signers.length) throw new Error("No signers");
          const seen = new Set();
          this.signatures = signers
            .filter((publicKey) => {
              publicKey = publicKey.toString();
              return !seen.has(publicKey) && (seen.add(publicKey), !0);
            })
            .map((publicKey) => ({ signature: null, publicKey: publicKey }));
        }
        sign(...signers) {
          if (0 === signers.length) throw new Error("No signers");
          var seen = new Set(),
            uniqueSigners = [];
          for (const signer of signers) {
            var key = signer.publicKey.toString();
            seen.has(key) || (seen.add(key), uniqueSigners.push(signer));
          }
          this.signatures = uniqueSigners.map((signer) => ({
            signature: null,
            publicKey: signer.publicKey,
          }));
          signers = this._compile();
          this._partialSign(signers, ...uniqueSigners);
        }
        partialSign(...signers) {
          if (0 === signers.length) throw new Error("No signers");
          var seen = new Set(),
            uniqueSigners = [];
          for (const signer of signers) {
            var key = signer.publicKey.toString();
            seen.has(key) || (seen.add(key), uniqueSigners.push(signer));
          }
          signers = this._compile();
          this._partialSign(signers, ...uniqueSigners);
        }
        _partialSign(message, ...signers) {
          const signData = message.serialize();
          signers.forEach((signer) => {
            var signature = sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, toBuffer(signature));
          });
        }
        addSignature(pubkey, signature) {
          this._compile(), this._addSignature(pubkey, signature);
        }
        _addSignature(pubkey, signature) {
          index_browser_esm_assert(64 === signature.length);
          var index = this.signatures.findIndex((sigpair) =>
            pubkey.equals(sigpair.publicKey)
          );
          if (index < 0)
            throw new Error("unknown signer: " + pubkey.toString());
          this.signatures[index].signature =
            node_modules_buffer.Buffer.from(signature);
        }
        verifySignatures(requireAllSignatures = !0) {
          return !this._getMessageSignednessErrors(
            this.serializeMessage(),
            requireAllSignatures
          );
        }
        _getMessageSignednessErrors(message, requireAllSignatures) {
          var signature,
            publicKey,
            errors = {};
          for ({ signature, publicKey } of this.signatures)
            null === signature
              ? requireAllSignatures && (errors.missing ||= []).push(publicKey)
              : verify(signature, message, publicKey.toBytes()) ||
                (errors.invalid ||= []).push(publicKey);
          return errors.invalid || errors.missing ? errors : void 0;
        }
        serialize(config) {
          var { requireAllSignatures: config, verifySignatures } =
              Object.assign(
                { requireAllSignatures: !0, verifySignatures: !0 },
                config
              ),
            signData = this.serializeMessage();
          if (verifySignatures) {
            verifySignatures = this._getMessageSignednessErrors(
              signData,
              config
            );
            if (verifySignatures) {
              let errorMessage = "Signature verification failed.";
              throw (
                (verifySignatures.invalid &&
                  (errorMessage += `
Invalid signature for public key${
                    1 === verifySignatures.invalid.length ? "" : "(s)"
                  } [\`${verifySignatures.invalid
                    .map((p) => p.toBase58())
                    .join("`, `")}\`].`),
                verifySignatures.missing &&
                  (errorMessage += `
Missing signature for public key${
                    1 === verifySignatures.missing.length ? "" : "(s)"
                  } [\`${verifySignatures.missing
                    .map((p) => p.toBase58())
                    .join("`, `")}\`].`),
                new Error(errorMessage))
              );
            }
          }
          return this._serialize(signData);
        }
        _serialize(signData) {
          var signatures = this["signatures"];
          const signatureCount = [];
          encodeLength(signatureCount, signatures.length);
          var transactionLength =
            signatureCount.length + 64 * signatures.length + signData.length;
          const wireTransaction =
            node_modules_buffer.Buffer.alloc(transactionLength);
          return (
            index_browser_esm_assert(signatures.length < 256),
            node_modules_buffer.Buffer.from(signatureCount).copy(
              wireTransaction,
              0
            ),
            signatures.forEach(({ signature }, index) => {
              null !== signature &&
                (index_browser_esm_assert(
                  64 === signature.length,
                  "signature has invalid length"
                ),
                node_modules_buffer.Buffer.from(signature).copy(
                  wireTransaction,
                  signatureCount.length + 64 * index
                ));
            }),
            signData.copy(
              wireTransaction,
              signatureCount.length + 64 * signatures.length
            ),
            index_browser_esm_assert(
              wireTransaction.length <= 1232,
              `Transaction too large: ${wireTransaction.length} > 1232`
            ),
            wireTransaction
          );
        }
        get keys() {
          return (
            index_browser_esm_assert(1 === this.instructions.length),
            this.instructions[0].keys.map((keyObj) => keyObj.pubkey)
          );
        }
        get programId() {
          return (
            index_browser_esm_assert(1 === this.instructions.length),
            this.instructions[0].programId
          );
        }
        get data() {
          return (
            index_browser_esm_assert(1 === this.instructions.length),
            this.instructions[0].data
          );
        }
        static from(buffer) {
          var byteArray = [...buffer],
            signatureCount = decodeLength(byteArray),
            signatures = [];
          for (let i = 0; i < signatureCount; i++) {
            var signature = guardedSplice(
              byteArray,
              0,
              SIGNATURE_LENGTH_IN_BYTES
            );
            signatures.push(
              bs58_default().encode(node_modules_buffer.Buffer.from(signature))
            );
          }
          return Transaction.populate(Message.from(byteArray), signatures);
        }
        static populate(message, signatures = []) {
          const transaction = new Transaction();
          return (
            (transaction.recentBlockhash = message.recentBlockhash),
            0 < message.header.numRequiredSignatures &&
              (transaction.feePayer = message.accountKeys[0]),
            signatures.forEach((signature, index) => {
              signature = {
                signature:
                  signature == bs58_default().encode(DEFAULT_SIGNATURE)
                    ? null
                    : bs58_default().decode(signature),
                publicKey: message.accountKeys[index],
              };
              transaction.signatures.push(signature);
            }),
            message.instructions.forEach((instruction) => {
              var keys = instruction.accounts.map((account) => {
                const pubkey = message.accountKeys[account];
                return {
                  pubkey: pubkey,
                  isSigner:
                    transaction.signatures.some(
                      (keyObj) =>
                        keyObj.publicKey.toString() === pubkey.toString()
                    ) || message.isAccountSigner(account),
                  isWritable: message.isAccountWritable(account),
                };
              });
              transaction.instructions.push(
                new TransactionInstruction({
                  keys: keys,
                  programId: message.accountKeys[instruction.programIdIndex],
                  data: bs58_default().decode(instruction.data),
                })
              );
            }),
            (transaction._message = message),
            (transaction._json = transaction.toJSON()),
            transaction
          );
        }
      }
      class VersionedTransaction {
        get version() {
          return this.message.version;
        }
        constructor(message, signatures) {
          if (
            ((this.signatures = void 0), (this.message = void 0) !== signatures)
          )
            index_browser_esm_assert(
              signatures.length === message.header.numRequiredSignatures,
              "Expected signatures length to be equal to the number of required signatures"
            ),
              (this.signatures = signatures);
          else {
            var defaultSignatures = [];
            for (let i = 0; i < message.header.numRequiredSignatures; i++)
              defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            this.signatures = defaultSignatures;
          }
          this.message = message;
        }
        serialize() {
          var serializedMessage = this.message.serialize(),
            encodedSignaturesLength = Array(),
            property =
              (encodeLength(encodedSignaturesLength, this.signatures.length),
              Layout.w3([
                Layout.av(
                  encodedSignaturesLength.length,
                  "encodedSignaturesLength"
                ),
                Layout.O6(
                  ((property = "signature"), Layout.av(64, property)),
                  this.signatures.length,
                  "signatures"
                ),
                Layout.av(serializedMessage.length, "serializedMessage"),
              ])),
            serializedTransaction = new Uint8Array(2048),
            property = property.encode(
              {
                encodedSignaturesLength: new Uint8Array(
                  encodedSignaturesLength
                ),
                signatures: this.signatures,
                serializedMessage: serializedMessage,
              },
              serializedTransaction
            );
          return serializedTransaction.slice(0, property);
        }
        static deserialize(serializedTransaction) {
          var byteArray = [...serializedTransaction],
            signatures = [],
            signaturesLength = decodeLength(byteArray);
          for (let i = 0; i < signaturesLength; i++)
            signatures.push(
              new Uint8Array(
                guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)
              )
            );
          serializedTransaction = VersionedMessage.deserialize(
            new Uint8Array(byteArray)
          );
          return new VersionedTransaction(serializedTransaction, signatures);
        }
        sign(signers) {
          var messageData = this.message.serialize(),
            signerPubkeys = this.message.staticAccountKeys.slice(
              0,
              this.message.header.numRequiredSignatures
            );
          for (const signer of signers) {
            var signerIndex = signerPubkeys.findIndex((pubkey) =>
              pubkey.equals(signer.publicKey)
            );
            index_browser_esm_assert(
              0 <= signerIndex,
              "Cannot sign with non signer key " + signer.publicKey.toBase58()
            ),
              (this.signatures[signerIndex] = sign(
                messageData,
                signer.secretKey
              ));
          }
        }
        addSignature(publicKey, signature) {
          index_browser_esm_assert(
            64 === signature.byteLength,
            "Signature must be 64 bytes long"
          );
          var signerIndex = this.message.staticAccountKeys
            .slice(0, this.message.header.numRequiredSignatures)
            .findIndex((pubkey) => pubkey.equals(publicKey));
          index_browser_esm_assert(
            0 <= signerIndex,
            `Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`
          ),
            (this.signatures[signerIndex] = signature);
        }
      }
      const SYSVAR_CLOCK_PUBKEY = new PublicKey(
        "SysvarC1ock11111111111111111111111111111111"
      );
      new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),
        new PublicKey("Sysvar1nstructions1111111111111111111111111");
      const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(
          "SysvarRecentB1ockHashes11111111111111111111"
        ),
        SYSVAR_RENT_PUBKEY = new PublicKey(
          "SysvarRent111111111111111111111111111111111"
        );
      new PublicKey("SysvarRewards111111111111111111111111111111"),
        new PublicKey("SysvarS1otHashes111111111111111111111111111"),
        new PublicKey("SysvarS1otHistory11111111111111111111111111");
      const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(
        "SysvarStakeHistory1111111111111111111111111"
      );
      class SendTransactionError extends Error {
        constructor({ action, signature, transactionMessage, logs }) {
          let message;
          switch (action) {
            case "send":
              message =
                `Transaction ${signature} resulted in an error. 
` +
                transactionMessage +
                ". " +
                (logs
                  ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. `
                  : "") +
                "\nCatch the SendTransactionError and call `getLogs()` on it for full details.";
              break;
            case "simulate":
              message =
                `Simulation failed. 
Message: ${transactionMessage}. 
` +
                (logs
                  ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. `
                  : "") +
                "\nCatch the SendTransactionError and call `getLogs()` on it for full details.";
              break;
            default:
              message = "Unknown action";
          }
          super(message),
            (this.signature = void 0),
            (this.transactionMessage = void 0),
            (this.logs = void 0),
            (this.signature = signature),
            (this.transactionMessage = transactionMessage),
            (this.logs = logs || void 0);
        }
        get transactionError() {
          return {
            message: this.transactionMessage,
            logs: Array.isArray(this.logs) ? this.logs : void 0,
          };
        }
        async getLogs(connection) {
          return (
            Array.isArray(this.logs) ||
              (this.logs = new Promise((resolve, reject) => {
                connection
                  .getTransaction(this.signature)
                  .then((tx) => {
                    tx && tx.meta && tx.meta.logMessages
                      ? ((tx = tx.meta.logMessages),
                        (this.logs = tx),
                        resolve(tx))
                      : reject(new Error("Log messages not found"));
                  })
                  .catch(reject);
              })),
            this.logs
          );
        }
      }
      class SolanaJSONRPCError extends Error {
        constructor({ code, message, data }, customMessage) {
          super(
            null != customMessage ? customMessage + ": " + message : message
          ),
            (this.code = void 0),
            (this.data = void 0),
            (this.code = code),
            (this.data = data),
            (this.name = "SolanaJSONRPCError");
        }
      }
      async function sendAndConfirmTransaction(
        connection,
        transaction,
        signers,
        options
      ) {
        var sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment:
              options.preflightCommitment || options.commitment,
            maxRetries: options.maxRetries,
            minContextSlot: options.minContextSlot,
          },
          signers = await connection.sendTransaction(
            transaction,
            signers,
            sendOptions
          );
        let status;
        if (
          (status = (
            null != transaction.recentBlockhash &&
            null != transaction.lastValidBlockHeight
              ? await connection.confirmTransaction(
                  {
                    abortSignal: options?.abortSignal,
                    signature: signers,
                    blockhash: transaction.recentBlockhash,
                    lastValidBlockHeight: transaction.lastValidBlockHeight,
                  },
                  options && options.commitment
                )
              : null != transaction.minNonceContextSlot &&
                null != transaction.nonceInfo
              ? ((sendOptions = transaction.nonceInfo["nonceInstruction"]),
                (sendOptions = sendOptions.keys[0].pubkey),
                await connection.confirmTransaction(
                  {
                    abortSignal: options?.abortSignal,
                    minContextSlot: transaction.minNonceContextSlot,
                    nonceAccountPubkey: sendOptions,
                    nonceValue: transaction.nonceInfo.nonce,
                    signature: signers,
                  },
                  options && options.commitment
                ))
              : (null != options?.abortSignal &&
                  console.warn(
                    "sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."
                  ),
                await connection.confirmTransaction(
                  signers,
                  options && options.commitment
                ))
          ).value).err
        ) {
          if (null != signers)
            throw new SendTransactionError({
              action: "send",
              signature: signers,
              transactionMessage: `Status: (${JSON.stringify(status)})`,
            });
          throw new Error(
            `Transaction ${signers} failed (${JSON.stringify(status)})`
          );
        }
        return signers;
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      function encodeData(type, fields) {
        var allocLength =
            0 <= type.layout.span
              ? type.layout.span
              : (function getAlloc(type, fields) {
                  const getItemAlloc = (item) => {
                    if (0 <= item.span) return item.span;
                    if ("function" == typeof item.alloc)
                      return item.alloc(fields[item.property]);
                    if ("count" in item && "elementLayout" in item) {
                      var field = fields[item.property];
                      if (Array.isArray(field))
                        return field.length * getItemAlloc(item.elementLayout);
                    } else if ("fields" in item)
                      return getAlloc({ layout: item }, fields[item.property]);
                    return 0;
                  };
                  let alloc = 0;
                  return (
                    type.layout.fields.forEach((item) => {
                      alloc += getItemAlloc(item);
                    }),
                    alloc
                  );
                })(type, fields),
          allocLength = node_modules_buffer.Buffer.alloc(allocLength),
          fields = Object.assign({ instruction: type.index }, fields);
        return type.layout.encode(fields, allocLength), allocLength;
      }
      __webpack_require__ = Layout.I0("lamportsPerSignature");
      const NonceAccountLayout = Layout.w3([
          Layout.DH("version"),
          Layout.DH("state"),
          publicKey("authorizedPubkey"),
          publicKey("nonce"),
          Layout.w3([__webpack_require__], "feeCalculator"),
        ]),
        NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
      class NonceAccount {
        constructor(args) {
          (this.authorizedPubkey = void 0),
            (this.nonce = void 0),
            (this.feeCalculator = void 0),
            (this.authorizedPubkey = args.authorizedPubkey),
            (this.nonce = args.nonce),
            (this.feeCalculator = args.feeCalculator);
        }
        static fromAccountData(buffer) {
          buffer = NonceAccountLayout.decode(toBuffer(buffer), 0);
          return new NonceAccount({
            authorizedPubkey: new PublicKey(buffer.authorizedPubkey),
            nonce: new PublicKey(buffer.nonce).toString(),
            feeCalculator: buffer.feeCalculator,
          });
        }
      }
      length = 8;
      var length,
        __webpack_exports__ = (property) => {
          property = (0, Layout.av)(length, property);
          const { encode, decode } = ((layout) => {
            return {
              decode: layout.decode.bind(layout),
              encode: layout.encode.bind(layout),
            };
          })(property);
          return (
            (property.decode = (buffer, offset) => {
              buffer = decode(buffer, offset);
              return (0, browser.k5)(node_modules_buffer.Buffer.from(buffer));
            }),
            (property.encode = (bigInt, buffer, offset) => {
              bigInt = (0, browser.Bq)(bigInt, length);
              return encode(bigInt, buffer, offset);
            }),
            property
          );
        };
      const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
        Create: {
          index: 0,
          layout: Layout.w3([
            Layout.DH("instruction"),
            Layout.Wg("lamports"),
            Layout.Wg("space"),
            publicKey("programId"),
          ]),
        },
        Assign: {
          index: 1,
          layout: Layout.w3([Layout.DH("instruction"), publicKey("programId")]),
        },
        Transfer: {
          index: 2,
          layout: Layout.w3([
            Layout.DH("instruction"),
            __webpack_exports__("lamports"),
          ]),
        },
        CreateWithSeed: {
          index: 3,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("base"),
            rustString("seed"),
            Layout.Wg("lamports"),
            Layout.Wg("space"),
            publicKey("programId"),
          ]),
        },
        AdvanceNonceAccount: {
          index: 4,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
        WithdrawNonceAccount: {
          index: 5,
          layout: Layout.w3([Layout.DH("instruction"), Layout.Wg("lamports")]),
        },
        InitializeNonceAccount: {
          index: 6,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("authorized"),
          ]),
        },
        AuthorizeNonceAccount: {
          index: 7,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("authorized"),
          ]),
        },
        Allocate: {
          index: 8,
          layout: Layout.w3([Layout.DH("instruction"), Layout.Wg("space")]),
        },
        AllocateWithSeed: {
          index: 9,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("base"),
            rustString("seed"),
            Layout.Wg("space"),
            publicKey("programId"),
          ]),
        },
        AssignWithSeed: {
          index: 10,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("base"),
            rustString("seed"),
            publicKey("programId"),
          ]),
        },
        TransferWithSeed: {
          index: 11,
          layout: Layout.w3([
            Layout.DH("instruction"),
            __webpack_exports__("lamports"),
            rustString("seed"),
            publicKey("programId"),
          ]),
        },
        UpgradeNonceAccount: {
          index: 12,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
      });
      class SystemProgram {
        constructor() {}
        static createAccount(params) {
          var data = encodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create, {
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer()),
          });
          return new TransactionInstruction({
            keys: [
              { pubkey: params.fromPubkey, isSigner: !0, isWritable: !0 },
              { pubkey: params.newAccountPubkey, isSigner: !0, isWritable: !0 },
            ],
            programId: this.programId,
            data: data,
          });
        }
        static transfer(params) {
          let data, keys;
          if ("basePubkey" in params) {
            var type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            (data = encodeData(type, {
              lamports: BigInt(params.lamports),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer()),
            })),
              (keys = [
                { pubkey: params.fromPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: params.basePubkey, isSigner: !0, isWritable: !1 },
                { pubkey: params.toPubkey, isSigner: !1, isWritable: !0 },
              ]);
          } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            (data = encodeData(type, { lamports: BigInt(params.lamports) })),
              (keys = [
                { pubkey: params.fromPubkey, isSigner: !0, isWritable: !0 },
                { pubkey: params.toPubkey, isSigner: !1, isWritable: !0 },
              ]);
          }
          return new TransactionInstruction({
            keys: keys,
            programId: this.programId,
            data: data,
          });
        }
        static assign(params) {
          let data, keys;
          if ("basePubkey" in params) {
            var type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            (data = encodeData(type, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer()),
            })),
              (keys = [
                { pubkey: params.accountPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: params.basePubkey, isSigner: !0, isWritable: !1 },
              ]);
          } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            (data = encodeData(type, {
              programId: toBuffer(params.programId.toBuffer()),
            })),
              (keys = [
                { pubkey: params.accountPubkey, isSigner: !0, isWritable: !0 },
              ]);
          }
          return new TransactionInstruction({
            keys: keys,
            programId: this.programId,
            data: data,
          });
        }
        static createAccountWithSeed(params) {
          var data = encodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              lamports: params.lamports,
              space: params.space,
              programId: toBuffer(params.programId.toBuffer()),
            }),
            keys = [
              { pubkey: params.fromPubkey, isSigner: !0, isWritable: !0 },
              { pubkey: params.newAccountPubkey, isSigner: !1, isWritable: !0 },
            ];
          return (
            params.basePubkey != params.fromPubkey &&
              keys.push({
                pubkey: params.basePubkey,
                isSigner: !0,
                isWritable: !1,
              }),
            new TransactionInstruction({
              keys: keys,
              programId: this.programId,
              data: data,
            })
          );
        }
        static createNonceAccount(params) {
          var transaction = new Transaction(),
            params =
              ("basePubkey" in params && "seed" in params
                ? transaction.add(
                    SystemProgram.createAccountWithSeed({
                      fromPubkey: params.fromPubkey,
                      newAccountPubkey: params.noncePubkey,
                      basePubkey: params.basePubkey,
                      seed: params.seed,
                      lamports: params.lamports,
                      space: NONCE_ACCOUNT_LENGTH,
                      programId: this.programId,
                    })
                  )
                : transaction.add(
                    SystemProgram.createAccount({
                      fromPubkey: params.fromPubkey,
                      newAccountPubkey: params.noncePubkey,
                      lamports: params.lamports,
                      space: NONCE_ACCOUNT_LENGTH,
                      programId: this.programId,
                    })
                  ),
              {
                noncePubkey: params.noncePubkey,
                authorizedPubkey: params.authorizedPubkey,
              });
          return transaction.add(this.nonceInitialize(params)), transaction;
        }
        static nonceInitialize(params) {
          var data = encodeData(
              SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,
              { authorized: toBuffer(params.authorizedPubkey.toBuffer()) }
            ),
            params = {
              keys: [
                { pubkey: params.noncePubkey, isSigner: !1, isWritable: !0 },
                {
                  pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                  isSigner: !1,
                  isWritable: !1,
                },
                { pubkey: SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
              ],
              programId: this.programId,
              data: data,
            };
          return new TransactionInstruction(params);
        }
        static nonceAdvance(params) {
          var data = encodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount),
            params = {
              keys: [
                { pubkey: params.noncePubkey, isSigner: !1, isWritable: !0 },
                {
                  pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                  isSigner: !1,
                  isWritable: !1,
                },
                {
                  pubkey: params.authorizedPubkey,
                  isSigner: !0,
                  isWritable: !1,
                },
              ],
              programId: this.programId,
              data: data,
            };
          return new TransactionInstruction(params);
        }
        static nonceWithdraw(params) {
          var data = encodeData(
            SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,
            { lamports: params.lamports }
          );
          return new TransactionInstruction({
            keys: [
              { pubkey: params.noncePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: params.toPubkey, isSigner: !1, isWritable: !0 },
              {
                pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                isSigner: !1,
                isWritable: !1,
              },
              { pubkey: SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
              { pubkey: params.authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: data,
          });
        }
        static nonceAuthorize(params) {
          var data = encodeData(
            SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,
            { authorized: toBuffer(params.newAuthorizedPubkey.toBuffer()) }
          );
          return new TransactionInstruction({
            keys: [
              { pubkey: params.noncePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: params.authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: data,
          });
        }
        static allocate(params) {
          let data, keys;
          if ("basePubkey" in params) {
            var type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            (data = encodeData(type, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              space: params.space,
              programId: toBuffer(params.programId.toBuffer()),
            })),
              (keys = [
                { pubkey: params.accountPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: params.basePubkey, isSigner: !0, isWritable: !1 },
              ]);
          } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            (data = encodeData(type, { space: params.space })),
              (keys = [
                { pubkey: params.accountPubkey, isSigner: !0, isWritable: !0 },
              ]);
          }
          return new TransactionInstruction({
            keys: keys,
            programId: this.programId,
            data: data,
          });
        }
      }
      SystemProgram.programId = new PublicKey(
        "11111111111111111111111111111111"
      );
      class Loader {
        constructor() {}
        static getMinNumSignatures(dataLength) {
          return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
        }
        static async load(connection, payer, program, programId, data) {
          {
            var balanceNeeded =
                await connection.getMinimumBalanceForRentExemption(data.length),
              programInfo = await connection.getAccountInfo(
                program.publicKey,
                "confirmed"
              );
            let transaction = null;
            if (null !== programInfo) {
              if (programInfo.executable)
                return (
                  console.error(
                    "Program load failed, account is already executable"
                  ),
                  !1
                );
              programInfo.data.length !== data.length &&
                (transaction = transaction || new Transaction()).add(
                  SystemProgram.allocate({
                    accountPubkey: program.publicKey,
                    space: data.length,
                  })
                ),
                programInfo.owner.equals(programId) ||
                  (transaction = transaction || new Transaction()).add(
                    SystemProgram.assign({
                      accountPubkey: program.publicKey,
                      programId: programId,
                    })
                  ),
                programInfo.lamports < balanceNeeded &&
                  (transaction = transaction || new Transaction()).add(
                    SystemProgram.transfer({
                      fromPubkey: payer.publicKey,
                      toPubkey: program.publicKey,
                      lamports: balanceNeeded - programInfo.lamports,
                    })
                  );
            } else
              transaction = new Transaction().add(
                SystemProgram.createAccount({
                  fromPubkey: payer.publicKey,
                  newAccountPubkey: program.publicKey,
                  lamports: 0 < balanceNeeded ? balanceNeeded : 1,
                  space: data.length,
                  programId: programId,
                })
              );
            null !== transaction &&
              (await sendAndConfirmTransaction(
                connection,
                transaction,
                [payer, program],
                { commitment: "confirmed" }
              ));
          }
          const dataLayout = Layout.w3([
            Layout.DH("instruction"),
            Layout.DH("offset"),
            Layout.DH("bytesLength"),
            Layout.DH("bytesLengthPadding"),
            Layout.O6(Layout.u8("byte"), Layout.cY(Layout.DH(), -8), "bytes"),
          ]);
          var chunkSize = Loader.chunkSize;
          let offset = 0,
            array = data;
          for (var transactions = []; 0 < array.length; ) {
            var bytes = array.slice(0, chunkSize);
            const data = node_modules_buffer.Buffer.alloc(chunkSize + 16);
            dataLayout.encode(
              {
                instruction: 0,
                offset: offset,
                bytes: bytes,
                bytesLength: 0,
                bytesLengthPadding: 0,
              },
              data
            );
            bytes = new Transaction().add({
              keys: [
                { pubkey: program.publicKey, isSigner: !0, isWritable: !0 },
              ],
              programId: programId,
              data: data,
            });
            transactions.push(
              sendAndConfirmTransaction(connection, bytes, [payer, program], {
                commitment: "confirmed",
              })
            ),
              connection._rpcEndpoint.includes("solana.com") &&
                (await sleep(250)),
              (offset += chunkSize),
              (array = array.slice(chunkSize));
          }
          await Promise.all(transactions);
          {
            const dataLayout = Layout.w3([Layout.DH("instruction")]),
              data = node_modules_buffer.Buffer.alloc(dataLayout.span),
              transaction =
                (dataLayout.encode({ instruction: 1 }, data),
                new Transaction().add({
                  keys: [
                    { pubkey: program.publicKey, isSigner: !0, isWritable: !0 },
                    {
                      pubkey: SYSVAR_RENT_PUBKEY,
                      isSigner: !1,
                      isWritable: !1,
                    },
                  ],
                  programId: programId,
                  data: data,
                }));
            var programInfo = await connection.sendTransaction(
                transaction,
                [payer, program],
                { preflightCommitment: "processed" }
              ),
              { context, value: balanceNeeded } =
                await connection.confirmTransaction(
                  {
                    signature: programInfo,
                    lastValidBlockHeight: transaction.lastValidBlockHeight,
                    blockhash: transaction.recentBlockhash,
                  },
                  "processed"
                );
            if (balanceNeeded.err)
              throw new Error(
                `Transaction ${programInfo} failed (${JSON.stringify(
                  balanceNeeded
                )})`
              );
            for (;;) {
              try {
                if (
                  (await connection.getSlot({ commitment: "processed" })) >
                  context.slot
                )
                  break;
              } catch {}
              await new Promise((resolve) =>
                setTimeout(resolve, Math.round(200))
              );
            }
          }
          return !0;
        }
      }
      Loader.chunkSize = 932;
      new PublicKey("BPFLoader2111111111111111111111111111111111");
      function getDefaultExportFromCjs(x) {
        return x &&
          x.__esModule &&
          Object.prototype.hasOwnProperty.call(x, "default")
          ? x.default
          : x;
      }
      var objToString = Object.prototype.toString,
        objKeys =
          Object.keys ||
          function (obj) {
            var name,
              keys = [];
            for (name in obj) keys.push(name);
            return keys;
          };
      var fastStableStringify$1 = getDefaultExportFromCjs(function (val) {
        val = (function stringify(val, isArrayProp) {
          var i, max, str, keys, key, propVal, toStr;
          if (!0 === val) return "true";
          if (!1 === val) return "false";
          switch (typeof val) {
            case "object":
              if (null === val) return null;
              if (val.toJSON && "function" == typeof val.toJSON)
                return stringify(val.toJSON(), isArrayProp);
              if ("[object Array]" === (toStr = objToString.call(val))) {
                for (str = "[", max = val.length - 1, i = 0; i < max; i++)
                  str += stringify(val[i], !0) + ",";
                return -1 < max && (str += stringify(val[i], !0)), str + "]";
              }
              if ("[object Object]" !== toStr) return JSON.stringify(val);
              for (
                max = (keys = objKeys(val).sort()).length, str = "", i = 0;
                i < max;

              )
                void 0 !== (propVal = stringify(val[(key = keys[i])], !1)) &&
                  (str && (str += ","),
                  (str += JSON.stringify(key) + ":" + propVal)),
                  i++;
              return "{" + str + "}";
            case "function":
            case "undefined":
              return isArrayProp ? null : void 0;
            case "string":
              return JSON.stringify(val);
            default:
              return isFinite(val) ? val : null;
          }
        })(val, !1);
        if (void 0 !== val) return "" + val;
      });
      function trailingZeros(n) {
        let trailingZeros = 0;
        for (; 1 < n; ) (n /= 2), trailingZeros++;
        return trailingZeros;
      }
      class EpochSchedule {
        constructor(
          slotsPerEpoch,
          leaderScheduleSlotOffset,
          warmup,
          firstNormalEpoch,
          firstNormalSlot
        ) {
          (this.slotsPerEpoch = void 0),
            (this.leaderScheduleSlotOffset = void 0),
            (this.warmup = void 0),
            (this.firstNormalEpoch = void 0),
            (this.firstNormalSlot = void 0),
            (this.slotsPerEpoch = slotsPerEpoch),
            (this.leaderScheduleSlotOffset = leaderScheduleSlotOffset),
            (this.warmup = warmup),
            (this.firstNormalEpoch = firstNormalEpoch),
            (this.firstNormalSlot = firstNormalSlot);
        }
        getEpoch(slot) {
          return this.getEpochAndSlotIndex(slot)[0];
        }
        getEpochAndSlotIndex(slot) {
          var epoch;
          if (slot < this.firstNormalSlot)
            return [
              (epoch =
                trailingZeros(
                  (function nextPowerOfTwo(n) {
                    return 0 === n
                      ? 1
                      : (n--,
                        (n =
                          (n =
                            (n =
                              (n = (n = (n |= n >> 1) | (n >> 2)) | (n >> 4)) |
                              (n >> 8)) |
                            (n >> 16)) |
                          (n >> 32)) + 1);
                  })(slot + 32 + 1)
                ) -
                trailingZeros(32) -
                1),
              slot - (this.getSlotsInEpoch(epoch) - 32),
            ];
          {
            var slot = slot - this.firstNormalSlot,
              normalEpochIndex = Math.floor(slot / this.slotsPerEpoch);
            const epoch = this.firstNormalEpoch + normalEpochIndex,
              slotIndex = slot % this.slotsPerEpoch;
            return [epoch, slotIndex];
          }
        }
        getFirstSlotInEpoch(epoch) {
          return epoch <= this.firstNormalEpoch
            ? 32 * (Math.pow(2, epoch) - 1)
            : (epoch - this.firstNormalEpoch) * this.slotsPerEpoch +
                this.firstNormalSlot;
        }
        getLastSlotInEpoch(epoch) {
          return (
            this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1
          );
        }
        getSlotsInEpoch(epoch) {
          return epoch < this.firstNormalEpoch
            ? Math.pow(2, epoch + trailingZeros(32))
            : this.slotsPerEpoch;
        }
      }
      var fetchImpl = globalThis.fetch;
      class RpcWebSocketClient extends sha512_sha512.A {
        constructor(address, options, generate_request_id) {
          super(
            (url) => {
              url = (0, websocket_browser.A)(url, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...options,
              });
              return (
                "socket" in url
                  ? (this.underlyingSocket = url.socket)
                  : (this.underlyingSocket = url),
                url
              );
            },
            address,
            options,
            generate_request_id
          ),
            (this.underlyingSocket = void 0);
        }
        call(...args) {
          var readyState = this.underlyingSocket?.readyState;
          return 1 === readyState
            ? super.call(...args)
            : Promise.reject(
                new Error(
                  "Tried to call a JSON-RPC method `" +
                    args[0] +
                    "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                    readyState +
                    ")"
                )
              );
        }
        notify(...args) {
          var readyState = this.underlyingSocket?.readyState;
          return 1 === readyState
            ? super.notify(...args)
            : Promise.reject(
                new Error(
                  "Tried to send a JSON-RPC notification `" +
                    args[0] +
                    "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                    readyState +
                    ")"
                )
              );
        }
      }
      class AddressLookupTableAccount {
        constructor(args) {
          (this.key = void 0),
            (this.state = void 0),
            (this.key = args.key),
            (this.state = args.state);
        }
        isActive() {
          var U64_MAX = BigInt("0xffffffffffffffff");
          return this.state.deactivationSlot === U64_MAX;
        }
        static deserialize(accountData) {
          var meta = (function decodeData(type, data) {
              let decoded;
              try {
                decoded = type.layout.decode(data);
              } catch (err) {
                throw new Error("invalid instruction; " + err);
              }
              if (decoded.typeIndex !== type.index)
                throw new Error(
                  `invalid account data; account type mismatch ${decoded.typeIndex} != ` +
                    type.index
                );
              return decoded;
            })(LookupTableMetaLayout, accountData),
            serializedAddressesLen = accountData.length - 56,
            serializedAddressesLen =
              (index_browser_esm_assert(
                0 <= serializedAddressesLen,
                "lookup table is invalid"
              ),
              index_browser_esm_assert(
                serializedAddressesLen % 32 == 0,
                "lookup table is invalid"
              ),
              serializedAddressesLen / 32),
            serializedAddressesLen = Layout.w3([
              Layout.O6(publicKey(), serializedAddressesLen, "addresses"),
            ]).decode(accountData.slice(56))["addresses"];
          return {
            deactivationSlot: meta.deactivationSlot,
            lastExtendedSlot: meta.lastExtendedSlot,
            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
            authority:
              0 !== meta.authority.length
                ? new PublicKey(meta.authority[0])
                : void 0,
            addresses: serializedAddressesLen.map(
              (address) => new PublicKey(address)
            ),
          };
        }
      }
      const LookupTableMetaLayout = {
          index: 1,
          layout: Layout.w3([
            Layout.DH("typeIndex"),
            __webpack_exports__("deactivationSlot"),
            Layout.I0("lastExtendedSlot"),
            Layout.u8("lastExtendedStartIndex"),
            Layout.u8(),
            Layout.O6(publicKey(), Layout.cY(Layout.u8(), -1), "authority"),
          ]),
        },
        URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
      const PublicKeyFromString = coerce(
        instance(PublicKey),
        string(),
        (value) => new PublicKey(value)
      );
      __webpack_require__ = tuple([string(), literal("base64")]);
      const BufferFromRawAccountData = coerce(
        instance(node_modules_buffer.Buffer),
        __webpack_require__,
        (value) => node_modules_buffer.Buffer.from(value[0], "base64")
      );
      function extractCommitmentFromConfig(commitmentOrConfig) {
        let commitment, config;
        if ("string" == typeof commitmentOrConfig)
          commitment = commitmentOrConfig;
        else if (commitmentOrConfig) {
          const { commitment: specifiedCommitment, ...specifiedConfig } =
            commitmentOrConfig;
          (commitment = specifiedCommitment), (config = specifiedConfig);
        }
        return { commitment: commitment, config: config };
      }
      function createRpcResult(result) {
        return union([
          type({ jsonrpc: literal("2.0"), id: string(), result: result }),
          type({
            jsonrpc: literal("2.0"),
            id: string(),
            error: type({
              code: unknown(),
              message: string(),
              data: optional(
                (function any() {
                  return dist_define("any", () => !0);
                })()
              ),
            }),
          }),
        ]);
      }
      const UnknownRpcResult = createRpcResult(unknown());
      function jsonRpcResult(schema) {
        return coerce(createRpcResult(schema), UnknownRpcResult, (value) =>
          "error" in value
            ? value
            : { ...value, result: create(value.result, schema) }
        );
      }
      function jsonRpcResultAndContext(value) {
        return jsonRpcResult(
          type({ context: type({ slot: dist_number() }), value: value })
        );
      }
      function notificationResultAndContext(value) {
        return type({ context: type({ slot: dist_number() }), value: value });
      }
      function versionedMessageFromResponse(version, response) {
        return 0 === version
          ? new MessageV0({
              header: response.header,
              staticAccountKeys: response.accountKeys.map(
                (accountKey) => new PublicKey(accountKey)
              ),
              recentBlockhash: response.recentBlockhash,
              compiledInstructions: response.instructions.map((ix) => ({
                programIdIndex: ix.programIdIndex,
                accountKeyIndexes: ix.accounts,
                data: bs58_default().decode(ix.data),
              })),
              addressTableLookups: response.addressTableLookups,
            })
          : new Message(response);
      }
      sha512_sha512 = type({
        foundation: dist_number(),
        foundationTerm: dist_number(),
        initial: dist_number(),
        taper: dist_number(),
        terminal: dist_number(),
      });
      const GetInflationRewardResult = jsonRpcResult(
        array(
          nullable(
            type({
              epoch: dist_number(),
              effectiveSlot: dist_number(),
              amount: dist_number(),
              postBalance: dist_number(),
              commission: optional(nullable(dist_number())),
            })
          )
        )
      );
      var GetRecentPrioritizationFeesResult = array(
          type({ slot: dist_number(), prioritizationFee: dist_number() })
        ),
        GetInflationRateResult = type({
          total: dist_number(),
          validator: dist_number(),
          foundation: dist_number(),
          epoch: dist_number(),
        }),
        GetEpochInfoResult = type({
          epoch: dist_number(),
          slotIndex: dist_number(),
          slotsInEpoch: dist_number(),
          absoluteSlot: dist_number(),
          blockHeight: optional(dist_number()),
          transactionCount: optional(dist_number()),
        }),
        GetEpochScheduleResult = type({
          slotsPerEpoch: dist_number(),
          leaderScheduleSlotOffset: dist_number(),
          warmup: dist_boolean(),
          firstNormalEpoch: dist_number(),
          firstNormalSlot: dist_number(),
        }),
        GetLeaderScheduleResult = record(string(), array(dist_number())),
        TransactionErrorResult = nullable(union([type({}), string()])),
        SignatureStatusResult = type({ err: TransactionErrorResult }),
        SignatureReceivedResult = literal("receivedSignature");
      const VersionResult = type({
          "solana-core": string(),
          "feature-set": optional(dist_number()),
        }),
        SimulatedTransactionResponseStruct = jsonRpcResultAndContext(
          type({
            err: nullable(union([type({}), string()])),
            logs: nullable(array(string())),
            accounts: optional(
              nullable(
                array(
                  nullable(
                    type({
                      executable: dist_boolean(),
                      owner: string(),
                      lamports: dist_number(),
                      data: array(string()),
                      rentEpoch: optional(dist_number()),
                    })
                  )
                )
              )
            ),
            unitsConsumed: optional(dist_number()),
            returnData: optional(
              nullable(
                type({
                  programId: string(),
                  data: tuple([string(), literal("base64")]),
                })
              )
            ),
          })
        ),
        BlockProductionResponseStruct = jsonRpcResultAndContext(
          type({
            byIdentity: record(string(), array(dist_number())),
            range: type({ firstSlot: dist_number(), lastSlot: dist_number() }),
          })
        );
      const GetInflationGovernorRpcResult = jsonRpcResult(sha512_sha512),
        GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult),
        GetRecentPrioritizationFeesRpcResult = jsonRpcResult(
          GetRecentPrioritizationFeesResult
        ),
        GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult),
        GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult),
        GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult),
        SlotRpcResult = jsonRpcResult(dist_number()),
        GetSupplyRpcResult = jsonRpcResultAndContext(
          type({
            total: dist_number(),
            circulating: dist_number(),
            nonCirculating: dist_number(),
            nonCirculatingAccounts: array(PublicKeyFromString),
          })
        ),
        TokenAmountResult = type({
          amount: string(),
          uiAmount: nullable(dist_number()),
          decimals: dist_number(),
          uiAmountString: optional(string()),
        }),
        GetTokenLargestAccountsResult = jsonRpcResultAndContext(
          array(
            type({
              address: PublicKeyFromString,
              amount: string(),
              uiAmount: nullable(dist_number()),
              decimals: dist_number(),
              uiAmountString: optional(string()),
            })
          )
        ),
        GetTokenAccountsByOwner = jsonRpcResultAndContext(
          array(
            type({
              pubkey: PublicKeyFromString,
              account: type({
                executable: dist_boolean(),
                owner: PublicKeyFromString,
                lamports: dist_number(),
                data: BufferFromRawAccountData,
                rentEpoch: dist_number(),
              }),
            })
          )
        );
      sha512_sha512 = type({
        program: string(),
        parsed: unknown(),
        space: dist_number(),
      });
      const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(
          array(
            type({
              pubkey: PublicKeyFromString,
              account: type({
                executable: dist_boolean(),
                owner: PublicKeyFromString,
                lamports: dist_number(),
                data: sha512_sha512,
                rentEpoch: dist_number(),
              }),
            })
          )
        ),
        GetLargestAccountsRpcResult = jsonRpcResultAndContext(
          array(type({ lamports: dist_number(), address: PublicKeyFromString }))
        ),
        AccountInfoResult = type({
          executable: dist_boolean(),
          owner: PublicKeyFromString,
          lamports: dist_number(),
          data: BufferFromRawAccountData,
          rentEpoch: dist_number(),
        }),
        KeyedAccountInfoResult = type({
          pubkey: PublicKeyFromString,
          account: AccountInfoResult,
        });
      GetInflationRateResult = coerce(
        union([instance(node_modules_buffer.Buffer), sha512_sha512]),
        union([__webpack_require__, sha512_sha512]),
        (value) =>
          Array.isArray(value) ? create(value, BufferFromRawAccountData) : value
      );
      const ParsedAccountInfoResult = type({
          executable: dist_boolean(),
          owner: PublicKeyFromString,
          lamports: dist_number(),
          data: GetInflationRateResult,
          rentEpoch: dist_number(),
        }),
        KeyedParsedAccountInfoResult = type({
          pubkey: PublicKeyFromString,
          account: ParsedAccountInfoResult,
        }),
        StakeActivationResult = type({
          state: union([
            literal("active"),
            literal("inactive"),
            literal("activating"),
            literal("deactivating"),
          ]),
          active: dist_number(),
          inactive: dist_number(),
        }),
        GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(
          array(
            type({
              signature: string(),
              slot: dist_number(),
              err: TransactionErrorResult,
              memo: nullable(string()),
              blockTime: optional(nullable(dist_number())),
            })
          )
        ),
        GetSignaturesForAddressRpcResult = jsonRpcResult(
          array(
            type({
              signature: string(),
              slot: dist_number(),
              err: TransactionErrorResult,
              memo: nullable(string()),
              blockTime: optional(nullable(dist_number())),
            })
          )
        ),
        AccountNotificationResult = type({
          subscription: dist_number(),
          result: notificationResultAndContext(AccountInfoResult),
        });
      GetRecentPrioritizationFeesResult = type({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult,
      });
      const ProgramAccountNotificationResult = type({
        subscription: dist_number(),
        result: notificationResultAndContext(GetRecentPrioritizationFeesResult),
      });
      GetEpochInfoResult = type({
        parent: dist_number(),
        slot: dist_number(),
        root: dist_number(),
      });
      const SlotNotificationResult = type({
        subscription: dist_number(),
        result: GetEpochInfoResult,
      });
      GetEpochScheduleResult = union([
        type({
          type: union([
            literal("firstShredReceived"),
            literal("completed"),
            literal("optimisticConfirmation"),
            literal("root"),
          ]),
          slot: dist_number(),
          timestamp: dist_number(),
        }),
        type({
          type: literal("createdBank"),
          parent: dist_number(),
          slot: dist_number(),
          timestamp: dist_number(),
        }),
        type({
          type: literal("frozen"),
          slot: dist_number(),
          timestamp: dist_number(),
          stats: type({
            numTransactionEntries: dist_number(),
            numSuccessfulTransactions: dist_number(),
            numFailedTransactions: dist_number(),
            maxTransactionsPerEntry: dist_number(),
          }),
        }),
        type({
          type: literal("dead"),
          slot: dist_number(),
          timestamp: dist_number(),
          err: string(),
        }),
      ]);
      const SlotUpdateNotificationResult = type({
          subscription: dist_number(),
          result: GetEpochScheduleResult,
        }),
        SignatureNotificationResult = type({
          subscription: dist_number(),
          result: notificationResultAndContext(
            union([SignatureStatusResult, SignatureReceivedResult])
          ),
        }),
        RootNotificationResult = type({
          subscription: dist_number(),
          result: dist_number(),
        }),
        ContactInfoResult = type({
          pubkey: string(),
          gossip: nullable(string()),
          tpu: nullable(string()),
          rpc: nullable(string()),
          version: nullable(string()),
        });
      GetLeaderScheduleResult = type({
        votePubkey: string(),
        nodePubkey: string(),
        activatedStake: dist_number(),
        epochVoteAccount: dist_boolean(),
        epochCredits: array(
          tuple([dist_number(), dist_number(), dist_number()])
        ),
        commission: dist_number(),
        lastVote: dist_number(),
        rootSlot: nullable(dist_number()),
      });
      const GetVoteAccounts = jsonRpcResult(
        type({
          current: array(GetLeaderScheduleResult),
          delinquent: array(GetLeaderScheduleResult),
        })
      );
      (__webpack_require__ = union([
        literal("processed"),
        literal("confirmed"),
        literal("finalized"),
      ])),
        (sha512_sha512 = type({
          slot: dist_number(),
          confirmations: nullable(dist_number()),
          err: TransactionErrorResult,
          confirmationStatus: optional(__webpack_require__),
        }));
      const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(
          array(nullable(sha512_sha512))
        ),
        GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(
          dist_number()
        );
      (GetInflationRateResult = type({
        accountKey: PublicKeyFromString,
        writableIndexes: array(dist_number()),
        readonlyIndexes: array(dist_number()),
      })),
        (GetRecentPrioritizationFeesResult = type({
          signatures: array(string()),
          message: type({
            accountKeys: array(string()),
            header: type({
              numRequiredSignatures: dist_number(),
              numReadonlySignedAccounts: dist_number(),
              numReadonlyUnsignedAccounts: dist_number(),
            }),
            instructions: array(
              type({
                accounts: array(dist_number()),
                data: string(),
                programIdIndex: dist_number(),
              })
            ),
            recentBlockhash: string(),
            addressTableLookups: optional(array(GetInflationRateResult)),
          }),
        })),
        (GetEpochInfoResult = type({
          pubkey: PublicKeyFromString,
          signer: dist_boolean(),
          writable: dist_boolean(),
          source: optional(
            union([literal("transaction"), literal("lookupTable")])
          ),
        })),
        (GetEpochScheduleResult = type({
          accountKeys: array(GetEpochInfoResult),
          signatures: array(string()),
        }));
      const ParsedInstructionResult = type({
          parsed: unknown(),
          program: string(),
          programId: PublicKeyFromString,
        }),
        RawInstructionResult = type({
          accounts: array(PublicKeyFromString),
          data: string(),
          programId: PublicKeyFromString,
        });
      (SignatureStatusResult = coerce(
        union([RawInstructionResult, ParsedInstructionResult]),
        union([
          type({ parsed: unknown(), program: string(), programId: string() }),
          type({
            accounts: array(string()),
            data: string(),
            programId: string(),
          }),
        ]),
        (value) =>
          "accounts" in value
            ? create(value, RawInstructionResult)
            : create(value, ParsedInstructionResult)
      )),
        (SignatureReceivedResult = type({
          signatures: array(string()),
          message: type({
            accountKeys: array(GetEpochInfoResult),
            instructions: array(SignatureStatusResult),
            recentBlockhash: string(),
            addressTableLookups: optional(
              nullable(array(GetInflationRateResult))
            ),
          }),
        })),
        (GetLeaderScheduleResult = type({
          accountIndex: dist_number(),
          mint: string(),
          owner: optional(string()),
          uiTokenAmount: TokenAmountResult,
        })),
        (__webpack_require__ = type({
          writable: array(PublicKeyFromString),
          readonly: array(PublicKeyFromString),
        })),
        (sha512_sha512 = type({
          err: TransactionErrorResult,
          fee: dist_number(),
          innerInstructions: optional(
            nullable(
              array(
                type({
                  index: dist_number(),
                  instructions: array(
                    type({
                      accounts: array(dist_number()),
                      data: string(),
                      programIdIndex: dist_number(),
                    })
                  ),
                })
              )
            )
          ),
          preBalances: array(dist_number()),
          postBalances: array(dist_number()),
          logMessages: optional(nullable(array(string()))),
          preTokenBalances: optional(nullable(array(GetLeaderScheduleResult))),
          postTokenBalances: optional(nullable(array(GetLeaderScheduleResult))),
          loadedAddresses: optional(__webpack_require__),
          computeUnitsConsumed: optional(dist_number()),
        })),
        (GetEpochInfoResult = type({
          err: TransactionErrorResult,
          fee: dist_number(),
          innerInstructions: optional(
            nullable(
              array(
                type({
                  index: dist_number(),
                  instructions: array(SignatureStatusResult),
                })
              )
            )
          ),
          preBalances: array(dist_number()),
          postBalances: array(dist_number()),
          logMessages: optional(nullable(array(string()))),
          preTokenBalances: optional(nullable(array(GetLeaderScheduleResult))),
          postTokenBalances: optional(nullable(array(GetLeaderScheduleResult))),
          loadedAddresses: optional(__webpack_require__),
          computeUnitsConsumed: optional(dist_number()),
        })),
        (GetInflationRateResult = union([literal(0), literal("legacy")])),
        (SignatureStatusResult = type({
          pubkey: string(),
          lamports: dist_number(),
          postBalance: nullable(dist_number()),
          rewardType: nullable(string()),
          commission: optional(nullable(dist_number())),
        }));
      const GetBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              transactions: array(
                type({
                  transaction: GetRecentPrioritizationFeesResult,
                  meta: nullable(sha512_sha512),
                  version: optional(GetInflationRateResult),
                })
              ),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetNoneModeBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetAccountsModeBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              transactions: array(
                type({
                  transaction: GetEpochScheduleResult,
                  meta: nullable(sha512_sha512),
                  version: optional(GetInflationRateResult),
                })
              ),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetParsedBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              transactions: array(
                type({
                  transaction: SignatureReceivedResult,
                  meta: nullable(GetEpochInfoResult),
                  version: optional(GetInflationRateResult),
                })
              ),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetParsedAccountsModeBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              transactions: array(
                type({
                  transaction: GetEpochScheduleResult,
                  meta: nullable(GetEpochInfoResult),
                  version: optional(GetInflationRateResult),
                })
              ),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetParsedNoneModeBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
              blockHeight: nullable(dist_number()),
            })
          )
        ),
        GetConfirmedBlockRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              transactions: array(
                type({
                  transaction: GetRecentPrioritizationFeesResult,
                  meta: nullable(sha512_sha512),
                })
              ),
              rewards: optional(array(SignatureStatusResult)),
              blockTime: nullable(dist_number()),
            })
          )
        ),
        GetBlockSignaturesRpcResult = jsonRpcResult(
          nullable(
            type({
              blockhash: string(),
              previousBlockhash: string(),
              parentSlot: dist_number(),
              signatures: array(string()),
              blockTime: nullable(dist_number()),
            })
          )
        ),
        GetTransactionRpcResult = jsonRpcResult(
          nullable(
            type({
              slot: dist_number(),
              meta: nullable(sha512_sha512),
              blockTime: optional(nullable(dist_number())),
              transaction: GetRecentPrioritizationFeesResult,
              version: optional(GetInflationRateResult),
            })
          )
        ),
        GetParsedTransactionRpcResult = jsonRpcResult(
          nullable(
            type({
              slot: dist_number(),
              transaction: SignatureReceivedResult,
              meta: nullable(GetEpochInfoResult),
              blockTime: optional(nullable(dist_number())),
              version: optional(GetInflationRateResult),
            })
          )
        ),
        GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(
          type({
            blockhash: string(),
            feeCalculator: type({ lamportsPerSignature: dist_number() }),
          })
        ),
        GetLatestBlockhashRpcResult = jsonRpcResultAndContext(
          type({ blockhash: string(), lastValidBlockHeight: dist_number() })
        ),
        IsBlockhashValidRpcResult = jsonRpcResultAndContext(dist_boolean()),
        GetRecentPerformanceSamplesRpcResult = jsonRpcResult(
          array(
            type({
              slot: dist_number(),
              numTransactions: dist_number(),
              numSlots: dist_number(),
              samplePeriodSecs: dist_number(),
            })
          )
        ),
        GetFeeCalculatorRpcResult = jsonRpcResultAndContext(
          nullable(
            type({
              feeCalculator: type({ lamportsPerSignature: dist_number() }),
            })
          )
        ),
        RequestAirdropRpcResult = jsonRpcResult(string()),
        SendTransactionRpcResult = jsonRpcResult(string());
      GetLeaderScheduleResult = type({
        err: TransactionErrorResult,
        logs: array(string()),
        signature: string(),
      });
      const LogsNotificationResult = type({
          result: notificationResultAndContext(GetLeaderScheduleResult),
          subscription: dist_number(),
        }),
        COMMON_HTTP_HEADERS = { "solana-client": "js/0.0.0-development" };
      class Connection {
        constructor(endpoint, _commitmentOrConfig) {
          (this._commitment = void 0),
            (this._confirmTransactionInitialTimeout = void 0),
            (this._rpcEndpoint = void 0),
            (this._rpcWsEndpoint = void 0),
            (this._rpcClient = void 0),
            (this._rpcRequest = void 0),
            (this._rpcBatchRequest = void 0),
            (this._rpcWebSocket = void 0),
            (this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketHeartbeat = null),
            (this._rpcWebSocketIdleTimeout = null),
            (this._rpcWebSocketGeneration = 0),
            (this._disableBlockhashCaching = !1),
            (this._pollingBlockhash = !1),
            (this._blockhashInfo = {
              latestBlockhash: null,
              lastFetch: 0,
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            (this._nextClientSubscriptionId = 0),
            (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
            (this._subscriptionHashByClientSubscriptionId = {}),
            (this._subscriptionStateChangeCallbacksByHash = {}),
            (this._subscriptionCallbacksByServerSubscriptionId = {}),
            (this._subscriptionsByHash = {}),
            (this._subscriptionsAutoDisposedByRpc = new Set()),
            (this.getBlockHeight = (() => {
              const requestPromises = {};
              return async (commitmentOrConfig) => {
                var { commitment: commitmentOrConfig, config } =
                  extractCommitmentFromConfig(commitmentOrConfig);
                const args = this._buildArgs(
                    [],
                    commitmentOrConfig,
                    void 0,
                    config
                  ),
                  requestHash = fastStableStringify$1(args);
                return (
                  (requestPromises[requestHash] =
                    requestPromises[requestHash] ??
                    (async () => {
                      try {
                        var res = create(
                          await this._rpcRequest("getBlockHeight", args),
                          jsonRpcResult(dist_number())
                        );
                        if ("error" in res)
                          throw new SolanaJSONRPCError(
                            res.error,
                            "failed to get block height information"
                          );
                        return res.result;
                      } finally {
                        delete requestPromises[requestHash];
                      }
                    })()),
                  requestPromises[requestHash]
                );
              };
            })());
          let wsEndpoint,
            httpHeaders,
            fetch,
            fetchMiddleware,
            disableRetryOnRateLimit,
            httpAgent;
          _commitmentOrConfig && "string" == typeof _commitmentOrConfig
            ? (this._commitment = _commitmentOrConfig)
            : _commitmentOrConfig &&
              ((this._commitment = _commitmentOrConfig.commitment),
              (this._confirmTransactionInitialTimeout =
                _commitmentOrConfig.confirmTransactionInitialTimeout),
              (wsEndpoint = _commitmentOrConfig.wsEndpoint),
              (httpHeaders = _commitmentOrConfig.httpHeaders),
              (fetch = _commitmentOrConfig.fetch),
              (fetchMiddleware = _commitmentOrConfig.fetchMiddleware),
              (disableRetryOnRateLimit =
                _commitmentOrConfig.disableRetryOnRateLimit),
              (httpAgent = _commitmentOrConfig.httpAgent)),
            (this._rpcEndpoint = (function assertEndpointUrl(putativeUrl) {
              if (!1 === /^https?:/.test(putativeUrl))
                throw new TypeError(
                  "Endpoint URL must start with `http:` or `https:`."
                );
              return putativeUrl;
            })(endpoint)),
            (this._rpcWsEndpoint =
              wsEndpoint ||
              (function makeWebsocketUrl(endpoint) {
                if (null == (matches = endpoint.match(URL_RE)))
                  throw TypeError(
                    `Failed to validate endpoint URL \`${endpoint}\``
                  );
                var [, matches, portWithColon, rest] = matches,
                  endpoint = endpoint.startsWith("https:") ? "wss:" : "ws:",
                  portWithColon =
                    null == portWithColon
                      ? null
                      : parseInt(portWithColon.slice(1), 10);
                return (
                  endpoint +
                  "//" +
                  matches +
                  (null == portWithColon ? "" : ":" + (portWithColon + 1)) +
                  rest
                );
              })(endpoint)),
            (this._rpcClient = (function createRpcClient(
              url,
              httpHeaders,
              customFetch,
              fetchMiddleware,
              disableRetryOnRateLimit,
              httpAgent
            ) {
              const fetch = customFetch || fetchImpl;
              null != httpAgent &&
                console.warn(
                  "You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."
                );
              let fetchWithMiddleware;
              return (
                fetchMiddleware &&
                  (fetchWithMiddleware = async (info, init) => {
                    var modifiedFetchArgs = await new Promise(
                      (resolve, reject) => {
                        try {
                          fetchMiddleware(
                            info,
                            init,
                            (modifiedInfo, modifiedInit) =>
                              resolve([modifiedInfo, modifiedInit])
                          );
                        } catch (error) {
                          reject(error);
                        }
                      }
                    );
                    return fetch(...modifiedFetchArgs);
                  }),
                new (browser_default())(async (request, callback) => {
                  var options = {
                    method: "POST",
                    body: request,
                    agent: void 0,
                    headers: Object.assign(
                      { "Content-Type": "application/json" },
                      httpHeaders || {},
                      COMMON_HTTP_HEADERS
                    ),
                  };
                  try {
                    let too_many_requests_retries = 5,
                      res,
                      waitTime = 500;
                    for (
                      ;
                      429 ===
                        (res = fetchWithMiddleware
                          ? await fetchWithMiddleware(url, options)
                          : await fetch(url, options)).status &&
                      !0 !== disableRetryOnRateLimit &&
                      0 !== --too_many_requests_retries;

                    )
                      console.error(
                        `Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`
                      ),
                        await sleep(waitTime),
                        (waitTime *= 2);
                    var text = await res.text();
                    res.ok
                      ? callback(null, text)
                      : callback(
                          new Error(`${res.status} ${res.statusText}: ` + text)
                        );
                  } catch (err) {
                    err instanceof Error && callback(err);
                  }
                }, {})
              );
            })(
              endpoint,
              httpHeaders,
              fetch,
              fetchMiddleware,
              disableRetryOnRateLimit,
              httpAgent
            )),
            (this._rpcRequest = (function createRpcRequest(client) {
              return (method, args) =>
                new Promise((resolve, reject) => {
                  client.request(method, args, (err, response) => {
                    err ? reject(err) : resolve(response);
                  });
                });
            })(this._rpcClient)),
            (this._rpcBatchRequest = (function createRpcBatchRequest(client) {
              return (requests) =>
                new Promise((resolve, reject) => {
                  0 === requests.length && resolve([]);
                  var batch = requests.map((params) =>
                    client.request(params.methodName, params.args)
                  );
                  client.request(batch, (err, response) => {
                    err ? reject(err) : resolve(response);
                  });
                });
            })(this._rpcClient)),
            (this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
              autoconnect: !1,
              max_reconnects: 1 / 0,
            })),
            this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
            this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
            this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
            this._rpcWebSocket.on(
              "accountNotification",
              this._wsOnAccountNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "programNotification",
              this._wsOnProgramAccountNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "slotNotification",
              this._wsOnSlotNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "slotsUpdatesNotification",
              this._wsOnSlotUpdatesNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "signatureNotification",
              this._wsOnSignatureNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "rootNotification",
              this._wsOnRootNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "logsNotification",
              this._wsOnLogsNotification.bind(this)
            );
        }
        get commitment() {
          return this._commitment;
        }
        get rpcEndpoint() {
          return this._rpcEndpoint;
        }
        async getBalanceAndContext(publicKey, commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [publicKey.toBase58()],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getBalance", commitmentOrConfig),
              jsonRpcResultAndContext(dist_number())
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get balance for " + publicKey.toBase58()
            );
          return config.result;
        }
        async getBalance(publicKey, commitmentOrConfig) {
          return this.getBalanceAndContext(publicKey, commitmentOrConfig)
            .then((x) => x.value)
            .catch((e) => {
              throw new Error(
                "failed to get balance of account " +
                  publicKey.toBase58() +
                  ": " +
                  e
              );
            });
        }
        async getBlockTime(slot) {
          var res = create(
            await this._rpcRequest("getBlockTime", [slot]),
            jsonRpcResult(nullable(dist_number()))
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get block time for slot " + slot
            );
          return res.result;
        }
        async getMinimumLedgerSlot() {
          var res = create(
            await this._rpcRequest("minimumLedgerSlot", []),
            jsonRpcResult(dist_number())
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get minimum ledger slot"
            );
          return res.result;
        }
        async getFirstAvailableBlock() {
          var res = create(
            await this._rpcRequest("getFirstAvailableBlock", []),
            SlotRpcResult
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get first available block"
            );
          return res.result;
        }
        async getSupply(config) {
          let configArg = {};
          configArg =
            "string" == typeof config
              ? { commitment: config }
              : config
              ? {
                  ...config,
                  commitment: (config && config.commitment) || this.commitment,
                }
              : { commitment: this.commitment };
          config = create(
            await this._rpcRequest("getSupply", [configArg]),
            GetSupplyRpcResult
          );
          if ("error" in config)
            throw new SolanaJSONRPCError(config.error, "failed to get supply");
          return config.result;
        }
        async getTokenSupply(tokenMintAddress, commitment) {
          (tokenMintAddress = this._buildArgs(
            [tokenMintAddress.toBase58()],
            commitment
          )),
            (commitment = create(
              await this._rpcRequest("getTokenSupply", tokenMintAddress),
              jsonRpcResultAndContext(TokenAmountResult)
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get token supply"
            );
          return commitment.result;
        }
        async getTokenAccountBalance(tokenAddress, commitment) {
          (tokenAddress = this._buildArgs(
            [tokenAddress.toBase58()],
            commitment
          )),
            (commitment = create(
              await this._rpcRequest("getTokenAccountBalance", tokenAddress),
              jsonRpcResultAndContext(TokenAmountResult)
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get token account balance"
            );
          return commitment.result;
        }
        async getTokenAccountsByOwner(
          ownerAddress,
          filter,
          commitmentOrConfig
        ) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            _args = [ownerAddress.toBase58()],
            filter =
              ("mint" in filter
                ? _args.push({ mint: filter.mint.toBase58() })
                : _args.push({ programId: filter.programId.toBase58() }),
              this._buildArgs(_args, commitmentOrConfig, "base64", config)),
            _args = create(
              await this._rpcRequest("getTokenAccountsByOwner", filter),
              GetTokenAccountsByOwner
            );
          if ("error" in _args)
            throw new SolanaJSONRPCError(
              _args.error,
              "failed to get token accounts owned by account " +
                ownerAddress.toBase58()
            );
          return _args.result;
        }
        async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
          var _args = [ownerAddress.toBase58()],
            filter =
              ("mint" in filter
                ? _args.push({ mint: filter.mint.toBase58() })
                : _args.push({ programId: filter.programId.toBase58() }),
              this._buildArgs(_args, commitment, "jsonParsed")),
            _args = create(
              await this._rpcRequest("getTokenAccountsByOwner", filter),
              GetParsedTokenAccountsByOwner
            );
          if ("error" in _args)
            throw new SolanaJSONRPCError(
              _args.error,
              "failed to get token accounts owned by account " +
                ownerAddress.toBase58()
            );
          return _args.result;
        }
        async getLargestAccounts(config) {
          (config = {
            ...config,
            commitment: (config && config.commitment) || this.commitment,
          }),
            (config = create(
              await this._rpcRequest(
                "getLargestAccounts",
                config.filter || config.commitment ? [config] : []
              ),
              GetLargestAccountsRpcResult
            ));
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get largest accounts"
            );
          return config.result;
        }
        async getTokenLargestAccounts(mintAddress, commitment) {
          (mintAddress = this._buildArgs([mintAddress.toBase58()], commitment)),
            (commitment = create(
              await this._rpcRequest("getTokenLargestAccounts", mintAddress),
              GetTokenLargestAccountsResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get token largest accounts"
            );
          return commitment.result;
        }
        async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [publicKey.toBase58()],
              commitmentOrConfig,
              "base64",
              config
            ),
            config = create(
              await this._rpcRequest("getAccountInfo", commitmentOrConfig),
              jsonRpcResultAndContext(nullable(AccountInfoResult))
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get info about account " + publicKey.toBase58()
            );
          return config.result;
        }
        async getParsedAccountInfo(publicKey, commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [publicKey.toBase58()],
              commitmentOrConfig,
              "jsonParsed",
              config
            ),
            config = create(
              await this._rpcRequest("getAccountInfo", commitmentOrConfig),
              jsonRpcResultAndContext(nullable(ParsedAccountInfoResult))
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get info about account " + publicKey.toBase58()
            );
          return config.result;
        }
        async getAccountInfo(publicKey, commitmentOrConfig) {
          try {
            return (
              await this.getAccountInfoAndContext(publicKey, commitmentOrConfig)
            ).value;
          } catch (e) {
            throw new Error(
              "failed to get info about account " +
                publicKey.toBase58() +
                ": " +
                e
            );
          }
        }
        async getMultipleParsedAccounts(publicKeys, rawConfig) {
          var { commitment: rawConfig, config } =
              extractCommitmentFromConfig(rawConfig),
            publicKeys = publicKeys.map((key) => key.toBase58()),
            rawConfig = this._buildArgs(
              [publicKeys],
              rawConfig,
              "jsonParsed",
              config
            ),
            config = create(
              await this._rpcRequest("getMultipleAccounts", rawConfig),
              jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult)))
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get info for accounts " + publicKeys
            );
          return config.result;
        }
        async getMultipleAccountsInfoAndContext(
          publicKeys,
          commitmentOrConfig
        ) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            publicKeys = publicKeys.map((key) => key.toBase58()),
            commitmentOrConfig = this._buildArgs(
              [publicKeys],
              commitmentOrConfig,
              "base64",
              config
            ),
            config = create(
              await this._rpcRequest("getMultipleAccounts", commitmentOrConfig),
              jsonRpcResultAndContext(array(nullable(AccountInfoResult)))
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get info for accounts " + publicKeys
            );
          return config.result;
        }
        async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
          return (
            await this.getMultipleAccountsInfoAndContext(
              publicKeys,
              commitmentOrConfig
            )
          ).value;
        }
        async getStakeActivation(publicKey, commitmentOrConfig, epoch) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [publicKey.toBase58()],
              commitmentOrConfig,
              void 0,
              { ...config, epoch: null != epoch ? epoch : config?.epoch }
            ),
            epoch = create(
              await this._rpcRequest("getStakeActivation", commitmentOrConfig),
              jsonRpcResult(StakeActivationResult)
            );
          if ("error" in epoch)
            throw new SolanaJSONRPCError(
              epoch.error,
              "failed to get Stake Activation " + publicKey.toBase58()
            );
          return epoch.result;
        }
        async getProgramAccounts(programId, configOrCommitment) {
          var { commitment: configOrCommitment, config } =
            extractCommitmentFromConfig(configOrCommitment);
          const { encoding, ...configWithoutEncoding } = config || {};
          (config = this._buildArgs(
            [programId.toBase58()],
            configOrCommitment,
            encoding || "base64",
            configWithoutEncoding
          )),
            (configOrCommitment = await this._rpcRequest(
              "getProgramAccounts",
              config
            )),
            (config = array(KeyedAccountInfoResult)),
            (configOrCommitment =
              !0 === configWithoutEncoding.withContext
                ? create(configOrCommitment, jsonRpcResultAndContext(config))
                : create(configOrCommitment, jsonRpcResult(config)));
          if ("error" in configOrCommitment)
            throw new SolanaJSONRPCError(
              configOrCommitment.error,
              "failed to get accounts owned by program " + programId.toBase58()
            );
          return configOrCommitment.result;
        }
        async getParsedProgramAccounts(programId, configOrCommitment) {
          var { commitment: configOrCommitment, config } =
              extractCommitmentFromConfig(configOrCommitment),
            configOrCommitment = this._buildArgs(
              [programId.toBase58()],
              configOrCommitment,
              "jsonParsed",
              config
            ),
            config = create(
              await this._rpcRequest("getProgramAccounts", configOrCommitment),
              jsonRpcResult(array(KeyedParsedAccountInfoResult))
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get accounts owned by program " + programId.toBase58()
            );
          return config.result;
        }
        async confirmTransaction(strategy, commitment) {
          let rawSignature;
          if ("string" == typeof strategy) rawSignature = strategy;
          else {
            var config = strategy;
            if (config.abortSignal?.aborted)
              return Promise.reject(config.abortSignal.reason);
            rawSignature = config.signature;
          }
          let decodedSignature;
          try {
            decodedSignature = bs58_default().decode(rawSignature);
          } catch (err) {
            throw new Error(
              "signature must be base58 encoded: " + rawSignature
            );
          }
          return (
            index_browser_esm_assert(
              64 === decodedSignature.length,
              "signature has invalid length"
            ),
            "string" == typeof strategy
              ? this.confirmTransactionUsingLegacyTimeoutStrategy({
                  commitment: commitment || this.commitment,
                  signature: rawSignature,
                })
              : "lastValidBlockHeight" in strategy
              ? this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                  commitment: commitment || this.commitment,
                  strategy: strategy,
                })
              : this.confirmTransactionUsingDurableNonceStrategy({
                  commitment: commitment || this.commitment,
                  strategy: strategy,
                })
          );
        }
        getCancellationPromise(signal) {
          return new Promise((_, reject) => {
            null != signal &&
              (signal.aborted
                ? reject(signal.reason)
                : signal.addEventListener("abort", () => {
                    reject(signal.reason);
                  }));
          });
        }
        getTransactionConfirmationPromise({ commitment, signature }) {
          let signatureSubscriptionId,
            disposeSignatureSubscriptionStateChangeObserver,
            done = !1;
          return {
            abortConfirmation: () => {
              disposeSignatureSubscriptionStateChangeObserver &&
                (disposeSignatureSubscriptionStateChangeObserver(),
                (disposeSignatureSubscriptionStateChangeObserver = void 0)),
                null != signatureSubscriptionId &&
                  (this.removeSignatureListener(signatureSubscriptionId),
                  (signatureSubscriptionId = void 0));
            },
            confirmationPromise: new Promise((resolve, reject) => {
              try {
                signatureSubscriptionId = this.onSignature(
                  signature,
                  (result, context) => {
                    signatureSubscriptionId = void 0;
                    context = { context: context, value: result };
                    resolve({
                      __type: TransactionStatus.PROCESSED,
                      response: context,
                    });
                  },
                  commitment
                );
                const subscriptionSetupPromise = new Promise(
                  (resolveSubscriptionSetup) => {
                    null == signatureSubscriptionId
                      ? resolveSubscriptionSetup()
                      : (disposeSignatureSubscriptionStateChangeObserver =
                          this._onSubscriptionStateChange(
                            signatureSubscriptionId,
                            (nextState) => {
                              "subscribed" === nextState &&
                                resolveSubscriptionSetup();
                            }
                          ));
                  }
                );
                (async () => {
                  if ((await subscriptionSetupPromise, !done)) {
                    var response = await this.getSignatureStatus(signature);
                    if (!done && null != response) {
                      var { context: response, value } = response;
                      if (null != value)
                        if (value?.err) reject(value.err);
                        else {
                          switch (commitment) {
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                              if ("processed" === value.confirmationStatus)
                                return;
                              break;
                            case "finalized":
                            case "max":
                            case "root":
                              if (
                                "processed" === value.confirmationStatus ||
                                "confirmed" === value.confirmationStatus
                              )
                                return;
                          }
                          (done = !0),
                            resolve({
                              __type: TransactionStatus.PROCESSED,
                              response: { context: response, value: value },
                            });
                        }
                    }
                  }
                })();
              } catch (err) {
                reject(err);
              }
            }),
          };
        }
        async confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment,
          strategy: { abortSignal, lastValidBlockHeight, signature },
        }) {
          let done = !1;
          var expiryPromise = new Promise((resolve) => {
              const checkBlockHeight = async () => {
                try {
                  return await this.getBlockHeight(commitment);
                } catch (_e) {
                  return -1;
                }
              };
              (async () => {
                let currentBlockHeight = await checkBlockHeight();
                if (!done) {
                  for (; currentBlockHeight <= lastValidBlockHeight; ) {
                    if ((await sleep(1e3), done)) return;
                    if (((currentBlockHeight = await checkBlockHeight()), done))
                      return;
                  }
                  resolve({ __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED });
                }
              })();
            }),
            { abortConfirmation, confirmationPromise } =
              this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature,
              }),
            abortSignal = this.getCancellationPromise(abortSignal);
          let result;
          try {
            var outcome = await Promise.race([
              abortSignal,
              confirmationPromise,
              expiryPromise,
            ]);
            if (outcome.__type !== TransactionStatus.PROCESSED)
              throw new TransactionExpiredBlockheightExceededError(signature);
            result = outcome.response;
          } finally {
            (done = !0), abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingDurableNonceStrategy({
          commitment,
          strategy: {
            abortSignal,
            minContextSlot,
            nonceAccountPubkey,
            nonceValue,
            signature,
          },
        }) {
          let done = !1;
          var expiryPromise = new Promise((resolve) => {
              let currentNonceValue = nonceValue,
                lastCheckedSlot = null;
              const getCurrentNonceValue = async () => {
                try {
                  var { context, value: nonceAccount } =
                    await this.getNonceAndContext(nonceAccountPubkey, {
                      commitment: commitment,
                      minContextSlot: minContextSlot,
                    });
                  return (lastCheckedSlot = context.slot), nonceAccount?.nonce;
                } catch (e) {
                  return currentNonceValue;
                }
              };
              (async () => {
                if (((currentNonceValue = await getCurrentNonceValue()), !done))
                  for (;;) {
                    if (nonceValue !== currentNonceValue)
                      return !resolve({
                        __type: TransactionStatus.NONCE_INVALID,
                        slotInWhichNonceDidAdvance: lastCheckedSlot,
                      });
                    if ((await sleep(2e3), done)) return;
                    if (
                      ((currentNonceValue = await getCurrentNonceValue()), done)
                    )
                      return;
                  }
              })();
            }),
            { abortConfirmation, confirmationPromise } =
              this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature,
              }),
            abortSignal = this.getCancellationPromise(abortSignal);
          let result;
          try {
            var outcome = await Promise.race([
              abortSignal,
              confirmationPromise,
              expiryPromise,
            ]);
            if (outcome.__type === TransactionStatus.PROCESSED)
              result = outcome.response;
            else {
              let signatureStatus;
              for (;;) {
                var status = await this.getSignatureStatus(signature);
                if (null == status) break;
                if (
                  !(
                    status.context.slot <
                    (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)
                  )
                ) {
                  signatureStatus = status;
                  break;
                }
                await sleep(400);
              }
              if (!signatureStatus?.value)
                throw new TransactionExpiredNonceInvalidError(signature);
              var commitmentForStatus = commitment || "finalized",
                confirmationStatus =
                  signatureStatus.value["confirmationStatus"];
              switch (commitmentForStatus) {
                case "processed":
                case "recent":
                  if (
                    "processed" !== confirmationStatus &&
                    "confirmed" !== confirmationStatus &&
                    "finalized" !== confirmationStatus
                  )
                    throw new TransactionExpiredNonceInvalidError(signature);
                  break;
                case "confirmed":
                case "single":
                case "singleGossip":
                  if (
                    "confirmed" !== confirmationStatus &&
                    "finalized" !== confirmationStatus
                  )
                    throw new TransactionExpiredNonceInvalidError(signature);
                  break;
                case "finalized":
                case "max":
                case "root":
                  if ("finalized" !== confirmationStatus)
                    throw new TransactionExpiredNonceInvalidError(signature);
              }
              result = {
                context: signatureStatus.context,
                value: { err: signatureStatus.value.err },
              };
            }
          } finally {
            (done = !0), abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingLegacyTimeoutStrategy({
          commitment,
          signature,
        }) {
          let timeoutId;
          var expiryPromise = new Promise((resolve) => {
              let timeoutMs = this._confirmTransactionInitialTimeout || 6e4;
              switch (commitment) {
                case "processed":
                case "recent":
                case "single":
                case "confirmed":
                case "singleGossip":
                  timeoutMs = this._confirmTransactionInitialTimeout || 3e4;
              }
              timeoutId = setTimeout(
                () =>
                  resolve({
                    __type: TransactionStatus.TIMED_OUT,
                    timeoutMs: timeoutMs,
                  }),
                timeoutMs
              );
            }),
            { abortConfirmation, confirmationPromise } =
              this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature,
              });
          let result;
          try {
            var outcome = await Promise.race([
              confirmationPromise,
              expiryPromise,
            ]);
            if (outcome.__type !== TransactionStatus.PROCESSED)
              throw new TransactionExpiredTimeoutError(
                signature,
                outcome.timeoutMs / 1e3
              );
            result = outcome.response;
          } finally {
            clearTimeout(timeoutId), abortConfirmation();
          }
          return result;
        }
        async getClusterNodes() {
          var res = create(
            await this._rpcRequest("getClusterNodes", []),
            jsonRpcResult(array(ContactInfoResult))
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get cluster nodes"
            );
          return res.result;
        }
        async getVoteAccounts(commitment) {
          (commitment = this._buildArgs([], commitment)),
            (commitment = create(
              await this._rpcRequest("getVoteAccounts", commitment),
              GetVoteAccounts
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get vote accounts"
            );
          return commitment.result;
        }
        async getSlot(commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getSlot", commitmentOrConfig),
              jsonRpcResult(dist_number())
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(config.error, "failed to get slot");
          return config.result;
        }
        async getSlotLeader(commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getSlotLeader", commitmentOrConfig),
              jsonRpcResult(string())
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get slot leader"
            );
          return config.result;
        }
        async getSlotLeaders(startSlot, limit) {
          startSlot = create(
            await this._rpcRequest("getSlotLeaders", [startSlot, limit]),
            jsonRpcResult(array(PublicKeyFromString))
          );
          if ("error" in startSlot)
            throw new SolanaJSONRPCError(
              startSlot.error,
              "failed to get slot leaders"
            );
          return startSlot.result;
        }
        async getSignatureStatus(signature, config) {
          var { context: signature, value: config } =
              await this.getSignatureStatuses([signature], config),
            config = (index_browser_esm_assert(1 === config.length), config[0]);
          return { context: signature, value: config };
        }
        async getSignatureStatuses(signatures, config) {
          (signatures = [signatures]),
            config && signatures.push(config),
            (config = await this._rpcRequest(
              "getSignatureStatuses",
              signatures
            )),
            (signatures = create(config, GetSignatureStatusesRpcResult));
          if ("error" in signatures)
            throw new SolanaJSONRPCError(
              signatures.error,
              "failed to get signature status"
            );
          return signatures.result;
        }
        async getTransactionCount(commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getTransactionCount", commitmentOrConfig),
              jsonRpcResult(dist_number())
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get transaction count"
            );
          return config.result;
        }
        async getTotalSupply(commitment) {
          return (
            await this.getSupply({
              commitment: commitment,
              excludeNonCirculatingAccountsList: !0,
            })
          ).value.total;
        }
        async getInflationGovernor(commitment) {
          (commitment = this._buildArgs([], commitment)),
            (commitment = create(
              await this._rpcRequest("getInflationGovernor", commitment),
              GetInflationGovernorRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get inflation"
            );
          return commitment.result;
        }
        async getInflationReward(addresses, epoch, commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            addresses = this._buildArgs(
              [addresses.map((pubkey) => pubkey.toBase58())],
              commitmentOrConfig,
              void 0,
              { ...config, epoch: null != epoch ? epoch : config?.epoch }
            ),
            commitmentOrConfig = create(
              await this._rpcRequest("getInflationReward", addresses),
              GetInflationRewardResult
            );
          if ("error" in commitmentOrConfig)
            throw new SolanaJSONRPCError(
              commitmentOrConfig.error,
              "failed to get inflation reward"
            );
          return commitmentOrConfig.result;
        }
        async getInflationRate() {
          var res = create(
            await this._rpcRequest("getInflationRate", []),
            GetInflationRateRpcResult
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get inflation rate"
            );
          return res.result;
        }
        async getEpochInfo(commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getEpochInfo", commitmentOrConfig),
              GetEpochInfoRpcResult
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get epoch info"
            );
          return config.result;
        }
        async getEpochSchedule() {
          var res = create(
            await this._rpcRequest("getEpochSchedule", []),
            GetEpochScheduleRpcResult
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get epoch schedule"
            );
          res = res.result;
          return new EpochSchedule(
            res.slotsPerEpoch,
            res.leaderScheduleSlotOffset,
            res.warmup,
            res.firstNormalEpoch,
            res.firstNormalSlot
          );
        }
        async getLeaderSchedule() {
          var res = create(
            await this._rpcRequest("getLeaderSchedule", []),
            GetLeaderScheduleRpcResult
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get leader schedule"
            );
          return res.result;
        }
        async getMinimumBalanceForRentExemption(dataLength, commitment) {
          (dataLength = this._buildArgs([dataLength], commitment)),
            (commitment = create(
              await this._rpcRequest(
                "getMinimumBalanceForRentExemption",
                dataLength
              ),
              GetMinimumBalanceForRentExemptionRpcResult
            ));
          return "error" in commitment
            ? (console.warn(
                "Unable to fetch minimum balance for rent exemption"
              ),
              0)
            : commitment.result;
        }
        async getRecentBlockhashAndContext(commitment) {
          (commitment = this._buildArgs([], commitment)),
            (commitment = create(
              await this._rpcRequest("getRecentBlockhash", commitment),
              GetRecentBlockhashAndContextRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get recent blockhash"
            );
          return commitment.result;
        }
        async getRecentPerformanceSamples(limit) {
          limit = create(
            await this._rpcRequest(
              "getRecentPerformanceSamples",
              limit ? [limit] : []
            ),
            GetRecentPerformanceSamplesRpcResult
          );
          if ("error" in limit)
            throw new SolanaJSONRPCError(
              limit.error,
              "failed to get recent performance samples"
            );
          return limit.result;
        }
        async getFeeCalculatorForBlockhash(blockhash, commitment) {
          (blockhash = this._buildArgs([blockhash], commitment)),
            (commitment = create(
              await this._rpcRequest("getFeeCalculatorForBlockhash", blockhash),
              GetFeeCalculatorRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get fee calculator"
            );
          var { context: blockhash, value: commitment } = commitment.result;
          return {
            context: blockhash,
            value: null !== commitment ? commitment.feeCalculator : null,
          };
        }
        async getFeeForMessage(message, commitment) {
          (message = toBuffer(message.serialize()).toString("base64")),
            (message = this._buildArgs([message], commitment)),
            (commitment = create(
              await this._rpcRequest("getFeeForMessage", message),
              jsonRpcResultAndContext(nullable(dist_number()))
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get fee for message"
            );
          if (null === commitment.result) throw new Error("invalid blockhash");
          return commitment.result;
        }
        async getRecentPrioritizationFees(config) {
          (config = config?.lockedWritableAccounts?.map((key) =>
            key.toBase58()
          )),
            (config = config?.length ? [config] : []),
            (config = create(
              await this._rpcRequest("getRecentPrioritizationFees", config),
              GetRecentPrioritizationFeesRpcResult
            ));
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get recent prioritization fees"
            );
          return config.result;
        }
        async getRecentBlockhash(commitment) {
          try {
            return (await this.getRecentBlockhashAndContext(commitment)).value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        async getLatestBlockhash(commitmentOrConfig) {
          try {
            return (await this.getLatestBlockhashAndContext(commitmentOrConfig))
              .value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        async getLatestBlockhashAndContext(commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            commitmentOrConfig = this._buildArgs(
              [],
              commitmentOrConfig,
              void 0,
              config
            ),
            config = create(
              await this._rpcRequest("getLatestBlockhash", commitmentOrConfig),
              GetLatestBlockhashRpcResult
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to get latest blockhash"
            );
          return config.result;
        }
        async isBlockhashValid(blockhash, rawConfig) {
          var { commitment: rawConfig, config } =
              extractCommitmentFromConfig(rawConfig),
            rawConfig = this._buildArgs([blockhash], rawConfig, void 0, config),
            config = create(
              await this._rpcRequest("isBlockhashValid", rawConfig),
              IsBlockhashValidRpcResult
            );
          if ("error" in config)
            throw new SolanaJSONRPCError(
              config.error,
              "failed to determine if the blockhash `" + blockhash + "`is valid"
            );
          return config.result;
        }
        async getVersion() {
          var res = create(
            await this._rpcRequest("getVersion", []),
            jsonRpcResult(VersionResult)
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(res.error, "failed to get version");
          return res.result;
        }
        async getGenesisHash() {
          var res = create(
            await this._rpcRequest("getGenesisHash", []),
            jsonRpcResult(string())
          );
          if ("error" in res)
            throw new SolanaJSONRPCError(
              res.error,
              "failed to get genesis hash"
            );
          return res.result;
        }
        async getBlock(slot, rawConfig) {
          var { commitment: rawConfig, config } =
              extractCommitmentFromConfig(rawConfig),
            slot = this._buildArgsAtLeastConfirmed(
              [slot],
              rawConfig,
              void 0,
              config
            ),
            unsafeRes = await this._rpcRequest("getBlock", slot);
          try {
            switch (config?.transactionDetails) {
              case "accounts":
                var res = create(unsafeRes, GetAccountsModeBlockRpcResult);
                if ("error" in res) throw res.error;
                return res.result;
              case "none": {
                const res = create(unsafeRes, GetNoneModeBlockRpcResult);
                if ("error" in res) throw res.error;
                return res.result;
              }
              default: {
                const res = create(unsafeRes, GetBlockRpcResult);
                if ("error" in res) throw res.error;
                var result = res["result"];
                return result
                  ? {
                      ...result,
                      transactions: result.transactions.map(
                        ({ transaction, meta, version }) => ({
                          meta: meta,
                          transaction: {
                            ...transaction,
                            message: versionedMessageFromResponse(
                              version,
                              transaction.message
                            ),
                          },
                          version: version,
                        })
                      ),
                    }
                  : null;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get confirmed block");
          }
        }
        async getParsedBlock(slot, rawConfig) {
          var { commitment: rawConfig, config } =
              extractCommitmentFromConfig(rawConfig),
            slot = this._buildArgsAtLeastConfirmed(
              [slot],
              rawConfig,
              "jsonParsed",
              config
            ),
            unsafeRes = await this._rpcRequest("getBlock", slot);
          try {
            switch (config?.transactionDetails) {
              case "accounts":
                var res = create(
                  unsafeRes,
                  GetParsedAccountsModeBlockRpcResult
                );
                if ("error" in res) throw res.error;
                return res.result;
              case "none": {
                const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
                if ("error" in res) throw res.error;
                return res.result;
              }
              default: {
                const res = create(unsafeRes, GetParsedBlockRpcResult);
                if ("error" in res) throw res.error;
                return res.result;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get block");
          }
        }
        async getBlockProduction(configOrCommitment) {
          let extra, commitment;
          if ("string" == typeof configOrCommitment)
            commitment = configOrCommitment;
          else if (configOrCommitment) {
            const { commitment: c, ...rest } = configOrCommitment;
            (commitment = c), (extra = rest);
          }
          (configOrCommitment = this._buildArgs(
            [],
            commitment,
            "base64",
            extra
          )),
            (configOrCommitment = create(
              await this._rpcRequest("getBlockProduction", configOrCommitment),
              BlockProductionResponseStruct
            ));
          if ("error" in configOrCommitment)
            throw new SolanaJSONRPCError(
              configOrCommitment.error,
              "failed to get block production information"
            );
          return configOrCommitment.result;
        }
        async getTransaction(signature, rawConfig) {
          var { commitment: rawConfig, config } =
              extractCommitmentFromConfig(rawConfig),
            signature = this._buildArgsAtLeastConfirmed(
              [signature],
              rawConfig,
              void 0,
              config
            ),
            rawConfig = create(
              await this._rpcRequest("getTransaction", signature),
              GetTransactionRpcResult
            );
          if ("error" in rawConfig)
            throw new SolanaJSONRPCError(
              rawConfig.error,
              "failed to get transaction"
            );
          config = rawConfig.result;
          return (
            config && {
              ...config,
              transaction: {
                ...config.transaction,
                message: versionedMessageFromResponse(
                  config.version,
                  config.transaction.message
                ),
              },
            }
          );
        }
        async getParsedTransaction(signature, commitmentOrConfig) {
          var { commitment: commitmentOrConfig, config } =
              extractCommitmentFromConfig(commitmentOrConfig),
            signature = this._buildArgsAtLeastConfirmed(
              [signature],
              commitmentOrConfig,
              "jsonParsed",
              config
            ),
            commitmentOrConfig = create(
              await this._rpcRequest("getTransaction", signature),
              GetParsedTransactionRpcResult
            );
          if ("error" in commitmentOrConfig)
            throw new SolanaJSONRPCError(
              commitmentOrConfig.error,
              "failed to get transaction"
            );
          return commitmentOrConfig.result;
        }
        async getParsedTransactions(signatures, commitmentOrConfig) {
          const { commitment, config } =
            extractCommitmentFromConfig(commitmentOrConfig);
          commitmentOrConfig = signatures.map((signature) => {
            return {
              methodName: "getTransaction",
              args: this._buildArgsAtLeastConfirmed(
                [signature],
                commitment,
                "jsonParsed",
                config
              ),
            };
          });
          return (await this._rpcBatchRequest(commitmentOrConfig)).map(
            (unsafeRes) => {
              unsafeRes = create(unsafeRes, GetParsedTransactionRpcResult);
              if ("error" in unsafeRes)
                throw new SolanaJSONRPCError(
                  unsafeRes.error,
                  "failed to get transactions"
                );
              return unsafeRes.result;
            }
          );
        }
        async getTransactions(signatures, commitmentOrConfig) {
          const { commitment, config } =
            extractCommitmentFromConfig(commitmentOrConfig);
          commitmentOrConfig = signatures.map((signature) => {
            return {
              methodName: "getTransaction",
              args: this._buildArgsAtLeastConfirmed(
                [signature],
                commitment,
                void 0,
                config
              ),
            };
          });
          return (await this._rpcBatchRequest(commitmentOrConfig)).map(
            (unsafeRes) => {
              unsafeRes = create(unsafeRes, GetTransactionRpcResult);
              if ("error" in unsafeRes)
                throw new SolanaJSONRPCError(
                  unsafeRes.error,
                  "failed to get transactions"
                );
              unsafeRes = unsafeRes.result;
              return (
                unsafeRes && {
                  ...unsafeRes,
                  transaction: {
                    ...unsafeRes.transaction,
                    message: versionedMessageFromResponse(
                      unsafeRes.version,
                      unsafeRes.transaction.message
                    ),
                  },
                }
              );
            }
          );
        }
        async getConfirmedBlock(slot, commitment) {
          (commitment = this._buildArgsAtLeastConfirmed([slot], commitment)),
            (commitment = create(
              await this._rpcRequest("getConfirmedBlock", commitment),
              GetConfirmedBlockRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get confirmed block"
            );
          var commitment = commitment.result;
          if (commitment)
            return {
              ...(commitment = {
                ...commitment,
                transactions: commitment.transactions.map(
                  ({ transaction, meta }) => {
                    var message = new Message(transaction.message);
                    return {
                      meta: meta,
                      transaction: { ...transaction, message: message },
                    };
                  }
                ),
              }),
              transactions: commitment.transactions.map(
                ({ transaction, meta }) => ({
                  meta: meta,
                  transaction: Transaction.populate(
                    transaction.message,
                    transaction.signatures
                  ),
                })
              ),
            };
          throw new Error("Confirmed block " + slot + " not found");
        }
        async getBlocks(startSlot, endSlot, commitment) {
          (endSlot = this._buildArgsAtLeastConfirmed(
            void 0 !== endSlot ? [startSlot, endSlot] : [startSlot],
            commitment
          )),
            (startSlot = create(
              await this._rpcRequest("getBlocks", endSlot),
              jsonRpcResult(array(dist_number()))
            ));
          if ("error" in startSlot)
            throw new SolanaJSONRPCError(
              startSlot.error,
              "failed to get blocks"
            );
          return startSlot.result;
        }
        async getBlockSignatures(slot, commitment) {
          (commitment = this._buildArgsAtLeastConfirmed(
            [slot],
            commitment,
            void 0,
            { transactionDetails: "signatures", rewards: !1 }
          )),
            (commitment = create(
              await this._rpcRequest("getBlock", commitment),
              GetBlockSignaturesRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get block"
            );
          commitment = commitment.result;
          if (commitment) return commitment;
          throw new Error("Block " + slot + " not found");
        }
        async getConfirmedBlockSignatures(slot, commitment) {
          (commitment = this._buildArgsAtLeastConfirmed(
            [slot],
            commitment,
            void 0,
            { transactionDetails: "signatures", rewards: !1 }
          )),
            (commitment = create(
              await this._rpcRequest("getConfirmedBlock", commitment),
              GetBlockSignaturesRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get confirmed block"
            );
          commitment = commitment.result;
          if (commitment) return commitment;
          throw new Error("Confirmed block " + slot + " not found");
        }
        async getConfirmedTransaction(signature, commitment) {
          (signature = this._buildArgsAtLeastConfirmed(
            [signature],
            commitment
          )),
            (commitment = create(
              await this._rpcRequest("getConfirmedTransaction", signature),
              GetTransactionRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get transaction"
            );
          var signatures,
            signature = commitment.result;
          return (
            signature &&
            ((commitment = new Message(signature.transaction.message)),
            (signatures = signature.transaction.signatures),
            {
              ...signature,
              transaction: Transaction.populate(commitment, signatures),
            })
          );
        }
        async getParsedConfirmedTransaction(signature, commitment) {
          (signature = this._buildArgsAtLeastConfirmed(
            [signature],
            commitment,
            "jsonParsed"
          )),
            (commitment = create(
              await this._rpcRequest("getConfirmedTransaction", signature),
              GetParsedTransactionRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get confirmed transaction"
            );
          return commitment.result;
        }
        async getParsedConfirmedTransactions(signatures, commitment) {
          signatures = signatures.map((signature) => {
            return {
              methodName: "getConfirmedTransaction",
              args: this._buildArgsAtLeastConfirmed(
                [signature],
                commitment,
                "jsonParsed"
              ),
            };
          });
          return (await this._rpcBatchRequest(signatures)).map((unsafeRes) => {
            unsafeRes = create(unsafeRes, GetParsedTransactionRpcResult);
            if ("error" in unsafeRes)
              throw new SolanaJSONRPCError(
                unsafeRes.error,
                "failed to get confirmed transactions"
              );
            return unsafeRes.result;
          });
        }
        async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
          for (
            var options = {},
              firstAvailableBlock = await this.getFirstAvailableBlock();
            !(
              "until" in options ||
              --startSlot <= 0 ||
              startSlot < firstAvailableBlock
            );

          )
            try {
              var block = await this.getConfirmedBlockSignatures(
                startSlot,
                "finalized"
              );
              0 < block.signatures.length &&
                (options.until =
                  block.signatures[block.signatures.length - 1].toString());
            } catch (err) {
              if (!(err instanceof Error && err.message.includes("skipped")))
                throw err;
            }
          for (
            var highestConfirmedRoot = await this.getSlot("finalized");
            !("before" in options || highestConfirmedRoot < ++endSlot);

          )
            try {
              const block = await this.getConfirmedBlockSignatures(endSlot);
              0 < block.signatures.length &&
                (options.before =
                  block.signatures[block.signatures.length - 1].toString());
            } catch (err) {
              if (!(err instanceof Error && err.message.includes("skipped")))
                throw err;
            }
          return (
            await this.getConfirmedSignaturesForAddress2(address, options)
          ).map((info) => info.signature);
        }
        async getConfirmedSignaturesForAddress2(address, options, commitment) {
          (address = this._buildArgsAtLeastConfirmed(
            [address.toBase58()],
            commitment,
            void 0,
            options
          )),
            (commitment = create(
              await this._rpcRequest(
                "getConfirmedSignaturesForAddress2",
                address
              ),
              GetConfirmedSignaturesForAddress2RpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get confirmed signatures for address"
            );
          return commitment.result;
        }
        async getSignaturesForAddress(address, options, commitment) {
          (address = this._buildArgsAtLeastConfirmed(
            [address.toBase58()],
            commitment,
            void 0,
            options
          )),
            (commitment = create(
              await this._rpcRequest("getSignaturesForAddress", address),
              GetSignaturesForAddressRpcResult
            ));
          if ("error" in commitment)
            throw new SolanaJSONRPCError(
              commitment.error,
              "failed to get signatures for address"
            );
          return commitment.result;
        }
        async getAddressLookupTable(accountKey, config) {
          var { context: config, value: accountInfo } =
            await this.getAccountInfoAndContext(accountKey, config);
          let value = null;
          return {
            context: config,
            value: (value =
              null !== accountInfo
                ? new AddressLookupTableAccount({
                    key: accountKey,
                    state: AddressLookupTableAccount.deserialize(
                      accountInfo.data
                    ),
                  })
                : value),
          };
        }
        async getNonceAndContext(nonceAccount, commitmentOrConfig) {
          var { context: nonceAccount, value: commitmentOrConfig } =
            await this.getAccountInfoAndContext(
              nonceAccount,
              commitmentOrConfig
            );
          let value = null;
          return {
            context: nonceAccount,
            value: (value =
              null !== commitmentOrConfig
                ? NonceAccount.fromAccountData(commitmentOrConfig.data)
                : value),
          };
        }
        async getNonce(nonceAccount, commitmentOrConfig) {
          return this.getNonceAndContext(nonceAccount, commitmentOrConfig)
            .then((x) => x.value)
            .catch((e) => {
              throw new Error(
                "failed to get nonce for account " +
                  nonceAccount.toBase58() +
                  ": " +
                  e
              );
            });
        }
        async requestAirdrop(to, lamports) {
          lamports = create(
            await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]),
            RequestAirdropRpcResult
          );
          if ("error" in lamports)
            throw new SolanaJSONRPCError(
              lamports.error,
              `airdrop to ${to.toBase58()} failed`
            );
          return lamports.result;
        }
        async _blockhashWithExpiryBlockHeight(disableCache) {
          if (!disableCache) {
            for (; this._pollingBlockhash; ) await sleep(100);
            disableCache = Date.now() - this._blockhashInfo.lastFetch;
            if (
              null !== this._blockhashInfo.latestBlockhash &&
              !(3e4 <= disableCache)
            )
              return this._blockhashInfo.latestBlockhash;
          }
          return this._pollNewBlockhash();
        }
        async _pollNewBlockhash() {
          this._pollingBlockhash = !0;
          try {
            var startTime = Date.now(),
              cachedLatestBlockhash = this._blockhashInfo.latestBlockhash,
              cachedBlockhash = cachedLatestBlockhash
                ? cachedLatestBlockhash.blockhash
                : null;
            for (let i = 0; i < 50; i++) {
              var latestBlockhash = await this.getLatestBlockhash("finalized");
              if (cachedBlockhash !== latestBlockhash.blockhash)
                return (
                  (this._blockhashInfo = {
                    latestBlockhash: latestBlockhash,
                    lastFetch: Date.now(),
                    transactionSignatures: [],
                    simulatedSignatures: [],
                  }),
                  latestBlockhash
                );
              await sleep(200);
            }
            throw new Error(
              `Unable to obtain a new blockhash after ${
                Date.now() - startTime
              }ms`
            );
          } finally {
            this._pollingBlockhash = !1;
          }
        }
        async getStakeMinimumDelegation(config) {
          var { commitment: config, config: configArg } =
              extractCommitmentFromConfig(config),
            config = this._buildArgs([], config, "base64", configArg),
            configArg = create(
              await this._rpcRequest("getStakeMinimumDelegation", config),
              jsonRpcResultAndContext(dist_number())
            );
          if ("error" in configArg)
            throw new SolanaJSONRPCError(
              configArg.error,
              "failed to get stake minimum delegation"
            );
          return configArg.result;
        }
        async simulateTransaction(
          transactionOrMessage,
          configOrSigners,
          includeAccounts
        ) {
          if ("message" in transactionOrMessage) {
            const wireTransaction = transactionOrMessage.serialize(),
              encodedTransaction =
                node_modules_buffer.Buffer.from(wireTransaction).toString(
                  "base64"
                );
            if (Array.isArray(configOrSigners) || void 0 !== includeAccounts)
              throw new Error("Invalid arguments");
            const config = configOrSigners || {},
              args =
                ((config.encoding = "base64"),
                "commitment" in config || (config.commitment = this.commitment),
                [encodedTransaction, config]),
              unsafeRes = await this._rpcRequest("simulateTransaction", args),
              res = create(unsafeRes, SimulatedTransactionResponseStruct);
            if ("error" in res)
              throw new Error(
                "failed to simulate transaction: " + res.error.message
              );
            return res.result;
          }
          let transaction;
          if (
            (transactionOrMessage instanceof Transaction
              ? ((originalTx = transactionOrMessage),
                ((transaction = new Transaction()).feePayer =
                  originalTx.feePayer),
                (transaction.instructions = transactionOrMessage.instructions),
                (transaction.nonceInfo = originalTx.nonceInfo),
                (transaction.signatures = originalTx.signatures))
              : ((transaction =
                  Transaction.populate(transactionOrMessage))._message =
                  transaction._json =
                    void 0),
            void 0 !== configOrSigners && !Array.isArray(configOrSigners))
          )
            throw new Error("Invalid arguments");
          var signers = configOrSigners;
          if (transaction.nonceInfo && signers) transaction.sign(...signers);
          else {
            let disableCache = this._disableBlockhashCaching;
            for (;;) {
              var latestBlockhash = await this._blockhashWithExpiryBlockHeight(
                disableCache
              );
              if (
                ((transaction.lastValidBlockHeight =
                  latestBlockhash.lastValidBlockHeight),
                (transaction.recentBlockhash = latestBlockhash.blockhash),
                !signers)
              )
                break;
              if ((transaction.sign(...signers), !transaction.signature))
                throw new Error("!signature");
              latestBlockhash = transaction.signature.toString("base64");
              if (
                !this._blockhashInfo.simulatedSignatures.includes(
                  latestBlockhash
                ) &&
                !this._blockhashInfo.transactionSignatures.includes(
                  latestBlockhash
                )
              ) {
                this._blockhashInfo.simulatedSignatures.push(latestBlockhash);
                break;
              }
              disableCache = !0;
            }
          }
          var originalTx = transaction._compile(),
            transactionOrMessage = originalTx.serialize();
          const wireTransaction = transaction._serialize(transactionOrMessage),
            encodedTransaction = wireTransaction.toString("base64"),
            config = { encoding: "base64", commitment: this.commitment },
            args =
              (includeAccounts &&
                ((configOrSigners = (
                  Array.isArray(includeAccounts)
                    ? includeAccounts
                    : originalTx.nonProgramIds()
                ).map((key) => key.toBase58())),
                (config.accounts = {
                  encoding: "base64",
                  addresses: configOrSigners,
                })),
              signers && (config.sigVerify = !0),
              [encodedTransaction, config]),
            unsafeRes = await this._rpcRequest("simulateTransaction", args),
            res = create(unsafeRes, SimulatedTransactionResponseStruct);
          if ("error" in res) {
            let logs;
            throw (
              ("data" in res.error &&
                (logs = res.error.data.logs) &&
                Array.isArray(logs) &&
                ((transactionOrMessage = "\n    " + logs.join("\n    ")),
                console.error(res.error.message, transactionOrMessage)),
              new SendTransactionError({
                action: "simulate",
                signature: "",
                transactionMessage: res.error.message,
                logs: logs,
              }))
            );
          }
          return res.result;
        }
        async sendTransaction(transaction, signersOrOptions, options) {
          if ("version" in transaction) {
            if (signersOrOptions && Array.isArray(signersOrOptions))
              throw new Error("Invalid arguments");
            const wireTransaction = transaction.serialize();
            return this.sendRawTransaction(wireTransaction, signersOrOptions);
          }
          if (void 0 === signersOrOptions || !Array.isArray(signersOrOptions))
            throw new Error("Invalid arguments");
          var signers = signersOrOptions;
          if (transaction.nonceInfo) transaction.sign(...signers);
          else {
            let disableCache = this._disableBlockhashCaching;
            for (;;) {
              var latestBlockhash = await this._blockhashWithExpiryBlockHeight(
                disableCache
              );
              if (
                ((transaction.lastValidBlockHeight =
                  latestBlockhash.lastValidBlockHeight),
                (transaction.recentBlockhash = latestBlockhash.blockhash),
                transaction.sign(...signers),
                !transaction.signature)
              )
                throw new Error("!signature");
              latestBlockhash = transaction.signature.toString("base64");
              if (
                !this._blockhashInfo.transactionSignatures.includes(
                  latestBlockhash
                )
              ) {
                this._blockhashInfo.transactionSignatures.push(latestBlockhash);
                break;
              }
              disableCache = !0;
            }
          }
          const wireTransaction = transaction.serialize();
          return this.sendRawTransaction(wireTransaction, options);
        }
        async sendRawTransaction(rawTransaction, options) {
          rawTransaction = toBuffer(rawTransaction).toString("base64");
          return await this.sendEncodedTransaction(rawTransaction, options);
        }
        async sendEncodedTransaction(encodedTransaction, options) {
          var config = { encoding: "base64" },
            skipPreflight = options && options.skipPreflight,
            preflightCommitment =
              !0 === skipPreflight
                ? "processed"
                : (options && options.preflightCommitment) || this.commitment,
            options =
              (options &&
                null != options.maxRetries &&
                (config.maxRetries = options.maxRetries),
              options &&
                null != options.minContextSlot &&
                (config.minContextSlot = options.minContextSlot),
              skipPreflight && (config.skipPreflight = skipPreflight),
              preflightCommitment &&
                (config.preflightCommitment = preflightCommitment),
              [encodedTransaction, config]),
            preflightCommitment = create(
              await this._rpcRequest("sendTransaction", options),
              SendTransactionRpcResult
            );
          if ("error" in preflightCommitment) {
            let logs = void 0;
            throw (
              ("data" in preflightCommitment.error &&
                (logs = preflightCommitment.error.data.logs),
              new SendTransactionError({
                action: skipPreflight ? "send" : "simulate",
                signature: "",
                transactionMessage: preflightCommitment.error.message,
                logs: logs,
              }))
            );
          }
          return preflightCommitment.result;
        }
        _wsOnOpen() {
          (this._rpcWebSocketConnected = !0),
            (this._rpcWebSocketHeartbeat = setInterval(() => {
              (async () => {
                try {
                  await this._rpcWebSocket.notify("ping");
                } catch {}
              })();
            }, 5e3)),
            this._updateSubscriptions();
        }
        _wsOnError(err) {
          (this._rpcWebSocketConnected = !1),
            console.error("ws error:", err.message);
        }
        _wsOnClose(code) {
          (this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketGeneration =
              (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
            this._rpcWebSocketIdleTimeout &&
              (clearTimeout(this._rpcWebSocketIdleTimeout),
              (this._rpcWebSocketIdleTimeout = null)),
            this._rpcWebSocketHeartbeat &&
              (clearInterval(this._rpcWebSocketHeartbeat),
              (this._rpcWebSocketHeartbeat = null)),
            1e3 === code
              ? this._updateSubscriptions()
              : ((this._subscriptionCallbacksByServerSubscriptionId = {}),
                Object.entries(this._subscriptionsByHash).forEach(
                  ([hash, subscription]) => {
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "pending",
                    });
                  }
                ));
        }
        _setSubscription(hash, nextSubscription) {
          this._subscriptionsByHash[hash]?.state !==
            (this._subscriptionsByHash[hash] = nextSubscription).state &&
            (hash = this._subscriptionStateChangeCallbacksByHash[hash]) &&
            hash.forEach((cb) => {
              try {
                cb(nextSubscription.state);
              } catch {}
            });
        }
        _onSubscriptionStateChange(clientSubscriptionId, callback) {
          const hash =
            this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          if (null == hash) return () => {};
          const stateChangeCallbacks =
            (this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set());
          return (
            stateChangeCallbacks.add(callback),
            () => {
              stateChangeCallbacks.delete(callback),
                0 === stateChangeCallbacks.size &&
                  delete this._subscriptionStateChangeCallbacksByHash[hash];
            }
          );
        }
        async _updateSubscriptions() {
          if (0 === Object.keys(this._subscriptionsByHash).length)
            this._rpcWebSocketConnected &&
              ((this._rpcWebSocketConnected = !1),
              (this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                  this._rpcWebSocket.close();
                } catch (err) {
                  err instanceof Error &&
                    console.log(
                      "Error when closing socket connection: " + err.message
                    );
                }
              }, 500)));
          else if (
            (null !== this._rpcWebSocketIdleTimeout &&
              (clearTimeout(this._rpcWebSocketIdleTimeout),
              (this._rpcWebSocketIdleTimeout = null),
              (this._rpcWebSocketConnected = !0)),
            this._rpcWebSocketConnected)
          ) {
            const activeWebSocketGeneration = this._rpcWebSocketGeneration,
              isCurrentConnectionStillActive = () =>
                activeWebSocketGeneration === this._rpcWebSocketGeneration;
            await Promise.all(
              Object.keys(this._subscriptionsByHash).map(async (hash) => {
                const subscription = this._subscriptionsByHash[hash];
                if (void 0 !== subscription)
                  switch (subscription.state) {
                    case "pending":
                    case "unsubscribed":
                      if (0 === subscription.callbacks.size)
                        delete this._subscriptionsByHash[hash],
                          "unsubscribed" === subscription.state &&
                            delete this
                              ._subscriptionCallbacksByServerSubscriptionId[
                              subscription.serverSubscriptionId
                            ],
                          await this._updateSubscriptions();
                      else {
                        var { args, method } = subscription;
                        try {
                          this._setSubscription(hash, {
                            ...subscription,
                            state: "subscribing",
                          });
                          var serverSubscriptionId =
                            await this._rpcWebSocket.call(method, args);
                          this._setSubscription(hash, {
                            ...subscription,
                            serverSubscriptionId: serverSubscriptionId,
                            state: "subscribed",
                          }),
                            (this._subscriptionCallbacksByServerSubscriptionId[
                              serverSubscriptionId
                            ] = subscription.callbacks),
                            await this._updateSubscriptions();
                        } catch (e) {
                          e instanceof Error &&
                            console.error(
                              method + " error for argument",
                              args,
                              e.message
                            ),
                            isCurrentConnectionStillActive() &&
                              (this._setSubscription(hash, {
                                ...subscription,
                                state: "pending",
                              }),
                              await this._updateSubscriptions());
                        }
                        await 0;
                      }
                      break;
                    case "subscribed":
                      0 === subscription.callbacks.size &&
                        (await (async () => {
                          var { serverSubscriptionId, unsubscribeMethod } =
                            subscription;
                          if (
                            this._subscriptionsAutoDisposedByRpc.has(
                              serverSubscriptionId
                            )
                          )
                            this._subscriptionsAutoDisposedByRpc.delete(
                              serverSubscriptionId
                            );
                          else {
                            this._setSubscription(hash, {
                              ...subscription,
                              state: "unsubscribing",
                            }),
                              this._setSubscription(hash, {
                                ...subscription,
                                state: "unsubscribing",
                              });
                            try {
                              await this._rpcWebSocket.call(unsubscribeMethod, [
                                serverSubscriptionId,
                              ]);
                            } catch (e) {
                              return (
                                (e instanceof Error &&
                                  console.error(
                                    unsubscribeMethod + " error:",
                                    e.message
                                  ),
                                !isCurrentConnectionStillActive()) ||
                                (this._setSubscription(hash, {
                                  ...subscription,
                                  state: "subscribed",
                                }),
                                !(await this._updateSubscriptions()))
                              );
                            }
                          }
                          this._setSubscription(hash, {
                            ...subscription,
                            state: "unsubscribed",
                          }),
                            await this._updateSubscriptions();
                        })());
                  }
              })
            );
          } else this._rpcWebSocket.connect();
        }
        _handleServerNotification(serverSubscriptionId, callbackArgs) {
          serverSubscriptionId =
            this._subscriptionCallbacksByServerSubscriptionId[
              serverSubscriptionId
            ];
          void 0 !== serverSubscriptionId &&
            serverSubscriptionId.forEach((cb) => {
              try {
                cb(...callbackArgs);
              } catch (e) {
                console.error(e);
              }
            });
        }
        _wsOnAccountNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            AccountNotificationResult
          );
          this._handleServerNotification(subscription, [
            notification.value,
            notification.context,
          ]);
        }
        _makeSubscription(subscriptionConfig, args) {
          const clientSubscriptionId = this._nextClientSubscriptionId++,
            hash = fastStableStringify$1([subscriptionConfig.method, args]);
          var existingSubscription = this._subscriptionsByHash[hash];
          return (
            void 0 === existingSubscription
              ? (this._subscriptionsByHash[hash] = {
                  ...subscriptionConfig,
                  args: args,
                  callbacks: new Set([subscriptionConfig.callback]),
                  state: "pending",
                })
              : existingSubscription.callbacks.add(subscriptionConfig.callback),
            (this._subscriptionHashByClientSubscriptionId[
              clientSubscriptionId
            ] = hash),
            (this._subscriptionDisposeFunctionsByClientSubscriptionId[
              clientSubscriptionId
            ] = async () => {
              delete this._subscriptionDisposeFunctionsByClientSubscriptionId[
                clientSubscriptionId
              ],
                delete this._subscriptionHashByClientSubscriptionId[
                  clientSubscriptionId
                ];
              var subscription = this._subscriptionsByHash[hash];
              index_browser_esm_assert(
                void 0 !== subscription,
                "Could not find a `Subscription` when tearing down client subscription #" +
                  clientSubscriptionId
              ),
                subscription.callbacks.delete(subscriptionConfig.callback),
                await this._updateSubscriptions();
            }),
            this._updateSubscriptions(),
            clientSubscriptionId
          );
        }
        onAccountChange(publicKey, callback, commitment) {
          publicKey = this._buildArgs(
            [publicKey.toBase58()],
            commitment || this._commitment || "finalized",
            "base64"
          );
          return this._makeSubscription(
            {
              callback: callback,
              method: "accountSubscribe",
              unsubscribeMethod: "accountUnsubscribe",
            },
            publicKey
          );
        }
        async removeAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "account change"
          );
        }
        _wsOnProgramAccountNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            ProgramAccountNotificationResult
          );
          this._handleServerNotification(subscription, [
            {
              accountId: notification.value.pubkey,
              accountInfo: notification.value.account,
            },
            notification.context,
          ]);
        }
        onProgramAccountChange(programId, callback, commitment, filters) {
          programId = this._buildArgs(
            [programId.toBase58()],
            commitment || this._commitment || "finalized",
            "base64",
            filters ? { filters: filters } : void 0
          );
          return this._makeSubscription(
            {
              callback: callback,
              method: "programSubscribe",
              unsubscribeMethod: "programUnsubscribe",
            },
            programId
          );
        }
        async removeProgramAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "program account change"
          );
        }
        onLogs(filter, callback, commitment) {
          filter = this._buildArgs(
            [
              "object" == typeof filter
                ? { mentions: [filter.toString()] }
                : filter,
            ],
            commitment || this._commitment || "finalized"
          );
          return this._makeSubscription(
            {
              callback: callback,
              method: "logsSubscribe",
              unsubscribeMethod: "logsUnsubscribe",
            },
            filter
          );
        }
        async removeOnLogsListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "logs"
          );
        }
        _wsOnLogsNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            LogsNotificationResult
          );
          this._handleServerNotification(subscription, [
            notification.value,
            notification.context,
          ]);
        }
        _wsOnSlotNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            SlotNotificationResult
          );
          this._handleServerNotification(subscription, [notification]);
        }
        onSlotChange(callback) {
          return this._makeSubscription(
            {
              callback: callback,
              method: "slotSubscribe",
              unsubscribeMethod: "slotUnsubscribe",
            },
            []
          );
        }
        async removeSlotChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "slot change"
          );
        }
        _wsOnSlotUpdatesNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            SlotUpdateNotificationResult
          );
          this._handleServerNotification(subscription, [notification]);
        }
        onSlotUpdate(callback) {
          return this._makeSubscription(
            {
              callback: callback,
              method: "slotsUpdatesSubscribe",
              unsubscribeMethod: "slotsUpdatesUnsubscribe",
            },
            []
          );
        }
        async removeSlotUpdateListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "slot update"
          );
        }
        async _unsubscribeClientSubscription(
          clientSubscriptionId,
          subscriptionName
        ) {
          var dispose =
            this._subscriptionDisposeFunctionsByClientSubscriptionId[
              clientSubscriptionId
            ];
          dispose
            ? await dispose()
            : console.warn(
                "Ignored unsubscribe request because an active subscription with id " +
                  `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` +
                  "could not be found."
              );
        }
        _buildArgs(args, override, encoding, extra) {
          override = override || this._commitment;
          if (override || encoding || extra) {
            let options = {};
            encoding && (options.encoding = encoding),
              override && (options.commitment = override),
              extra && (options = Object.assign(options, extra)),
              args.push(options);
          }
          return args;
        }
        _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
          var commitment = override || this._commitment;
          if (commitment && !["confirmed", "finalized"].includes(commitment))
            throw new Error(
              "Using Connection with default commitment: `" +
                this._commitment +
                "`, but method requires at least `confirmed`"
            );
          return this._buildArgs(args, override, encoding, extra);
        }
        _wsOnSignatureNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            SignatureNotificationResult
          );
          "receivedSignature" !== notification.value &&
            this._subscriptionsAutoDisposedByRpc.add(subscription),
            this._handleServerNotification(
              subscription,
              "receivedSignature" === notification.value
                ? [{ type: "received" }, notification.context]
                : [
                    { type: "status", result: notification.value },
                    notification.context,
                  ]
            );
        }
        onSignature(signature, callback, commitment) {
          signature = this._buildArgs(
            [signature],
            commitment || this._commitment || "finalized"
          );
          const clientSubscriptionId = this._makeSubscription(
            {
              callback: (notification, context) => {
                if ("status" === notification.type) {
                  callback(notification.result, context);
                  try {
                    this.removeSignatureListener(clientSubscriptionId);
                  } catch (_err) {}
                }
              },
              method: "signatureSubscribe",
              unsubscribeMethod: "signatureUnsubscribe",
            },
            signature
          );
          return clientSubscriptionId;
        }
        onSignatureWithOptions(signature, callback, options) {
          const { commitment, ...extra } = {
            ...options,
            commitment:
              (options && options.commitment) ||
              this._commitment ||
              "finalized",
          };
          options = this._buildArgs([signature], commitment, void 0, extra);
          const clientSubscriptionId = this._makeSubscription(
            {
              callback: (notification, context) => {
                callback(notification, context);
                try {
                  this.removeSignatureListener(clientSubscriptionId);
                } catch (_err) {}
              },
              method: "signatureSubscribe",
              unsubscribeMethod: "signatureUnsubscribe",
            },
            options
          );
          return clientSubscriptionId;
        }
        async removeSignatureListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "signature result"
          );
        }
        _wsOnRootNotification(notification) {
          var { result: notification, subscription } = create(
            notification,
            RootNotificationResult
          );
          this._handleServerNotification(subscription, [notification]);
        }
        onRootChange(callback) {
          return this._makeSubscription(
            {
              callback: callback,
              method: "rootSubscribe",
              unsubscribeMethod: "rootUnsubscribe",
            },
            []
          );
        }
        async removeRootChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(
            clientSubscriptionId,
            "root change"
          );
        }
      }
      class Keypair {
        constructor(keypair) {
          (this._keypair = void 0),
            (this._keypair = keypair ?? generateKeypair());
        }
        static generate() {
          return new Keypair(generateKeypair());
        }
        static fromSecretKey(secretKey, options) {
          if (64 !== secretKey.byteLength)
            throw new Error("bad secret key size");
          var publicKey = secretKey.slice(32, 64);
          if (!options || !options.skipValidation) {
            var options = secretKey.slice(0, 32),
              computedPublicKey = getPublicKey(options);
            for (let ii = 0; ii < 32; ii++)
              if (publicKey[ii] !== computedPublicKey[ii])
                throw new Error("provided secretKey is invalid");
          }
          return new Keypair({ publicKey: publicKey, secretKey: secretKey });
        }
        static fromSeed(seed) {
          var publicKey = getPublicKey(seed),
            secretKey = new Uint8Array(64);
          return (
            secretKey.set(seed),
            secretKey.set(publicKey, 32),
            new Keypair({ publicKey: publicKey, secretKey: secretKey })
          );
        }
        get publicKey() {
          return new PublicKey(this._keypair.publicKey);
        }
        get secretKey() {
          return new Uint8Array(this._keypair.secretKey);
        }
      }
      const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
        CreateLookupTable: {
          index: 0,
          layout: Layout.w3([
            Layout.DH("instruction"),
            __webpack_exports__("recentSlot"),
            Layout.u8("bumpSeed"),
          ]),
        },
        FreezeLookupTable: {
          index: 1,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
        ExtendLookupTable: {
          index: 2,
          layout: Layout.w3([
            Layout.DH("instruction"),
            __webpack_exports__(),
            Layout.O6(publicKey(), Layout.cY(Layout.DH(), -8), "addresses"),
          ]),
        },
        DeactivateLookupTable: {
          index: 3,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
        CloseLookupTable: {
          index: 4,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
      });
      class AddressLookupTableProgram {
        constructor() {}
        static createLookupTable(params) {
          var [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync(
              [
                params.authority.toBuffer(),
                (0, browser.Bq)(BigInt(params.recentSlot), 8),
              ],
              this.programId
            ),
            bumpSeed = encodeData(
              LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,
              { recentSlot: BigInt(params.recentSlot), bumpSeed: bumpSeed }
            ),
            params = [
              { pubkey: lookupTableAddress, isSigner: !1, isWritable: !0 },
              { pubkey: params.authority, isSigner: !0, isWritable: !1 },
              { pubkey: params.payer, isSigner: !0, isWritable: !0 },
              { pubkey: SystemProgram.programId, isSigner: !1, isWritable: !1 },
            ];
          return [
            new TransactionInstruction({
              programId: this.programId,
              keys: params,
              data: bumpSeed,
            }),
            lookupTableAddress,
          ];
        }
        static freezeLookupTable(params) {
          var data = encodeData(
              LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable
            ),
            params = [
              { pubkey: params.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: params.authority, isSigner: !0, isWritable: !1 },
            ];
          return new TransactionInstruction({
            programId: this.programId,
            keys: params,
            data: data,
          });
        }
        static extendLookupTable(params) {
          var data = encodeData(
              LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,
              { addresses: params.addresses.map((addr) => addr.toBytes()) }
            ),
            keys = [
              { pubkey: params.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: params.authority, isSigner: !0, isWritable: !1 },
            ];
          return (
            params.payer &&
              keys.push(
                { pubkey: params.payer, isSigner: !0, isWritable: !0 },
                {
                  pubkey: SystemProgram.programId,
                  isSigner: !1,
                  isWritable: !1,
                }
              ),
            new TransactionInstruction({
              programId: this.programId,
              keys: keys,
              data: data,
            })
          );
        }
        static deactivateLookupTable(params) {
          var data = encodeData(
              LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable
            ),
            params = [
              { pubkey: params.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: params.authority, isSigner: !0, isWritable: !1 },
            ];
          return new TransactionInstruction({
            programId: this.programId,
            keys: params,
            data: data,
          });
        }
        static closeLookupTable(params) {
          var data = encodeData(
              LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable
            ),
            params = [
              { pubkey: params.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: params.authority, isSigner: !0, isWritable: !1 },
              { pubkey: params.recipient, isSigner: !1, isWritable: !0 },
            ];
          return new TransactionInstruction({
            programId: this.programId,
            keys: params,
            data: data,
          });
        }
      }
      AddressLookupTableProgram.programId = new PublicKey(
        "AddressLookupTab1e1111111111111111111111111"
      );
      const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
        RequestUnits: {
          index: 0,
          layout: Layout.w3([
            Layout.u8("instruction"),
            Layout.DH("units"),
            Layout.DH("additionalFee"),
          ]),
        },
        RequestHeapFrame: {
          index: 1,
          layout: Layout.w3([Layout.u8("instruction"), Layout.DH("bytes")]),
        },
        SetComputeUnitLimit: {
          index: 2,
          layout: Layout.w3([Layout.u8("instruction"), Layout.DH("units")]),
        },
        SetComputeUnitPrice: {
          index: 3,
          layout: Layout.w3([
            Layout.u8("instruction"),
            __webpack_exports__("microLamports"),
          ]),
        },
      });
      class ComputeBudgetProgram {
        constructor() {}
        static requestUnits(params) {
          params = encodeData(
            COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,
            params
          );
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: params,
          });
        }
        static requestHeapFrame(params) {
          params = encodeData(
            COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,
            params
          );
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: params,
          });
        }
        static setComputeUnitLimit(params) {
          params = encodeData(
            COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,
            params
          );
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: params,
          });
        }
        static setComputeUnitPrice(params) {
          params = encodeData(
            COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,
            { microLamports: BigInt(params.microLamports) }
          );
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: params,
          });
        }
      }
      ComputeBudgetProgram.programId = new PublicKey(
        "ComputeBudget111111111111111111111111111111"
      );
      const ED25519_INSTRUCTION_LAYOUT = Layout.w3([
        Layout.u8("numSignatures"),
        Layout.u8("padding"),
        Layout.NX("signatureOffset"),
        Layout.NX("signatureInstructionIndex"),
        Layout.NX("publicKeyOffset"),
        Layout.NX("publicKeyInstructionIndex"),
        Layout.NX("messageDataOffset"),
        Layout.NX("messageDataSize"),
        Layout.NX("messageInstructionIndex"),
      ]);
      (class Ed25519Program {
        constructor() {}
        static createInstructionWithPublicKey(params) {
          var {
              publicKey: params,
              message,
              signature,
              instructionIndex,
            } = params,
            publicKeyOffset =
              (index_browser_esm_assert(
                32 === params.length,
                `Public Key must be 32 bytes but received ${params.length} bytes`
              ),
              index_browser_esm_assert(
                64 === signature.length,
                `Signature must be 64 bytes but received ${signature.length} bytes`
              ),
              ED25519_INSTRUCTION_LAYOUT.span),
            signatureOffset = publicKeyOffset + params.length,
            messageDataOffset = signatureOffset + signature.length,
            instructionData = node_modules_buffer.Buffer.alloc(
              messageDataOffset + message.length
            ),
            instructionIndex =
              null == instructionIndex ? 65535 : instructionIndex;
          return (
            ED25519_INSTRUCTION_LAYOUT.encode(
              {
                numSignatures: 1,
                padding: 0,
                signatureOffset: signatureOffset,
                signatureInstructionIndex: instructionIndex,
                publicKeyOffset: publicKeyOffset,
                publicKeyInstructionIndex: instructionIndex,
                messageDataOffset: messageDataOffset,
                messageDataSize: message.length,
                messageInstructionIndex: instructionIndex,
              },
              instructionData
            ),
            instructionData.fill(params, publicKeyOffset),
            instructionData.fill(signature, signatureOffset),
            instructionData.fill(message, messageDataOffset),
            new TransactionInstruction({
              keys: [],
              programId: Ed25519Program.programId,
              data: instructionData,
            })
          );
        }
        static createInstructionWithPrivateKey(params) {
          var { privateKey: params, message, instructionIndex } = params;
          index_browser_esm_assert(
            64 === params.length,
            `Private key must be 64 bytes but received ${params.length} bytes`
          );
          try {
            var keypair = Keypair.fromSecretKey(params),
              publicKey = keypair.publicKey.toBytes(),
              signature = sign(message, keypair.secretKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey,
              message: message,
              signature: signature,
              instructionIndex: instructionIndex,
            });
          } catch (error) {
            throw new Error("Error creating instruction; " + error);
          }
        }
      }).programId = new PublicKey(
        "Ed25519SigVerify111111111111111111111111111"
      );
      secp256k1.utils.isValidPrivateKey;
      const publicKeyCreate = secp256k1.getPublicKey,
        SECP256K1_INSTRUCTION_LAYOUT = Layout.w3([
          Layout.u8("numSignatures"),
          Layout.NX("signatureOffset"),
          Layout.u8("signatureInstructionIndex"),
          Layout.NX("ethAddressOffset"),
          Layout.u8("ethAddressInstructionIndex"),
          Layout.NX("messageDataOffset"),
          Layout.NX("messageDataSize"),
          Layout.u8("messageInstructionIndex"),
          Layout.av(20, "ethAddress"),
          Layout.av(64, "signature"),
          Layout.u8("recoveryId"),
        ]);
      class Secp256k1Program {
        constructor() {}
        static publicKeyToEthAddress(publicKey) {
          index_browser_esm_assert(
            64 === publicKey.length,
            `Public key must be 64 bytes but received ${publicKey.length} bytes`
          );
          try {
            return node_modules_buffer.Buffer.from(
              keccak_256(toBuffer(publicKey))
            ).slice(-20);
          } catch (error) {
            throw new Error("Error constructing Ethereum address: " + error);
          }
        }
        static createInstructionWithPublicKey(params) {
          var {
            publicKey: params,
            message,
            signature,
            recoveryId,
            instructionIndex,
          } = params;
          return Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: Secp256k1Program.publicKeyToEthAddress(params),
            message: message,
            signature: signature,
            recoveryId: recoveryId,
            instructionIndex: instructionIndex,
          });
        }
        static createInstructionWithEthAddress(params) {
          var {
            ethAddress: params,
            message,
            signature,
            recoveryId,
            instructionIndex = 0,
          } = params;
          let ethAddress;
          index_browser_esm_assert(
            20 ===
              (ethAddress =
                "string" == typeof params
                  ? params.startsWith("0x")
                    ? node_modules_buffer.Buffer.from(params.substr(2), "hex")
                    : node_modules_buffer.Buffer.from(params, "hex")
                  : params).length,
            `Address must be 20 bytes but received ${ethAddress.length} bytes`
          );
          var params = 12 + ethAddress.length,
            messageDataOffset = params + signature.length + 1,
            instructionData = node_modules_buffer.Buffer.alloc(
              SECP256K1_INSTRUCTION_LAYOUT.span + message.length
            );
          return (
            SECP256K1_INSTRUCTION_LAYOUT.encode(
              {
                numSignatures: 1,
                signatureOffset: params,
                signatureInstructionIndex: instructionIndex,
                ethAddressOffset: 12,
                ethAddressInstructionIndex: instructionIndex,
                messageDataOffset: messageDataOffset,
                messageDataSize: message.length,
                messageInstructionIndex: instructionIndex,
                signature: toBuffer(signature),
                ethAddress: toBuffer(ethAddress),
                recoveryId: recoveryId,
              },
              instructionData
            ),
            instructionData.fill(
              toBuffer(message),
              SECP256K1_INSTRUCTION_LAYOUT.span
            ),
            new TransactionInstruction({
              keys: [],
              programId: Secp256k1Program.programId,
              data: instructionData,
            })
          );
        }
        static createInstructionWithPrivateKey(params) {
          var { privateKey: params, message, instructionIndex } = params;
          index_browser_esm_assert(
            32 === params.length,
            `Private key must be 32 bytes but received ${params.length} bytes`
          );
          try {
            var privateKey = toBuffer(params),
              publicKey = publicKeyCreate(privateKey, !1).slice(1),
              [signature, recoveryId] = ((msgHash, privKey) => {
                msgHash = secp256k1.sign(msgHash, privKey);
                return [msgHash.toCompactRawBytes(), msgHash.recovery];
              })(
                node_modules_buffer.Buffer.from(keccak_256(toBuffer(message))),
                privateKey
              );
            return this.createInstructionWithPublicKey({
              publicKey: publicKey,
              message: message,
              signature: signature,
              recoveryId: recoveryId,
              instructionIndex: instructionIndex,
            });
          } catch (error) {
            throw new Error("Error creating instruction; " + error);
          }
        }
      }
      Secp256k1Program.programId = new PublicKey(
        "KeccakSecp256k11111111111111111111111111111"
      );
      const STAKE_CONFIG_ID = new PublicKey(
        "StakeConfig11111111111111111111111111111111"
      );
      class Lockup {
        constructor(unixTimestamp, epoch, custodian) {
          (this.unixTimestamp = void 0),
            (this.epoch = void 0),
            (this.custodian = void 0),
            (this.unixTimestamp = unixTimestamp),
            (this.epoch = epoch),
            (this.custodian = custodian);
        }
      }
      Lockup.default = new Lockup(0, 0, PublicKey.default);
      const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
        Initialize: {
          index: 0,
          layout: Layout.w3([
            Layout.DH("instruction"),
            ((__webpack_require__ = "authorized"),
            Layout.w3(
              [publicKey("staker"), publicKey("withdrawer")],
              __webpack_require__
            )),
            ((property = "lockup") =>
              Layout.w3(
                [
                  Layout.Wg("unixTimestamp"),
                  Layout.Wg("epoch"),
                  publicKey("custodian"),
                ],
                property
              ))(),
          ]),
        },
        Authorize: {
          index: 1,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("newAuthorized"),
            Layout.DH("stakeAuthorizationType"),
          ]),
        },
        Delegate: { index: 2, layout: Layout.w3([Layout.DH("instruction")]) },
        Split: {
          index: 3,
          layout: Layout.w3([Layout.DH("instruction"), Layout.Wg("lamports")]),
        },
        Withdraw: {
          index: 4,
          layout: Layout.w3([Layout.DH("instruction"), Layout.Wg("lamports")]),
        },
        Deactivate: { index: 5, layout: Layout.w3([Layout.DH("instruction")]) },
        Merge: { index: 7, layout: Layout.w3([Layout.DH("instruction")]) },
        AuthorizeWithSeed: {
          index: 8,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("newAuthorized"),
            Layout.DH("stakeAuthorizationType"),
            rustString("authoritySeed"),
            publicKey("authorityOwner"),
          ]),
        },
      });
      Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
      class StakeProgram {
        constructor() {}
        static initialize(params) {
          var { stakePubkey: params, authorized, lockup: maybeLockup } = params,
            maybeLockup = maybeLockup || Lockup.default,
            authorized = encodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize, {
              authorized: {
                staker: toBuffer(authorized.staker.toBuffer()),
                withdrawer: toBuffer(authorized.withdrawer.toBuffer()),
              },
              lockup: {
                unixTimestamp: maybeLockup.unixTimestamp,
                epoch: maybeLockup.epoch,
                custodian: toBuffer(maybeLockup.custodian.toBuffer()),
              },
            }),
            maybeLockup = {
              keys: [
                { pubkey: params, isSigner: !1, isWritable: !0 },
                { pubkey: SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
              ],
              programId: this.programId,
              data: authorized,
            };
          return new TransactionInstruction(maybeLockup);
        }
        static createAccountWithSeed(params) {
          var transaction = new Transaction(),
            {
              stakePubkey: params,
              authorized,
              lockup,
            } = (transaction.add(
              SystemProgram.createAccountWithSeed({
                fromPubkey: params.fromPubkey,
                newAccountPubkey: params.stakePubkey,
                basePubkey: params.basePubkey,
                seed: params.seed,
                lamports: params.lamports,
                space: this.space,
                programId: this.programId,
              })
            ),
            params);
          return transaction.add(
            this.initialize({
              stakePubkey: params,
              authorized: authorized,
              lockup: lockup,
            })
          );
        }
        static createAccount(params) {
          var transaction = new Transaction(),
            {
              stakePubkey: params,
              authorized,
              lockup,
            } = (transaction.add(
              SystemProgram.createAccount({
                fromPubkey: params.fromPubkey,
                newAccountPubkey: params.stakePubkey,
                lamports: params.lamports,
                space: this.space,
                programId: this.programId,
              })
            ),
            params);
          return transaction.add(
            this.initialize({
              stakePubkey: params,
              authorized: authorized,
              lockup: lockup,
            })
          );
        }
        static delegate(params) {
          var { stakePubkey: params, authorizedPubkey, votePubkey } = params,
            data = encodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate);
          return new Transaction().add({
            keys: [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: votePubkey, isSigner: !1, isWritable: !1 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1,
              },
              { pubkey: STAKE_CONFIG_ID, isSigner: !1, isWritable: !1 },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: data,
          });
        }
        static authorize(params) {
          var {
              stakePubkey: params,
              authorizedPubkey,
              newAuthorizedPubkey,
              stakeAuthorizationType,
              custodianPubkey,
            } = params,
            newAuthorizedPubkey = encodeData(
              STAKE_INSTRUCTION_LAYOUTS.Authorize,
              {
                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
                stakeAuthorizationType: stakeAuthorizationType.index,
              }
            ),
            stakeAuthorizationType = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !0 },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ];
          return (
            custodianPubkey &&
              stakeAuthorizationType.push({
                pubkey: custodianPubkey,
                isSigner: !0,
                isWritable: !1,
              }),
            new Transaction().add({
              keys: stakeAuthorizationType,
              programId: this.programId,
              data: newAuthorizedPubkey,
            })
          );
        }
        static authorizeWithSeed(params) {
          var {
              stakePubkey: params,
              authorityBase,
              authoritySeed,
              authorityOwner,
              newAuthorizedPubkey,
              stakeAuthorizationType,
              custodianPubkey,
            } = params,
            newAuthorizedPubkey = encodeData(
              STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,
              {
                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
                stakeAuthorizationType: stakeAuthorizationType.index,
                authoritySeed: authoritySeed,
                authorityOwner: toBuffer(authorityOwner.toBuffer()),
              }
            ),
            stakeAuthorizationType = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: authorityBase, isSigner: !0, isWritable: !1 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
            ];
          return (
            custodianPubkey &&
              stakeAuthorizationType.push({
                pubkey: custodianPubkey,
                isSigner: !0,
                isWritable: !1,
              }),
            new Transaction().add({
              keys: stakeAuthorizationType,
              programId: this.programId,
              data: newAuthorizedPubkey,
            })
          );
        }
        static splitInstruction(params) {
          var {
              stakePubkey: params,
              authorizedPubkey,
              splitStakePubkey,
              lamports,
            } = params,
            lamports = encodeData(STAKE_INSTRUCTION_LAYOUTS.Split, {
              lamports: lamports,
            });
          return new TransactionInstruction({
            keys: [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: splitStakePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: lamports,
          });
        }
        static split(params, rentExemptReserve) {
          var transaction = new Transaction();
          return (
            transaction.add(
              SystemProgram.createAccount({
                fromPubkey: params.authorizedPubkey,
                newAccountPubkey: params.splitStakePubkey,
                lamports: rentExemptReserve,
                space: this.space,
                programId: this.programId,
              })
            ),
            transaction.add(this.splitInstruction(params))
          );
        }
        static splitWithSeed(params, rentExemptReserve) {
          var {
              stakePubkey,
              authorizedPubkey,
              splitStakePubkey,
              basePubkey,
              seed,
              lamports,
            } = params,
            transaction = new Transaction();
          return (
            transaction.add(
              SystemProgram.allocate({
                accountPubkey: splitStakePubkey,
                basePubkey: basePubkey,
                seed: seed,
                space: this.space,
                programId: this.programId,
              })
            ),
            rentExemptReserve &&
              0 < rentExemptReserve &&
              transaction.add(
                SystemProgram.transfer({
                  fromPubkey: params.authorizedPubkey,
                  toPubkey: splitStakePubkey,
                  lamports: rentExemptReserve,
                })
              ),
            transaction.add(
              this.splitInstruction({
                stakePubkey: stakePubkey,
                authorizedPubkey: authorizedPubkey,
                splitStakePubkey: splitStakePubkey,
                lamports: lamports,
              })
            )
          );
        }
        static merge(params) {
          var {
              stakePubkey: params,
              sourceStakePubKey,
              authorizedPubkey,
            } = params,
            data = encodeData(STAKE_INSTRUCTION_LAYOUTS.Merge);
          return new Transaction().add({
            keys: [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: sourceStakePubKey, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1,
              },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: data,
          });
        }
        static withdraw(params) {
          var {
              stakePubkey: params,
              authorizedPubkey,
              toPubkey,
              lamports,
              custodianPubkey,
            } = params,
            lamports = encodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw, {
              lamports: lamports,
            }),
            params = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: toPubkey, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1,
              },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ];
          return (
            custodianPubkey &&
              params.push({
                pubkey: custodianPubkey,
                isSigner: !0,
                isWritable: !1,
              }),
            new Transaction().add({
              keys: params,
              programId: this.programId,
              data: lamports,
            })
          );
        }
        static deactivate(params) {
          var { stakePubkey: params, authorizedPubkey } = params,
            data = encodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate);
          return new Transaction().add({
            keys: [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: data,
          });
        }
      }
      (StakeProgram.programId = new PublicKey(
        "Stake11111111111111111111111111111111111111"
      )),
        (StakeProgram.space = 200);
      const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
        InitializeAccount: {
          index: 0,
          layout: Layout.w3([
            Layout.DH("instruction"),
            ((property = "voteInit") =>
              Layout.w3(
                [
                  publicKey("nodePubkey"),
                  publicKey("authorizedVoter"),
                  publicKey("authorizedWithdrawer"),
                  Layout.u8("commission"),
                ],
                property
              ))(),
          ]),
        },
        Authorize: {
          index: 1,
          layout: Layout.w3([
            Layout.DH("instruction"),
            publicKey("newAuthorized"),
            Layout.DH("voteAuthorizationType"),
          ]),
        },
        Withdraw: {
          index: 3,
          layout: Layout.w3([Layout.DH("instruction"), Layout.Wg("lamports")]),
        },
        UpdateValidatorIdentity: {
          index: 4,
          layout: Layout.w3([Layout.DH("instruction")]),
        },
        AuthorizeWithSeed: {
          index: 10,
          layout: Layout.w3([
            Layout.DH("instruction"),
            ((property = "voteAuthorizeWithSeedArgs") =>
              Layout.w3(
                [
                  Layout.DH("voteAuthorizationType"),
                  publicKey("currentAuthorityDerivedKeyOwnerPubkey"),
                  rustString("currentAuthorityDerivedKeySeed"),
                  publicKey("newAuthorized"),
                ],
                property
              ))(),
          ]),
        },
      });
      Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
      class VoteProgram {
        constructor() {}
        static initializeAccount(params) {
          var { votePubkey: params, nodePubkey, voteInit } = params,
            voteInit = encodeData(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, {
              voteInit: {
                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
                authorizedWithdrawer: toBuffer(
                  voteInit.authorizedWithdrawer.toBuffer()
                ),
                commission: voteInit.commission,
              },
            }),
            params = {
              keys: [
                { pubkey: params, isSigner: !1, isWritable: !0 },
                { pubkey: SYSVAR_RENT_PUBKEY, isSigner: !1, isWritable: !1 },
                { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
                { pubkey: nodePubkey, isSigner: !0, isWritable: !1 },
              ],
              programId: this.programId,
              data: voteInit,
            };
          return new TransactionInstruction(params);
        }
        static createAccount(params) {
          var transaction = new Transaction();
          return (
            transaction.add(
              SystemProgram.createAccount({
                fromPubkey: params.fromPubkey,
                newAccountPubkey: params.votePubkey,
                lamports: params.lamports,
                space: this.space,
                programId: this.programId,
              })
            ),
            transaction.add(
              this.initializeAccount({
                votePubkey: params.votePubkey,
                nodePubkey: params.voteInit.nodePubkey,
                voteInit: params.voteInit,
              })
            )
          );
        }
        static authorize(params) {
          var {
              votePubkey: params,
              authorizedPubkey,
              newAuthorizedPubkey,
              voteAuthorizationType,
            } = params,
            newAuthorizedPubkey = encodeData(
              VOTE_INSTRUCTION_LAYOUTS.Authorize,
              {
                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
                voteAuthorizationType: voteAuthorizationType.index,
              }
            ),
            voteAuthorizationType = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              { pubkey: authorizedPubkey, isSigner: !0, isWritable: !1 },
            ];
          return new Transaction().add({
            keys: voteAuthorizationType,
            programId: this.programId,
            data: newAuthorizedPubkey,
          });
        }
        static authorizeWithSeed(params) {
          var {
              currentAuthorityDerivedKeyBasePubkey: params,
              currentAuthorityDerivedKeyOwnerPubkey,
              currentAuthorityDerivedKeySeed,
              newAuthorizedPubkey,
              voteAuthorizationType,
              votePubkey,
            } = params,
            currentAuthorityDerivedKeyOwnerPubkey = encodeData(
              VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,
              {
                voteAuthorizeWithSeedArgs: {
                  currentAuthorityDerivedKeyOwnerPubkey: toBuffer(
                    currentAuthorityDerivedKeyOwnerPubkey.toBuffer()
                  ),
                  currentAuthorityDerivedKeySeed:
                    currentAuthorityDerivedKeySeed,
                  newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
                  voteAuthorizationType: voteAuthorizationType.index,
                },
              }
            ),
            currentAuthorityDerivedKeySeed = [
              { pubkey: votePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: !1, isWritable: !1 },
              { pubkey: params, isSigner: !0, isWritable: !1 },
            ];
          return new Transaction().add({
            keys: currentAuthorityDerivedKeySeed,
            programId: this.programId,
            data: currentAuthorityDerivedKeyOwnerPubkey,
          });
        }
        static withdraw(params) {
          var {
              votePubkey: params,
              authorizedWithdrawerPubkey,
              lamports,
              toPubkey,
            } = params,
            lamports = encodeData(VOTE_INSTRUCTION_LAYOUTS.Withdraw, {
              lamports: lamports,
            }),
            params = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: toPubkey, isSigner: !1, isWritable: !0 },
              {
                pubkey: authorizedWithdrawerPubkey,
                isSigner: !0,
                isWritable: !1,
              },
            ];
          return new Transaction().add({
            keys: params,
            programId: this.programId,
            data: lamports,
          });
        }
        static safeWithdraw(
          params,
          currentVoteAccountBalance,
          rentExemptMinimum
        ) {
          if (params.lamports > currentVoteAccountBalance - rentExemptMinimum)
            throw new Error(
              "Withdraw will leave vote account with insufficient funds."
            );
          return VoteProgram.withdraw(params);
        }
        static updateValidatorIdentity(params) {
          var {
              votePubkey: params,
              authorizedWithdrawerPubkey,
              nodePubkey,
            } = params,
            data = encodeData(VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity),
            params = [
              { pubkey: params, isSigner: !1, isWritable: !0 },
              { pubkey: nodePubkey, isSigner: !0, isWritable: !1 },
              {
                pubkey: authorizedWithdrawerPubkey,
                isSigner: !0,
                isWritable: !1,
              },
            ];
          return new Transaction().add({
            keys: params,
            programId: this.programId,
            data: data,
          });
        }
      }
      (VoteProgram.programId = new PublicKey(
        "Vote111111111111111111111111111111111111111"
      )),
        (VoteProgram.space = 3762);
      new PublicKey("Va1idator1nfo111111111111111111111111111111"),
        type({
          name: string(),
          website: optional(string()),
          details: optional(string()),
          keybaseUsername: optional(string()),
        });
      new PublicKey("Vote111111111111111111111111111111111111111");
      Layout.w3([
        publicKey("nodePubkey"),
        publicKey("authorizedWithdrawer"),
        Layout.u8("commission"),
        Layout.I0(),
        Layout.O6(
          Layout.w3([Layout.I0("slot"), Layout.DH("confirmationCount")]),
          Layout.cY(Layout.DH(), -8),
          "votes"
        ),
        Layout.u8("rootSlotValid"),
        Layout.I0("rootSlot"),
        Layout.I0(),
        Layout.O6(
          Layout.w3([Layout.I0("epoch"), publicKey("authorizedVoter")]),
          Layout.cY(Layout.DH(), -8),
          "authorizedVoters"
        ),
        Layout.w3(
          [
            Layout.O6(
              Layout.w3([
                publicKey("authorizedPubkey"),
                Layout.I0("epochOfLastAuthorizedSwitch"),
                Layout.I0("targetEpoch"),
              ]),
              32,
              "buf"
            ),
            Layout.I0("idx"),
            Layout.u8("isEmpty"),
          ],
          "priorVoters"
        ),
        Layout.I0(),
        Layout.O6(
          Layout.w3([
            Layout.I0("epoch"),
            Layout.I0("credits"),
            Layout.I0("prevCredits"),
          ]),
          Layout.cY(Layout.DH(), -8),
          "epochCredits"
        ),
        Layout.w3([Layout.I0("slot"), Layout.I0("timestamp")], "lastTimestamp"),
      ]);
      const endpoint = {
        http: {
          devnet: "http://api.devnet.solana.com",
          testnet: "http://api.testnet.solana.com",
          "mainnet-beta": "http://api.mainnet-beta.solana.com/",
        },
        https: {
          devnet: "https://api.devnet.solana.com",
          testnet: "https://api.testnet.solana.com",
          "mainnet-beta": "https://api.mainnet-beta.solana.com/",
        },
      };
    },
    2993: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _Buffer = __webpack_require__(1817).Buffer;
      module.exports = function base(ALPHABET) {
        if (255 <= ALPHABET.length) throw new TypeError("Alphabet too long");
        for (
          var BASE_MAP = new Uint8Array(256), j = 0;
          j < BASE_MAP.length;
          j++
        )
          BASE_MAP[j] = 255;
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i),
            xc = x.charCodeAt(0);
          if (255 !== BASE_MAP[xc]) throw new TypeError(x + " is ambiguous");
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length,
          LEADER = ALPHABET.charAt(0),
          FACTOR = Math.log(BASE) / Math.log(256),
          iFACTOR = Math.log(256) / Math.log(BASE);
        function decodeUnsafe(source) {
          if ("string" != typeof source) throw new TypeError("Expected String");
          if (0 === source.length) return _Buffer.alloc(0);
          for (var psz = 0, zeroes = 0, length = 0; source[psz] === LEADER; )
            zeroes++, psz++;
          for (
            var size = ((source.length - psz) * FACTOR + 1) >>> 0,
              b256 = new Uint8Array(size);
            source[psz];

          ) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (255 === carry) return;
            for (
              var i = 0, it3 = size - 1;
              (0 !== carry || i < length) && -1 !== it3;
              it3--, i++
            )
              (carry += (BASE * b256[it3]) >>> 0),
                (b256[it3] = carry % 256 >>> 0),
                (carry = (carry / 256) >>> 0);
            if (0 !== carry) throw new Error("Non-zero carry");
            (length = i), psz++;
          }
          for (var it4 = size - length; it4 !== size && 0 === b256[it4]; )
            it4++;
          for (
            var vch = _Buffer.allocUnsafe(zeroes + (size - it4)),
              j = (vch.fill(0, 0, zeroes), zeroes);
            it4 !== size;

          )
            vch[j++] = b256[it4++];
          return vch;
        }
        return {
          encode: function encode(source) {
            if (
              ((Array.isArray(source) || source instanceof Uint8Array) &&
                (source = _Buffer.from(source)),
              !_Buffer.isBuffer(source))
            )
              throw new TypeError("Expected Buffer");
            if (0 === source.length) return "";
            for (
              var zeroes = 0, length = 0, pbegin = 0, pend = source.length;
              pbegin !== pend && 0 === source[pbegin];

            )
              pbegin++, zeroes++;
            for (
              var size = ((pend - pbegin) * iFACTOR + 1) >>> 0,
                b58 = new Uint8Array(size);
              pbegin !== pend;

            ) {
              for (
                var carry = source[pbegin], i = 0, it1 = size - 1;
                (0 !== carry || i < length) && -1 !== it1;
                it1--, i++
              )
                (carry += (256 * b58[it1]) >>> 0),
                  (b58[it1] = carry % BASE >>> 0),
                  (carry = (carry / BASE) >>> 0);
              if (0 !== carry) throw new Error("Non-zero carry");
              (length = i), pbegin++;
            }
            for (var it2 = size - length; it2 !== size && 0 === b58[it2]; )
              it2++;
            for (var str = LEADER.repeat(zeroes); it2 < size; ++it2)
              str += ALPHABET.charAt(b58[it2]);
            return str;
          },
          decodeUnsafe: decodeUnsafe,
          decode: function decode(string) {
            if ((string = decodeUnsafe(string))) return string;
            throw new Error("Non-base" + BASE + " character");
          },
        };
      };
    },
    3718: (module, __unused_webpack_exports, __webpack_require__) => {
      __webpack_require__ = __webpack_require__(2993);
      module.exports = __webpack_require__(
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      );
    },
    1736: (module) => {
      "use strict";
      module.exports = function base(ALPHABET) {
        if (255 <= ALPHABET.length) throw new TypeError("Alphabet too long");
        for (
          var BASE_MAP = new Uint8Array(256), j = 0;
          j < BASE_MAP.length;
          j++
        )
          BASE_MAP[j] = 255;
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i),
            xc = x.charCodeAt(0);
          if (255 !== BASE_MAP[xc]) throw new TypeError(x + " is ambiguous");
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length,
          LEADER = ALPHABET.charAt(0),
          FACTOR = Math.log(BASE) / Math.log(256),
          iFACTOR = Math.log(256) / Math.log(BASE);
        function decodeUnsafe(source) {
          if ("string" != typeof source) throw new TypeError("Expected String");
          if (0 === source.length) return new Uint8Array();
          for (var psz = 0, zeroes = 0, length = 0; source[psz] === LEADER; )
            zeroes++, psz++;
          for (
            var size = ((source.length - psz) * FACTOR + 1) >>> 0,
              b256 = new Uint8Array(size);
            source[psz];

          ) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (255 === carry) return;
            for (
              var i = 0, it3 = size - 1;
              (0 !== carry || i < length) && -1 !== it3;
              it3--, i++
            )
              (carry += (BASE * b256[it3]) >>> 0),
                (b256[it3] = carry % 256 >>> 0),
                (carry = (carry / 256) >>> 0);
            if (0 !== carry) throw new Error("Non-zero carry");
            (length = i), psz++;
          }
          for (var it4 = size - length; it4 !== size && 0 === b256[it4]; )
            it4++;
          for (
            var vch = new Uint8Array(zeroes + (size - it4)), j = zeroes;
            it4 !== size;

          )
            vch[j++] = b256[it4++];
          return vch;
        }
        return {
          encode: function encode(source) {
            if (
              (source instanceof Uint8Array ||
                (ArrayBuffer.isView(source)
                  ? (source = new Uint8Array(
                      source.buffer,
                      source.byteOffset,
                      source.byteLength
                    ))
                  : Array.isArray(source) &&
                    (source = Uint8Array.from(source))),
              !(source instanceof Uint8Array))
            )
              throw new TypeError("Expected Uint8Array");
            if (0 === source.length) return "";
            for (
              var zeroes = 0, length = 0, pbegin = 0, pend = source.length;
              pbegin !== pend && 0 === source[pbegin];

            )
              pbegin++, zeroes++;
            for (
              var size = ((pend - pbegin) * iFACTOR + 1) >>> 0,
                b58 = new Uint8Array(size);
              pbegin !== pend;

            ) {
              for (
                var carry = source[pbegin], i = 0, it1 = size - 1;
                (0 !== carry || i < length) && -1 !== it1;
                it1--, i++
              )
                (carry += (256 * b58[it1]) >>> 0),
                  (b58[it1] = carry % BASE >>> 0),
                  (carry = (carry / BASE) >>> 0);
              if (0 !== carry) throw new Error("Non-zero carry");
              (length = i), pbegin++;
            }
            for (var it2 = size - length; it2 !== size && 0 === b58[it2]; )
              it2++;
            for (var str = LEADER.repeat(zeroes); it2 < size; ++it2)
              str += ALPHABET.charAt(b58[it2]);
            return str;
          },
          decodeUnsafe: decodeUnsafe,
          decode: function decode(string) {
            if ((string = decodeUnsafe(string))) return string;
            throw new Error("Non-base" + BASE + " character");
          },
        };
      };
    },
    7322: (__unused_webpack_module, exports) => {
      "use strict";
      (exports.byteLength = function byteLength(b64) {
        var b64 = getLens(b64),
          validLen = b64[0],
          b64 = b64[1];
        return (3 * (validLen + b64)) / 4 - b64;
      }),
        (exports.toByteArray = function toByteArray(b64) {
          var tmp,
            i,
            lens = getLens(b64),
            validLen = lens[0],
            lens = lens[1],
            arr = new Arr(
              (function _byteLength(b64, validLen, placeHoldersLen) {
                return (3 * (validLen + placeHoldersLen)) / 4 - placeHoldersLen;
              })(0, validLen, lens)
            ),
            curByte = 0,
            len = 0 < lens ? validLen - 4 : validLen;
          for (i = 0; i < len; i += 4)
            (tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)]),
              (arr[curByte++] = (tmp >> 16) & 255),
              (arr[curByte++] = (tmp >> 8) & 255),
              (arr[curByte++] = 255 & tmp);
          2 === lens &&
            ((tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4)),
            (arr[curByte++] = 255 & tmp));
          1 === lens &&
            ((tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2)),
            (arr[curByte++] = (tmp >> 8) & 255),
            (arr[curByte++] = 255 & tmp));
          return arr;
        }),
        (exports.fromByteArray = function fromByteArray(uint8) {
          for (
            var tmp,
              len = uint8.length,
              extraBytes = len % 3,
              parts = [],
              i = 0,
              len2 = len - extraBytes;
            i < len2;
            i += 16383
          )
            parts.push(
              (function encodeChunk(uint8, start, end) {
                for (var tmp, output = [], i = start; i < end; i += 3)
                  (tmp =
                    ((uint8[i] << 16) & 16711680) +
                    ((uint8[i + 1] << 8) & 65280) +
                    (255 & uint8[i + 2])),
                    output.push(
                      (function tripletToBase64(num) {
                        return (
                          lookup[(num >> 18) & 63] +
                          lookup[(num >> 12) & 63] +
                          lookup[(num >> 6) & 63] +
                          lookup[63 & num]
                        );
                      })(tmp)
                    );
                return output.join("");
              })(uint8, i, len2 < i + 16383 ? len2 : i + 16383)
            );
          1 == extraBytes
            ? ((tmp = uint8[len - 1]),
              parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 63] + "=="))
            : 2 == extraBytes &&
              ((tmp = (uint8[len - 2] << 8) + uint8[len - 1]),
              parts.push(
                lookup[tmp >> 10] +
                  lookup[(tmp >> 4) & 63] +
                  lookup[(tmp << 2) & 63] +
                  "="
              ));
          return parts.join("");
        });
      for (
        var lookup = [],
          revLookup = [],
          Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          code =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          i = 0,
          len = code.length;
        i < len;
        ++i
      )
        (lookup[i] = code[i]), (revLookup[code.charCodeAt(i)] = i);
      function getLens(b64) {
        var len = b64.length;
        if (0 < len % 4)
          throw new Error("Invalid string. Length must be a multiple of 4");
        (b64 = b64.indexOf("=")),
          (len = (b64 = -1 === b64 ? len : b64) === len ? 0 : 4 - (b64 % 4));
        return [b64, len];
      }
      (revLookup["-".charCodeAt(0)] = 62), (revLookup["_".charCodeAt(0)] = 63);
    },
    1740: (__unused_webpack_module, exports) => {
      "use strict";
      (exports.k5 = function toBigIntLE(buf) {
        return (
          (buf = Buffer.from(buf)).reverse(),
          0 === (buf = buf.toString("hex")).length
            ? BigInt(0)
            : BigInt("0x" + buf)
        );
      }),
        (exports.Bq = function toBufferLE(num, width) {
          return (
            (num = num.toString(16)),
            (num = Buffer.from(
              num.padStart(2 * width, "0").slice(0, 2 * width),
              "hex"
            )).reverse(),
            num
          );
        });
    },
    7240: function (module, __unused_webpack_exports, __webpack_require__) {
      !(function (module, exports) {
        "use strict";
        function assert(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          function TempCtor() {}
          (TempCtor.prototype = superCtor.prototype),
            (ctor.prototype = new TempCtor()),
            (ctor.prototype.constructor = ctor);
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) return number;
          (this.negative = 0),
            (this.words = null),
            (this.length = 0),
            (this.red = null) !== number &&
              (("le" !== base && "be" !== base) ||
                ((endian = base), (base = 10)),
              this._init(number || 0, base || 10, endian || "be"));
        }
        var Buffer;
        "object" == typeof module ? (module.exports = BN) : (exports.BN = BN),
          ((BN.BN = BN).wordSize = 26);
        try {
          Buffer = (
            "undefined" != typeof window && void 0 !== window.Buffer
              ? window
              : __webpack_require__(5066)
          ).Buffer;
        } catch (e) {}
        function parseHex4Bits(string, index) {
          index = string.charCodeAt(index);
          return 48 <= index && index <= 57
            ? index - 48
            : 65 <= index && index <= 70
            ? index - 55
            : 97 <= index && index <= 102
            ? index - 87
            : void assert(!1, "Invalid character in " + string);
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          return (
            lowerBound <= index - 1 &&
              (r |= parseHex4Bits(string, index - 1) << 4),
            r
          );
        }
        function parseBase(str, start, end, mul) {
          for (
            var r = 0, b = 0, len = Math.min(str.length, end), i = start;
            i < len;
            i++
          ) {
            var c = str.charCodeAt(i) - 48;
            (r *= mul),
              (b = 49 <= c ? c - 49 + 10 : 17 <= c ? c - 17 + 10 : c),
              assert(0 <= c && b < mul, "Invalid character"),
              (r += b);
          }
          return r;
        }
        function move(dest, src) {
          (dest.words = src.words),
            (dest.length = src.length),
            (dest.negative = src.negative),
            (dest.red = src.red);
        }
        if (
          ((BN.isBN = function isBN(num) {
            return (
              num instanceof BN ||
              (null !== num &&
                "object" == typeof num &&
                num.constructor.wordSize === BN.wordSize &&
                Array.isArray(num.words))
            );
          }),
          (BN.max = function max(left, right) {
            return 0 < left.cmp(right) ? left : right;
          }),
          (BN.min = function min(left, right) {
            return left.cmp(right) < 0 ? left : right;
          }),
          (BN.prototype._init = function init(number, base, endian) {
            if ("number" == typeof number)
              return this._initNumber(number, base, endian);
            if ("object" == typeof number)
              return this._initArray(number, base, endian);
            assert(
              (base = "hex" === base ? 16 : base) === (0 | base) &&
                2 <= base &&
                base <= 36
            );
            var start = 0;
            "-" === (number = number.toString().replace(/\s+/g, ""))[0] &&
              (start++, (this.negative = 1)),
              start < number.length &&
                (16 === base
                  ? this._parseHex(number, start, endian)
                  : (this._parseBase(number, base, start),
                    "le" === endian &&
                      this._initArray(this.toArray(), base, endian)));
          }),
          (BN.prototype._initNumber = function _initNumber(
            number,
            base,
            endian
          ) {
            number < 0 && ((this.negative = 1), (number = -number)),
              number < 67108864
                ? ((this.words = [67108863 & number]), (this.length = 1))
                : number < 4503599627370496
                ? ((this.words = [
                    67108863 & number,
                    (number / 67108864) & 67108863,
                  ]),
                  (this.length = 2))
                : (assert(number < 9007199254740992),
                  (this.words = [
                    67108863 & number,
                    (number / 67108864) & 67108863,
                    1,
                  ]),
                  (this.length = 3)),
              "le" === endian && this._initArray(this.toArray(), base, endian);
          }),
          (BN.prototype._initArray = function _initArray(number, base, endian) {
            if ((assert("number" == typeof number.length), number.length <= 0))
              return (this.words = [0]), (this.length = 1), this;
            (this.length = Math.ceil(number.length / 3)),
              (this.words = new Array(this.length));
            for (var j, w, i = 0; i < this.length; i++) this.words[i] = 0;
            var off = 0;
            if ("be" === endian)
              for (i = number.length - 1, j = 0; 0 <= i; i -= 3)
                (w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16)),
                  (this.words[j] |= (w << off) & 67108863),
                  (this.words[j + 1] = (w >>> (26 - off)) & 67108863),
                  26 <= (off += 24) && ((off -= 26), j++);
            else if ("le" === endian)
              for (j = i = 0; i < number.length; i += 3)
                (w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16)),
                  (this.words[j] |= (w << off) & 67108863),
                  (this.words[j + 1] = (w >>> (26 - off)) & 67108863),
                  26 <= (off += 24) && ((off -= 26), j++);
            return this._strip();
          }),
          (BN.prototype._parseHex = function _parseHex(number, start, endian) {
            (this.length = Math.ceil((number.length - start) / 6)),
              (this.words = new Array(this.length));
            for (var i = 0; i < this.length; i++) this.words[i] = 0;
            var w,
              off = 0,
              j = 0;
            if ("be" === endian)
              for (i = number.length - 1; start <= i; i -= 2)
                (w = parseHexByte(number, start, i) << off),
                  (this.words[j] |= 67108863 & w),
                  18 <= off
                    ? ((off -= 18), (this.words[(j += 1)] |= w >>> 26))
                    : (off += 8);
            else
              for (
                i = (number.length - start) % 2 == 0 ? start + 1 : start;
                i < number.length;
                i += 2
              )
                (w = parseHexByte(number, start, i) << off),
                  (this.words[j] |= 67108863 & w),
                  18 <= off
                    ? ((off -= 18), (this.words[(j += 1)] |= w >>> 26))
                    : (off += 8);
            this._strip();
          }),
          (BN.prototype._parseBase = function _parseBase(number, base, start) {
            this.words = [0];
            for (
              var limbLen = 0, limbPow = (this.length = 1);
              limbPow <= 67108863;
              limbPow *= base
            )
              limbLen++;
            for (
              var limbPow = (limbPow / base) | 0,
                total = number.length - start,
                mod = total % --limbLen,
                end = Math.min(total, total - mod) + start,
                word = 0,
                i = start;
              i < end;
              i += limbLen
            )
              (word = parseBase(number, i, i + limbLen, base)),
                this.imuln(limbPow),
                this.words[0] + word < 67108864
                  ? (this.words[0] += word)
                  : this._iaddn(word);
            if (0 != mod) {
              for (
                var pow = 1,
                  word = parseBase(number, i, number.length, base),
                  i = 0;
                i < mod;
                i++
              )
                pow *= base;
              this.imuln(pow),
                this.words[0] + word < 67108864
                  ? (this.words[0] += word)
                  : this._iaddn(word);
            }
            this._strip();
          }),
          (BN.prototype.copy = function copy(dest) {
            dest.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) dest.words[i] = this.words[i];
            (dest.length = this.length),
              (dest.negative = this.negative),
              (dest.red = this.red);
          }),
          (BN.prototype._move = function _move(dest) {
            move(dest, this);
          }),
          (BN.prototype.clone = function clone() {
            var r = new BN(null);
            return this.copy(r), r;
          }),
          (BN.prototype._expand = function _expand(size) {
            for (; this.length < size; ) this.words[this.length++] = 0;
            return this;
          }),
          (BN.prototype._strip = function strip() {
            for (; 1 < this.length && 0 === this.words[this.length - 1]; )
              this.length--;
            return this._normSign();
          }),
          (BN.prototype._normSign = function _normSign() {
            return (
              1 === this.length && 0 === this.words[0] && (this.negative = 0),
              this
            );
          }),
          "undefined" != typeof Symbol && "function" == typeof Symbol.for)
        )
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        else BN.prototype.inspect = inspect;
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        function allocate(ArrayType, size) {
          return ArrayType.allocUnsafe
            ? ArrayType.allocUnsafe(size)
            : new ArrayType(size);
        }
        var zeros = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000",
          ],
          groupSizes = [
            0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          ],
          groupBases = [
            0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
            16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
            11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
            5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
            20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
            60466176,
          ];
        (BN.prototype.toString = function toString(base, padding) {
          if (
            ((padding = 0 | padding || 1),
            16 === (base = base || 10) || "hex" === base)
          ) {
            for (
              var out = "", off = 0, carry = 0, i = 0;
              i < this.length;
              i++
            ) {
              var w = this.words[i],
                word = (16777215 & ((w << off) | carry)).toString(16),
                carry = (w >>> (24 - off)) & 16777215;
              26 <= (off += 2) && ((off -= 26), i--),
                (out =
                  0 !== carry || i !== this.length - 1
                    ? zeros[6 - word.length] + word + out
                    : word + out);
            }
            for (
              0 !== carry && (out = carry.toString(16) + out);
              out.length % padding != 0;

            )
              out = "0" + out;
            return (out = 0 !== this.negative ? "-" + out : out);
          }
          if (base === (0 | base) && 2 <= base && base <= 36) {
            var groupSize = groupSizes[base],
              groupBase = groupBases[base];
            for (out = "", (c = this.clone()).negative = 0; !c.isZero(); ) {
              var c,
                r = c.modrn(groupBase).toString(base);
              out = (c = c.idivn(groupBase)).isZero()
                ? r + out
                : zeros[groupSize - r.length] + r + out;
            }
            for (
              this.isZero() && (out = "0" + out);
              out.length % padding != 0;

            )
              out = "0" + out;
            return (out = 0 !== this.negative ? "-" + out : out);
          }
          assert(!1, "Base should be between 2 and 36");
        }),
          (BN.prototype.toNumber = function toNumber() {
            var ret = this.words[0];
            return (
              2 === this.length
                ? (ret += 67108864 * this.words[1])
                : 3 === this.length && 1 === this.words[2]
                ? (ret += 4503599627370496 + 67108864 * this.words[1])
                : 2 < this.length &&
                  assert(!1, "Number can only safely store up to 53 bits"),
              0 !== this.negative ? -ret : ret
            );
          }),
          (BN.prototype.toJSON = function toJSON() {
            return this.toString(16, 2);
          }),
          Buffer &&
            (BN.prototype.toBuffer = function toBuffer(endian, length) {
              return this.toArrayLike(Buffer, endian, length);
            }),
          (BN.prototype.toArray = function toArray(endian, length) {
            return this.toArrayLike(Array, endian, length);
          });
        function smallMulTo(self, num, out) {
          out.negative = num.negative ^ self.negative;
          var len = (self.length + num.length) | 0,
            len = ((out.length = len) - 1) | 0,
            carry =
              ((r = (0 | self.words[0]) * (0 | num.words[0])) / 67108864) | 0;
          out.words[0] = 67108863 & r;
          for (var k = 1; k < len; k++) {
            for (
              var r,
                ncarry = carry >>> 26,
                rword = 67108863 & carry,
                maxJ = Math.min(k, num.length - 1),
                j = Math.max(0, k - self.length + 1);
              j <= maxJ;
              j++
            )
              (ncarry +=
                ((r =
                  (0 | self.words[(k - j) | 0]) * (0 | num.words[j]) + rword) /
                  67108864) |
                0),
                (rword = 67108863 & r);
            (out.words[k] = 0 | rword), (carry = 0 | ncarry);
          }
          return (
            0 !== carry ? (out.words[k] = 0 | carry) : out.length--,
            out._strip()
          );
        }
        (BN.prototype.toArrayLike = function toArrayLike(
          ArrayType,
          endian,
          length
        ) {
          this._strip();
          var byteLength = this.byteLength(),
            length = length || Math.max(1, byteLength),
            ArrayType =
              (assert(
                byteLength <= length,
                "byte array longer than desired length"
              ),
              assert(0 < length, "Requested array length <= 0"),
              allocate(ArrayType, length));
          return (
            this["_toArrayLike" + ("le" === endian ? "LE" : "BE")](
              ArrayType,
              byteLength
            ),
            ArrayType
          );
        }),
          (BN.prototype._toArrayLikeLE = function _toArrayLikeLE(
            res,
            byteLength
          ) {
            for (
              var position = 0, carry = 0, i = 0, shift = 0;
              i < this.length;
              i++
            ) {
              var word = (this.words[i] << shift) | carry;
              (res[position++] = 255 & word),
                position < res.length && (res[position++] = (word >> 8) & 255),
                position < res.length && (res[position++] = (word >> 16) & 255),
                6 === shift
                  ? (position < res.length &&
                      (res[position++] = (word >> 24) & 255),
                    (shift = carry = 0))
                  : ((carry = word >>> 24), (shift += 2));
            }
            if (position < res.length)
              for (res[position++] = carry; position < res.length; )
                res[position++] = 0;
          }),
          (BN.prototype._toArrayLikeBE = function _toArrayLikeBE(
            res,
            byteLength
          ) {
            for (
              var position = res.length - 1, carry = 0, i = 0, shift = 0;
              i < this.length;
              i++
            ) {
              var word = (this.words[i] << shift) | carry;
              (res[position--] = 255 & word),
                0 <= position && (res[position--] = (word >> 8) & 255),
                0 <= position && (res[position--] = (word >> 16) & 255),
                6 === shift
                  ? (0 <= position && (res[position--] = (word >> 24) & 255),
                    (shift = carry = 0))
                  : ((carry = word >>> 24), (shift += 2));
            }
            if (0 <= position)
              for (res[position--] = carry; 0 <= position; )
                res[position--] = 0;
          }),
          Math.clz32
            ? (BN.prototype._countBits = function _countBits(w) {
                return 32 - Math.clz32(w);
              })
            : (BN.prototype._countBits = function _countBits(w) {
                var r = 0;
                return (
                  4096 <= w && ((r += 13), (w >>>= 13)),
                  64 <= w && ((r += 7), (w >>>= 7)),
                  8 <= w && ((r += 4), (w >>>= 4)),
                  2 <= w && ((r += 2), (w >>>= 2)),
                  r + w
                );
              }),
          (BN.prototype._zeroBits = function _zeroBits(w) {
            var r;
            return 0 === w
              ? 26
              : ((r = 0) == (8191 & (w = w)) && ((r += 13), (w >>>= 13)),
                0 == (127 & w) && ((r += 7), (w >>>= 7)),
                0 == (15 & w) && ((r += 4), (w >>>= 4)),
                0 == (3 & w) && ((r += 2), (w >>>= 2)),
                0 == (1 & w) && r++,
                r);
          }),
          (BN.prototype.bitLength = function bitLength() {
            var w = this.words[this.length - 1],
              w = this._countBits(w);
            return 26 * (this.length - 1) + w;
          }),
          (BN.prototype.zeroBits = function zeroBits() {
            if (this.isZero()) return 0;
            for (var r = 0, i = 0; i < this.length; i++) {
              var b = this._zeroBits(this.words[i]);
              if (((r += b), 26 !== b)) break;
            }
            return r;
          }),
          (BN.prototype.byteLength = function byteLength() {
            return Math.ceil(this.bitLength() / 8);
          }),
          (BN.prototype.toTwos = function toTwos(width) {
            return 0 !== this.negative
              ? this.abs().inotn(width).iaddn(1)
              : this.clone();
          }),
          (BN.prototype.fromTwos = function fromTwos(width) {
            return this.testn(width - 1)
              ? this.notn(width).iaddn(1).ineg()
              : this.clone();
          }),
          (BN.prototype.isNeg = function isNeg() {
            return 0 !== this.negative;
          }),
          (BN.prototype.neg = function neg() {
            return this.clone().ineg();
          }),
          (BN.prototype.ineg = function ineg() {
            return this.isZero() || (this.negative ^= 1), this;
          }),
          (BN.prototype.iuor = function iuor(num) {
            for (; this.length < num.length; ) this.words[this.length++] = 0;
            for (var i = 0; i < num.length; i++)
              this.words[i] = this.words[i] | num.words[i];
            return this._strip();
          }),
          (BN.prototype.ior = function ior(num) {
            return assert(0 == (this.negative | num.negative)), this.iuor(num);
          }),
          (BN.prototype.or = function or(num) {
            return this.length > num.length
              ? this.clone().ior(num)
              : num.clone().ior(this);
          }),
          (BN.prototype.uor = function uor(num) {
            return this.length > num.length
              ? this.clone().iuor(num)
              : num.clone().iuor(this);
          }),
          (BN.prototype.iuand = function iuand(num) {
            for (
              var b = this.length > num.length ? num : this, i = 0;
              i < b.length;
              i++
            )
              this.words[i] = this.words[i] & num.words[i];
            return (this.length = b.length), this._strip();
          }),
          (BN.prototype.iand = function iand(num) {
            return assert(0 == (this.negative | num.negative)), this.iuand(num);
          }),
          (BN.prototype.and = function and(num) {
            return this.length > num.length
              ? this.clone().iand(num)
              : num.clone().iand(this);
          }),
          (BN.prototype.uand = function uand(num) {
            return this.length > num.length
              ? this.clone().iuand(num)
              : num.clone().iuand(this);
          }),
          (BN.prototype.iuxor = function iuxor(num) {
            for (
              var a,
                b =
                  this.length > num.length
                    ? ((a = this), num)
                    : ((a = num), this),
                i = 0;
              i < b.length;
              i++
            )
              this.words[i] = a.words[i] ^ b.words[i];
            if (this !== a)
              for (; i < a.length; i++) this.words[i] = a.words[i];
            return (this.length = a.length), this._strip();
          }),
          (BN.prototype.ixor = function ixor(num) {
            return assert(0 == (this.negative | num.negative)), this.iuxor(num);
          }),
          (BN.prototype.xor = function xor(num) {
            return this.length > num.length
              ? this.clone().ixor(num)
              : num.clone().ixor(this);
          }),
          (BN.prototype.uxor = function uxor(num) {
            return this.length > num.length
              ? this.clone().iuxor(num)
              : num.clone().iuxor(this);
          }),
          (BN.prototype.inotn = function inotn(width) {
            assert("number" == typeof width && 0 <= width);
            var bytesNeeded = 0 | Math.ceil(width / 26),
              width = width % 26;
            this._expand(bytesNeeded), 0 < width && bytesNeeded--;
            for (var i = 0; i < bytesNeeded; i++)
              this.words[i] = 67108863 & ~this.words[i];
            return (
              0 < width &&
                (this.words[i] = ~this.words[i] & (67108863 >> (26 - width))),
              this._strip()
            );
          }),
          (BN.prototype.notn = function notn(width) {
            return this.clone().inotn(width);
          }),
          (BN.prototype.setn = function setn(bit, val) {
            assert("number" == typeof bit && 0 <= bit);
            var off = (bit / 26) | 0,
              bit = bit % 26;
            return (
              this._expand(1 + off),
              (this.words[off] = val
                ? this.words[off] | (1 << bit)
                : this.words[off] & ~(1 << bit)),
              this._strip()
            );
          }),
          (BN.prototype.iadd = function iadd(num) {
            var r, a;
            if (0 !== this.negative && 0 === num.negative)
              return (
                (this.negative = 0),
                (r = this.isub(num)),
                (this.negative ^= 1),
                this._normSign()
              );
            if (0 === this.negative && 0 !== num.negative)
              return (
                (num.negative = 0),
                (r = this.isub(num)),
                (num.negative = 1),
                r._normSign()
              );
            for (
              var b =
                  this.length > num.length
                    ? ((a = this), num)
                    : ((a = num), this),
                carry = 0,
                i = 0;
              i < b.length;
              i++
            )
              (r = (0 | a.words[i]) + (0 | b.words[i]) + carry),
                (this.words[i] = 67108863 & r),
                (carry = r >>> 26);
            for (; 0 !== carry && i < a.length; i++)
              (r = (0 | a.words[i]) + carry),
                (this.words[i] = 67108863 & r),
                (carry = r >>> 26);
            if (((this.length = a.length), 0 !== carry))
              (this.words[this.length] = carry), this.length++;
            else if (a !== this)
              for (; i < a.length; i++) this.words[i] = a.words[i];
            return this;
          }),
          (BN.prototype.add = function add(num) {
            var res;
            return 0 !== num.negative && 0 === this.negative
              ? ((num.negative = 0),
                (res = this.sub(num)),
                (num.negative ^= 1),
                res)
              : 0 === num.negative && 0 !== this.negative
              ? ((this.negative = 0),
                (res = num.sub(this)),
                (this.negative = 1),
                res)
              : this.length > num.length
              ? this.clone().iadd(num)
              : num.clone().iadd(this);
          }),
          (BN.prototype.isub = function isub(num) {
            var r;
            if (0 !== num.negative)
              return (
                (num.negative = 0),
                (r = this.iadd(num)),
                (num.negative = 1),
                r._normSign()
              );
            if (0 !== this.negative)
              return (
                (this.negative = 0),
                this.iadd(num),
                (this.negative = 1),
                this._normSign()
              );
            var a,
              cmp = this.cmp(num);
            if (0 === cmp)
              return (
                (this.negative = 0),
                (this.length = 1),
                (this.words[0] = 0),
                this
              );
            for (
              var b = 0 < cmp ? ((a = this), num) : ((a = num), this),
                carry = 0,
                i = 0;
              i < b.length;
              i++
            )
              (carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26),
                (this.words[i] = 67108863 & r);
            for (; 0 !== carry && i < a.length; i++)
              (carry = (r = (0 | a.words[i]) + carry) >> 26),
                (this.words[i] = 67108863 & r);
            if (0 === carry && i < a.length && a !== this)
              for (; i < a.length; i++) this.words[i] = a.words[i];
            return (
              (this.length = Math.max(this.length, i)),
              a !== this && (this.negative = 1),
              this._strip()
            );
          }),
          (BN.prototype.sub = function sub(num) {
            return this.clone().isub(num);
          });
        var comb10MulTo = function comb10MulTo(self, num, out) {
          var lo,
            a = self.words,
            b = num.words,
            o = out.words,
            a0 = 0 | a[0],
            al0 = 8191 & a0,
            a0 = a0 >>> 13,
            a1 = 0 | a[1],
            al1 = 8191 & a1,
            a1 = a1 >>> 13,
            a2 = 0 | a[2],
            al2 = 8191 & a2,
            a2 = a2 >>> 13,
            a3 = 0 | a[3],
            al3 = 8191 & a3,
            a3 = a3 >>> 13,
            a4 = 0 | a[4],
            al4 = 8191 & a4,
            a4 = a4 >>> 13,
            a5 = 0 | a[5],
            al5 = 8191 & a5,
            a5 = a5 >>> 13,
            a6 = 0 | a[6],
            al6 = 8191 & a6,
            a6 = a6 >>> 13,
            a7 = 0 | a[7],
            al7 = 8191 & a7,
            a7 = a7 >>> 13,
            a8 = 0 | a[8],
            al8 = 8191 & a8,
            a8 = a8 >>> 13,
            a = 0 | a[9],
            al9 = 8191 & a,
            a = a >>> 13,
            b0 = 0 | b[0],
            bl0 = 8191 & b0,
            b0 = b0 >>> 13,
            b1 = 0 | b[1],
            bl1 = 8191 & b1,
            b1 = b1 >>> 13,
            b2 = 0 | b[2],
            bl2 = 8191 & b2,
            b2 = b2 >>> 13,
            b3 = 0 | b[3],
            bl3 = 8191 & b3,
            b3 = b3 >>> 13,
            b4 = 0 | b[4],
            bl4 = 8191 & b4,
            b4 = b4 >>> 13,
            b5 = 0 | b[5],
            bl5 = 8191 & b5,
            b5 = b5 >>> 13,
            b6 = 0 | b[6],
            bl6 = 8191 & b6,
            b6 = b6 >>> 13,
            b7 = 0 | b[7],
            bl7 = 8191 & b7,
            b7 = b7 >>> 13,
            b8 = 0 | b[8],
            bl8 = 8191 & b8,
            b8 = b8 >>> 13,
            b = 0 | b[9],
            bl9 = 8191 & b,
            b = b >>> 13,
            num =
              ((out.negative = self.negative ^ num.negative),
              (out.length = 19),
              (((0 + Math.imul(al0, bl0)) | 0) +
                ((8191 &
                  (self = (Math.imul(al0, b0) + Math.imul(a0, bl0)) | 0)) <<
                  13)) |
                0),
            c = (((Math.imul(a0, b0) + (self >>> 13)) | 0) + (num >>> 26)) | 0;
          (num &= 67108863),
            (lo = Math.imul(al1, bl0)),
            (self = (Math.imul(al1, b0) + Math.imul(a1, bl0)) | 0),
            (hi = Math.imul(a1, b0));
          var hi,
            w1 =
              (((c + ((lo + Math.imul(al0, bl1)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b1)) | 0) + Math.imul(a0, bl1)) |
                    0)) <<
                  13)) |
              0,
            w2 =
              ((c =
                (((((hi + Math.imul(a0, b1)) | 0) + (self >>> 13)) | 0) +
                  (w1 >>> 26)) |
                0),
              (w1 &= 67108863),
              (lo = Math.imul(al2, bl0)),
              (self = (Math.imul(al2, b0) + Math.imul(a2, bl0)) | 0),
              (hi = Math.imul(a2, b0)),
              (lo = (lo + Math.imul(al1, bl1)) | 0),
              (self =
                (((self + Math.imul(al1, b1)) | 0) + Math.imul(a1, bl1)) | 0),
              (hi = (hi + Math.imul(a1, b1)) | 0),
              (((c + ((lo + Math.imul(al0, bl2)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b2)) | 0) + Math.imul(a0, bl2)) |
                    0)) <<
                  13)) |
                0),
            w3 =
              ((c =
                (((((hi + Math.imul(a0, b2)) | 0) + (self >>> 13)) | 0) +
                  (w2 >>> 26)) |
                0),
              (w2 &= 67108863),
              (lo = Math.imul(al3, bl0)),
              (self = (Math.imul(al3, b0) + Math.imul(a3, bl0)) | 0),
              (hi = Math.imul(a3, b0)),
              (lo = (lo + Math.imul(al2, bl1)) | 0),
              (self =
                (((self + Math.imul(al2, b1)) | 0) + Math.imul(a2, bl1)) | 0),
              (hi = (hi + Math.imul(a2, b1)) | 0),
              (lo = (lo + Math.imul(al1, bl2)) | 0),
              (self =
                (((self + Math.imul(al1, b2)) | 0) + Math.imul(a1, bl2)) | 0),
              (hi = (hi + Math.imul(a1, b2)) | 0),
              (((c + ((lo + Math.imul(al0, bl3)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b3)) | 0) + Math.imul(a0, bl3)) |
                    0)) <<
                  13)) |
                0),
            w4 =
              ((c =
                (((((hi + Math.imul(a0, b3)) | 0) + (self >>> 13)) | 0) +
                  (w3 >>> 26)) |
                0),
              (w3 &= 67108863),
              (lo = Math.imul(al4, bl0)),
              (self = (Math.imul(al4, b0) + Math.imul(a4, bl0)) | 0),
              (hi = Math.imul(a4, b0)),
              (lo = (lo + Math.imul(al3, bl1)) | 0),
              (self =
                (((self + Math.imul(al3, b1)) | 0) + Math.imul(a3, bl1)) | 0),
              (hi = (hi + Math.imul(a3, b1)) | 0),
              (lo = (lo + Math.imul(al2, bl2)) | 0),
              (self =
                (((self + Math.imul(al2, b2)) | 0) + Math.imul(a2, bl2)) | 0),
              (hi = (hi + Math.imul(a2, b2)) | 0),
              (lo = (lo + Math.imul(al1, bl3)) | 0),
              (self =
                (((self + Math.imul(al1, b3)) | 0) + Math.imul(a1, bl3)) | 0),
              (hi = (hi + Math.imul(a1, b3)) | 0),
              (((c + ((lo + Math.imul(al0, bl4)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b4)) | 0) + Math.imul(a0, bl4)) |
                    0)) <<
                  13)) |
                0),
            w5 =
              ((c =
                (((((hi + Math.imul(a0, b4)) | 0) + (self >>> 13)) | 0) +
                  (w4 >>> 26)) |
                0),
              (w4 &= 67108863),
              (lo = Math.imul(al5, bl0)),
              (self = (Math.imul(al5, b0) + Math.imul(a5, bl0)) | 0),
              (hi = Math.imul(a5, b0)),
              (lo = (lo + Math.imul(al4, bl1)) | 0),
              (self =
                (((self + Math.imul(al4, b1)) | 0) + Math.imul(a4, bl1)) | 0),
              (hi = (hi + Math.imul(a4, b1)) | 0),
              (lo = (lo + Math.imul(al3, bl2)) | 0),
              (self =
                (((self + Math.imul(al3, b2)) | 0) + Math.imul(a3, bl2)) | 0),
              (hi = (hi + Math.imul(a3, b2)) | 0),
              (lo = (lo + Math.imul(al2, bl3)) | 0),
              (self =
                (((self + Math.imul(al2, b3)) | 0) + Math.imul(a2, bl3)) | 0),
              (hi = (hi + Math.imul(a2, b3)) | 0),
              (lo = (lo + Math.imul(al1, bl4)) | 0),
              (self =
                (((self + Math.imul(al1, b4)) | 0) + Math.imul(a1, bl4)) | 0),
              (hi = (hi + Math.imul(a1, b4)) | 0),
              (((c + ((lo + Math.imul(al0, bl5)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b5)) | 0) + Math.imul(a0, bl5)) |
                    0)) <<
                  13)) |
                0),
            w6 =
              ((c =
                (((((hi + Math.imul(a0, b5)) | 0) + (self >>> 13)) | 0) +
                  (w5 >>> 26)) |
                0),
              (w5 &= 67108863),
              (lo = Math.imul(al6, bl0)),
              (self = (Math.imul(al6, b0) + Math.imul(a6, bl0)) | 0),
              (hi = Math.imul(a6, b0)),
              (lo = (lo + Math.imul(al5, bl1)) | 0),
              (self =
                (((self + Math.imul(al5, b1)) | 0) + Math.imul(a5, bl1)) | 0),
              (hi = (hi + Math.imul(a5, b1)) | 0),
              (lo = (lo + Math.imul(al4, bl2)) | 0),
              (self =
                (((self + Math.imul(al4, b2)) | 0) + Math.imul(a4, bl2)) | 0),
              (hi = (hi + Math.imul(a4, b2)) | 0),
              (lo = (lo + Math.imul(al3, bl3)) | 0),
              (self =
                (((self + Math.imul(al3, b3)) | 0) + Math.imul(a3, bl3)) | 0),
              (hi = (hi + Math.imul(a3, b3)) | 0),
              (lo = (lo + Math.imul(al2, bl4)) | 0),
              (self =
                (((self + Math.imul(al2, b4)) | 0) + Math.imul(a2, bl4)) | 0),
              (hi = (hi + Math.imul(a2, b4)) | 0),
              (lo = (lo + Math.imul(al1, bl5)) | 0),
              (self =
                (((self + Math.imul(al1, b5)) | 0) + Math.imul(a1, bl5)) | 0),
              (hi = (hi + Math.imul(a1, b5)) | 0),
              (((c + ((lo + Math.imul(al0, bl6)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b6)) | 0) + Math.imul(a0, bl6)) |
                    0)) <<
                  13)) |
                0),
            w7 =
              ((c =
                (((((hi + Math.imul(a0, b6)) | 0) + (self >>> 13)) | 0) +
                  (w6 >>> 26)) |
                0),
              (w6 &= 67108863),
              (lo = Math.imul(al7, bl0)),
              (self = (Math.imul(al7, b0) + Math.imul(a7, bl0)) | 0),
              (hi = Math.imul(a7, b0)),
              (lo = (lo + Math.imul(al6, bl1)) | 0),
              (self =
                (((self + Math.imul(al6, b1)) | 0) + Math.imul(a6, bl1)) | 0),
              (hi = (hi + Math.imul(a6, b1)) | 0),
              (lo = (lo + Math.imul(al5, bl2)) | 0),
              (self =
                (((self + Math.imul(al5, b2)) | 0) + Math.imul(a5, bl2)) | 0),
              (hi = (hi + Math.imul(a5, b2)) | 0),
              (lo = (lo + Math.imul(al4, bl3)) | 0),
              (self =
                (((self + Math.imul(al4, b3)) | 0) + Math.imul(a4, bl3)) | 0),
              (hi = (hi + Math.imul(a4, b3)) | 0),
              (lo = (lo + Math.imul(al3, bl4)) | 0),
              (self =
                (((self + Math.imul(al3, b4)) | 0) + Math.imul(a3, bl4)) | 0),
              (hi = (hi + Math.imul(a3, b4)) | 0),
              (lo = (lo + Math.imul(al2, bl5)) | 0),
              (self =
                (((self + Math.imul(al2, b5)) | 0) + Math.imul(a2, bl5)) | 0),
              (hi = (hi + Math.imul(a2, b5)) | 0),
              (lo = (lo + Math.imul(al1, bl6)) | 0),
              (self =
                (((self + Math.imul(al1, b6)) | 0) + Math.imul(a1, bl6)) | 0),
              (hi = (hi + Math.imul(a1, b6)) | 0),
              (((c + ((lo + Math.imul(al0, bl7)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b7)) | 0) + Math.imul(a0, bl7)) |
                    0)) <<
                  13)) |
                0),
            w8 =
              ((c =
                (((((hi + Math.imul(a0, b7)) | 0) + (self >>> 13)) | 0) +
                  (w7 >>> 26)) |
                0),
              (w7 &= 67108863),
              (lo = Math.imul(al8, bl0)),
              (self = (Math.imul(al8, b0) + Math.imul(a8, bl0)) | 0),
              (hi = Math.imul(a8, b0)),
              (lo = (lo + Math.imul(al7, bl1)) | 0),
              (self =
                (((self + Math.imul(al7, b1)) | 0) + Math.imul(a7, bl1)) | 0),
              (hi = (hi + Math.imul(a7, b1)) | 0),
              (lo = (lo + Math.imul(al6, bl2)) | 0),
              (self =
                (((self + Math.imul(al6, b2)) | 0) + Math.imul(a6, bl2)) | 0),
              (hi = (hi + Math.imul(a6, b2)) | 0),
              (lo = (lo + Math.imul(al5, bl3)) | 0),
              (self =
                (((self + Math.imul(al5, b3)) | 0) + Math.imul(a5, bl3)) | 0),
              (hi = (hi + Math.imul(a5, b3)) | 0),
              (lo = (lo + Math.imul(al4, bl4)) | 0),
              (self =
                (((self + Math.imul(al4, b4)) | 0) + Math.imul(a4, bl4)) | 0),
              (hi = (hi + Math.imul(a4, b4)) | 0),
              (lo = (lo + Math.imul(al3, bl5)) | 0),
              (self =
                (((self + Math.imul(al3, b5)) | 0) + Math.imul(a3, bl5)) | 0),
              (hi = (hi + Math.imul(a3, b5)) | 0),
              (lo = (lo + Math.imul(al2, bl6)) | 0),
              (self =
                (((self + Math.imul(al2, b6)) | 0) + Math.imul(a2, bl6)) | 0),
              (hi = (hi + Math.imul(a2, b6)) | 0),
              (lo = (lo + Math.imul(al1, bl7)) | 0),
              (self =
                (((self + Math.imul(al1, b7)) | 0) + Math.imul(a1, bl7)) | 0),
              (hi = (hi + Math.imul(a1, b7)) | 0),
              (((c + ((lo + Math.imul(al0, bl8)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b8)) | 0) + Math.imul(a0, bl8)) |
                    0)) <<
                  13)) |
                0),
            bl0 =
              ((c =
                (((((hi + Math.imul(a0, b8)) | 0) + (self >>> 13)) | 0) +
                  (w8 >>> 26)) |
                0),
              (w8 &= 67108863),
              (lo = Math.imul(al9, bl0)),
              (self = (Math.imul(al9, b0) + Math.imul(a, bl0)) | 0),
              (hi = Math.imul(a, b0)),
              (lo = (lo + Math.imul(al8, bl1)) | 0),
              (self =
                (((self + Math.imul(al8, b1)) | 0) + Math.imul(a8, bl1)) | 0),
              (hi = (hi + Math.imul(a8, b1)) | 0),
              (lo = (lo + Math.imul(al7, bl2)) | 0),
              (self =
                (((self + Math.imul(al7, b2)) | 0) + Math.imul(a7, bl2)) | 0),
              (hi = (hi + Math.imul(a7, b2)) | 0),
              (lo = (lo + Math.imul(al6, bl3)) | 0),
              (self =
                (((self + Math.imul(al6, b3)) | 0) + Math.imul(a6, bl3)) | 0),
              (hi = (hi + Math.imul(a6, b3)) | 0),
              (lo = (lo + Math.imul(al5, bl4)) | 0),
              (self =
                (((self + Math.imul(al5, b4)) | 0) + Math.imul(a5, bl4)) | 0),
              (hi = (hi + Math.imul(a5, b4)) | 0),
              (lo = (lo + Math.imul(al4, bl5)) | 0),
              (self =
                (((self + Math.imul(al4, b5)) | 0) + Math.imul(a4, bl5)) | 0),
              (hi = (hi + Math.imul(a4, b5)) | 0),
              (lo = (lo + Math.imul(al3, bl6)) | 0),
              (self =
                (((self + Math.imul(al3, b6)) | 0) + Math.imul(a3, bl6)) | 0),
              (hi = (hi + Math.imul(a3, b6)) | 0),
              (lo = (lo + Math.imul(al2, bl7)) | 0),
              (self =
                (((self + Math.imul(al2, b7)) | 0) + Math.imul(a2, bl7)) | 0),
              (hi = (hi + Math.imul(a2, b7)) | 0),
              (lo = (lo + Math.imul(al1, bl8)) | 0),
              (self =
                (((self + Math.imul(al1, b8)) | 0) + Math.imul(a1, bl8)) | 0),
              (hi = (hi + Math.imul(a1, b8)) | 0),
              (((c + ((lo + Math.imul(al0, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al0, b)) | 0) + Math.imul(a0, bl9)) |
                    0)) <<
                  13)) |
                0),
            b0 =
              ((c =
                (((((hi + Math.imul(a0, b)) | 0) + (self >>> 13)) | 0) +
                  (bl0 >>> 26)) |
                0),
              (bl0 &= 67108863),
              (lo = Math.imul(al9, bl1)),
              (self = (Math.imul(al9, b1) + Math.imul(a, bl1)) | 0),
              (hi = Math.imul(a, b1)),
              (lo = (lo + Math.imul(al8, bl2)) | 0),
              (self =
                (((self + Math.imul(al8, b2)) | 0) + Math.imul(a8, bl2)) | 0),
              (hi = (hi + Math.imul(a8, b2)) | 0),
              (lo = (lo + Math.imul(al7, bl3)) | 0),
              (self =
                (((self + Math.imul(al7, b3)) | 0) + Math.imul(a7, bl3)) | 0),
              (hi = (hi + Math.imul(a7, b3)) | 0),
              (lo = (lo + Math.imul(al6, bl4)) | 0),
              (self =
                (((self + Math.imul(al6, b4)) | 0) + Math.imul(a6, bl4)) | 0),
              (hi = (hi + Math.imul(a6, b4)) | 0),
              (lo = (lo + Math.imul(al5, bl5)) | 0),
              (self =
                (((self + Math.imul(al5, b5)) | 0) + Math.imul(a5, bl5)) | 0),
              (hi = (hi + Math.imul(a5, b5)) | 0),
              (lo = (lo + Math.imul(al4, bl6)) | 0),
              (self =
                (((self + Math.imul(al4, b6)) | 0) + Math.imul(a4, bl6)) | 0),
              (hi = (hi + Math.imul(a4, b6)) | 0),
              (lo = (lo + Math.imul(al3, bl7)) | 0),
              (self =
                (((self + Math.imul(al3, b7)) | 0) + Math.imul(a3, bl7)) | 0),
              (hi = (hi + Math.imul(a3, b7)) | 0),
              (lo = (lo + Math.imul(al2, bl8)) | 0),
              (self =
                (((self + Math.imul(al2, b8)) | 0) + Math.imul(a2, bl8)) | 0),
              (hi = (hi + Math.imul(a2, b8)) | 0),
              (((c + ((lo + Math.imul(al1, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al1, b)) | 0) + Math.imul(a1, bl9)) |
                    0)) <<
                  13)) |
                0),
            al0 =
              ((c =
                (((((hi + Math.imul(a1, b)) | 0) + (self >>> 13)) | 0) +
                  (b0 >>> 26)) |
                0),
              (b0 &= 67108863),
              (lo = Math.imul(al9, bl2)),
              (self = (Math.imul(al9, b2) + Math.imul(a, bl2)) | 0),
              (hi = Math.imul(a, b2)),
              (lo = (lo + Math.imul(al8, bl3)) | 0),
              (self =
                (((self + Math.imul(al8, b3)) | 0) + Math.imul(a8, bl3)) | 0),
              (hi = (hi + Math.imul(a8, b3)) | 0),
              (lo = (lo + Math.imul(al7, bl4)) | 0),
              (self =
                (((self + Math.imul(al7, b4)) | 0) + Math.imul(a7, bl4)) | 0),
              (hi = (hi + Math.imul(a7, b4)) | 0),
              (lo = (lo + Math.imul(al6, bl5)) | 0),
              (self =
                (((self + Math.imul(al6, b5)) | 0) + Math.imul(a6, bl5)) | 0),
              (hi = (hi + Math.imul(a6, b5)) | 0),
              (lo = (lo + Math.imul(al5, bl6)) | 0),
              (self =
                (((self + Math.imul(al5, b6)) | 0) + Math.imul(a5, bl6)) | 0),
              (hi = (hi + Math.imul(a5, b6)) | 0),
              (lo = (lo + Math.imul(al4, bl7)) | 0),
              (self =
                (((self + Math.imul(al4, b7)) | 0) + Math.imul(a4, bl7)) | 0),
              (hi = (hi + Math.imul(a4, b7)) | 0),
              (lo = (lo + Math.imul(al3, bl8)) | 0),
              (self =
                (((self + Math.imul(al3, b8)) | 0) + Math.imul(a3, bl8)) | 0),
              (hi = (hi + Math.imul(a3, b8)) | 0),
              (((c + ((lo + Math.imul(al2, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al2, b)) | 0) + Math.imul(a2, bl9)) |
                    0)) <<
                  13)) |
                0),
            a0 =
              ((c =
                (((((hi + Math.imul(a2, b)) | 0) + (self >>> 13)) | 0) +
                  (al0 >>> 26)) |
                0),
              (al0 &= 67108863),
              (lo = Math.imul(al9, bl3)),
              (self = (Math.imul(al9, b3) + Math.imul(a, bl3)) | 0),
              (hi = Math.imul(a, b3)),
              (lo = (lo + Math.imul(al8, bl4)) | 0),
              (self =
                (((self + Math.imul(al8, b4)) | 0) + Math.imul(a8, bl4)) | 0),
              (hi = (hi + Math.imul(a8, b4)) | 0),
              (lo = (lo + Math.imul(al7, bl5)) | 0),
              (self =
                (((self + Math.imul(al7, b5)) | 0) + Math.imul(a7, bl5)) | 0),
              (hi = (hi + Math.imul(a7, b5)) | 0),
              (lo = (lo + Math.imul(al6, bl6)) | 0),
              (self =
                (((self + Math.imul(al6, b6)) | 0) + Math.imul(a6, bl6)) | 0),
              (hi = (hi + Math.imul(a6, b6)) | 0),
              (lo = (lo + Math.imul(al5, bl7)) | 0),
              (self =
                (((self + Math.imul(al5, b7)) | 0) + Math.imul(a5, bl7)) | 0),
              (hi = (hi + Math.imul(a5, b7)) | 0),
              (lo = (lo + Math.imul(al4, bl8)) | 0),
              (self =
                (((self + Math.imul(al4, b8)) | 0) + Math.imul(a4, bl8)) | 0),
              (hi = (hi + Math.imul(a4, b8)) | 0),
              (((c + ((lo + Math.imul(al3, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al3, b)) | 0) + Math.imul(a3, bl9)) |
                    0)) <<
                  13)) |
                0),
            bl1 =
              ((c =
                (((((hi + Math.imul(a3, b)) | 0) + (self >>> 13)) | 0) +
                  (a0 >>> 26)) |
                0),
              (a0 &= 67108863),
              (lo = Math.imul(al9, bl4)),
              (self = (Math.imul(al9, b4) + Math.imul(a, bl4)) | 0),
              (hi = Math.imul(a, b4)),
              (lo = (lo + Math.imul(al8, bl5)) | 0),
              (self =
                (((self + Math.imul(al8, b5)) | 0) + Math.imul(a8, bl5)) | 0),
              (hi = (hi + Math.imul(a8, b5)) | 0),
              (lo = (lo + Math.imul(al7, bl6)) | 0),
              (self =
                (((self + Math.imul(al7, b6)) | 0) + Math.imul(a7, bl6)) | 0),
              (hi = (hi + Math.imul(a7, b6)) | 0),
              (lo = (lo + Math.imul(al6, bl7)) | 0),
              (self =
                (((self + Math.imul(al6, b7)) | 0) + Math.imul(a6, bl7)) | 0),
              (hi = (hi + Math.imul(a6, b7)) | 0),
              (lo = (lo + Math.imul(al5, bl8)) | 0),
              (self =
                (((self + Math.imul(al5, b8)) | 0) + Math.imul(a5, bl8)) | 0),
              (hi = (hi + Math.imul(a5, b8)) | 0),
              (((c + ((lo + Math.imul(al4, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al4, b)) | 0) + Math.imul(a4, bl9)) |
                    0)) <<
                  13)) |
                0),
            b1 =
              ((c =
                (((((hi + Math.imul(a4, b)) | 0) + (self >>> 13)) | 0) +
                  (bl1 >>> 26)) |
                0),
              (bl1 &= 67108863),
              (lo = Math.imul(al9, bl5)),
              (self = (Math.imul(al9, b5) + Math.imul(a, bl5)) | 0),
              (hi = Math.imul(a, b5)),
              (lo = (lo + Math.imul(al8, bl6)) | 0),
              (self =
                (((self + Math.imul(al8, b6)) | 0) + Math.imul(a8, bl6)) | 0),
              (hi = (hi + Math.imul(a8, b6)) | 0),
              (lo = (lo + Math.imul(al7, bl7)) | 0),
              (self =
                (((self + Math.imul(al7, b7)) | 0) + Math.imul(a7, bl7)) | 0),
              (hi = (hi + Math.imul(a7, b7)) | 0),
              (lo = (lo + Math.imul(al6, bl8)) | 0),
              (self =
                (((self + Math.imul(al6, b8)) | 0) + Math.imul(a6, bl8)) | 0),
              (hi = (hi + Math.imul(a6, b8)) | 0),
              (((c + ((lo + Math.imul(al5, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al5, b)) | 0) + Math.imul(a5, bl9)) |
                    0)) <<
                  13)) |
                0),
            al1 =
              ((c =
                (((((hi + Math.imul(a5, b)) | 0) + (self >>> 13)) | 0) +
                  (b1 >>> 26)) |
                0),
              (b1 &= 67108863),
              (lo = Math.imul(al9, bl6)),
              (self = (Math.imul(al9, b6) + Math.imul(a, bl6)) | 0),
              (hi = Math.imul(a, b6)),
              (lo = (lo + Math.imul(al8, bl7)) | 0),
              (self =
                (((self + Math.imul(al8, b7)) | 0) + Math.imul(a8, bl7)) | 0),
              (hi = (hi + Math.imul(a8, b7)) | 0),
              (lo = (lo + Math.imul(al7, bl8)) | 0),
              (self =
                (((self + Math.imul(al7, b8)) | 0) + Math.imul(a7, bl8)) | 0),
              (hi = (hi + Math.imul(a7, b8)) | 0),
              (((c + ((lo + Math.imul(al6, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al6, b)) | 0) + Math.imul(a6, bl9)) |
                    0)) <<
                  13)) |
                0),
            a1 =
              ((c =
                (((((hi + Math.imul(a6, b)) | 0) + (self >>> 13)) | 0) +
                  (al1 >>> 26)) |
                0),
              (al1 &= 67108863),
              (lo = Math.imul(al9, bl7)),
              (self = (Math.imul(al9, b7) + Math.imul(a, bl7)) | 0),
              (hi = Math.imul(a, b7)),
              (lo = (lo + Math.imul(al8, bl8)) | 0),
              (self =
                (((self + Math.imul(al8, b8)) | 0) + Math.imul(a8, bl8)) | 0),
              (hi = (hi + Math.imul(a8, b8)) | 0),
              (((c + ((lo + Math.imul(al7, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al7, b)) | 0) + Math.imul(a7, bl9)) |
                    0)) <<
                  13)) |
                0),
            bl2 =
              ((c =
                (((((hi + Math.imul(a7, b)) | 0) + (self >>> 13)) | 0) +
                  (a1 >>> 26)) |
                0),
              (a1 &= 67108863),
              (lo = Math.imul(al9, bl8)),
              (self = (Math.imul(al9, b8) + Math.imul(a, bl8)) | 0),
              (hi = Math.imul(a, b8)),
              (((c + ((lo + Math.imul(al8, bl9)) | 0)) | 0) +
                ((8191 &
                  (self =
                    (((self + Math.imul(al8, b)) | 0) + Math.imul(a8, bl9)) |
                    0)) <<
                  13)) |
                0),
            b2 =
              ((c =
                (((((hi + Math.imul(a8, b)) | 0) + (self >>> 13)) | 0) +
                  (bl2 >>> 26)) |
                0),
              (bl2 &= 67108863),
              (((c + Math.imul(al9, bl9)) | 0) +
                ((8191 &
                  (self = (Math.imul(al9, b) + Math.imul(a, bl9)) | 0)) <<
                  13)) |
                0);
          return (
            (c = (((Math.imul(a, b) + (self >>> 13)) | 0) + (b2 >>> 26)) | 0),
            (b2 &= 67108863),
            (o[0] = num),
            (o[1] = w1),
            (o[2] = w2),
            (o[3] = w3),
            (o[4] = w4),
            (o[5] = w5),
            (o[6] = w6),
            (o[7] = w7),
            (o[8] = w8),
            (o[9] = bl0),
            (o[10] = b0),
            (o[11] = al0),
            (o[12] = a0),
            (o[13] = bl1),
            (o[14] = b1),
            (o[15] = al1),
            (o[16] = a1),
            (o[17] = bl2),
            (o[18] = b2),
            0 != c && ((o[19] = c), out.length++),
            out
          );
        };
        function bigMulTo(self, num, out) {
          (out.negative = num.negative ^ self.negative),
            (out.length = self.length + num.length);
          for (var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++) {
            for (
              var ncarry = hncarry,
                hncarry = 0,
                rword = 67108863 & carry,
                maxJ = Math.min(k, num.length - 1),
                j = Math.max(0, k - self.length + 1);
              j <= maxJ;
              j++
            ) {
              var lo,
                r = (0 | self.words[k - j]) * (0 | num.words[j]),
                rword = 67108863 & (lo = ((67108863 & r) + rword) | 0);
              (hncarry +=
                (ncarry =
                  ((ncarry = (ncarry + ((r / 67108864) | 0)) | 0) +
                    (lo >>> 26)) |
                  0) >>> 26),
                (ncarry &= 67108863);
            }
            (out.words[k] = rword), (carry = ncarry), (ncarry = hncarry);
          }
          return (
            0 !== carry ? (out.words[k] = carry) : out.length--, out._strip()
          );
        }
        function jumboMulTo(self, num, out) {
          return bigMulTo(self, num, out);
        }
        Math.imul || (comb10MulTo = smallMulTo),
          (BN.prototype.mulTo = function mulTo(num, out) {
            var len = this.length + num.length,
              len = (
                10 === this.length && 10 === num.length
                  ? comb10MulTo
                  : len < 63
                  ? smallMulTo
                  : len < 1024
                  ? bigMulTo
                  : jumboMulTo
              )(this, num, out);
            return len;
          }),
          (BN.prototype.mul = function mul(num) {
            var out = new BN(null);
            return (
              (out.words = new Array(this.length + num.length)),
              this.mulTo(num, out)
            );
          }),
          (BN.prototype.mulf = function mulf(num) {
            var out = new BN(null);
            return (
              (out.words = new Array(this.length + num.length)),
              jumboMulTo(this, num, out)
            );
          }),
          (BN.prototype.imul = function imul(num) {
            return this.clone().mulTo(num, this);
          }),
          (BN.prototype.imuln = function imuln(num) {
            for (
              var isNegNum = num < 0,
                carry =
                  (assert("number" == typeof (num = isNegNum ? -num : num)),
                  assert(num < 67108864),
                  0),
                i = 0;
              i < this.length;
              i++
            ) {
              var w = (0 | this.words[i]) * num,
                lo = (67108863 & w) + (67108863 & carry),
                carry = (carry >>= 26) + ((w / 67108864) | 0) + (lo >>> 26);
              this.words[i] = 67108863 & lo;
            }
            return (
              0 !== carry && ((this.words[i] = carry), this.length++),
              isNegNum ? this.ineg() : this
            );
          }),
          (BN.prototype.muln = function muln(num) {
            return this.clone().imuln(num);
          }),
          (BN.prototype.sqr = function sqr() {
            return this.mul(this);
          }),
          (BN.prototype.isqr = function isqr() {
            return this.imul(this.clone());
          }),
          (BN.prototype.pow = function pow(num) {
            var w = (function toBitArray(num) {
              for (
                var w = new Array(num.bitLength()), bit = 0;
                bit < w.length;
                bit++
              )
                w[bit] = (num.words[(bit / 26) | 0] >>> bit % 26) & 1;
              return w;
            })(num);
            if (0 === w.length) return new BN(1);
            for (
              var res = this, i = 0;
              i < w.length && 0 === w[i];
              i++, res = res.sqr()
            );
            if (++i < w.length)
              for (var q = res.sqr(); i < w.length; i++, q = q.sqr())
                0 !== w[i] && (res = res.mul(q));
            return res;
          }),
          (BN.prototype.iushln = function iushln(bits) {
            assert("number" == typeof bits && 0 <= bits);
            var r = bits % 26,
              s = (bits - r) / 26,
              carryMask = (67108863 >>> (26 - r)) << (26 - r);
            if (0 != r) {
              for (var carry = 0, i = 0; i < this.length; i++) {
                var newCarry = this.words[i] & carryMask,
                  c = ((0 | this.words[i]) - newCarry) << r;
                (this.words[i] = c | carry), (carry = newCarry >>> (26 - r));
              }
              carry && ((this.words[i] = carry), this.length++);
            }
            if (0 != s) {
              for (i = this.length - 1; 0 <= i; i--)
                this.words[i + s] = this.words[i];
              for (i = 0; i < s; i++) this.words[i] = 0;
              this.length += s;
            }
            return this._strip();
          }),
          (BN.prototype.ishln = function ishln(bits) {
            return assert(0 === this.negative), this.iushln(bits);
          }),
          (BN.prototype.iushrn = function iushrn(bits, hint, extended) {
            assert("number" == typeof bits && 0 <= bits),
              (h = hint ? (hint - (hint % 26)) / 26 : 0);
            var h,
              r = bits % 26,
              s = Math.min((bits - r) / 26, this.length),
              mask = 67108863 ^ ((67108863 >>> r) << r),
              maskedWords = extended;
            if (((h -= s), (h = Math.max(0, h)), maskedWords)) {
              for (var i = 0; i < s; i++) maskedWords.words[i] = this.words[i];
              maskedWords.length = s;
            }
            if (0 !== s)
              if (this.length > s)
                for (this.length -= s, i = 0; i < this.length; i++)
                  this.words[i] = this.words[i + s];
              else (this.words[0] = 0), (this.length = 1);
            for (
              var carry = 0, i = this.length - 1;
              0 <= i && (0 !== carry || h <= i);
              i--
            ) {
              var word = 0 | this.words[i];
              (this.words[i] = (carry << (26 - r)) | (word >>> r)),
                (carry = word & mask);
            }
            return (
              maskedWords &&
                0 !== carry &&
                (maskedWords.words[maskedWords.length++] = carry),
              0 === this.length && ((this.words[0] = 0), (this.length = 1)),
              this._strip()
            );
          }),
          (BN.prototype.ishrn = function ishrn(bits, hint, extended) {
            return (
              assert(0 === this.negative), this.iushrn(bits, hint, extended)
            );
          }),
          (BN.prototype.shln = function shln(bits) {
            return this.clone().ishln(bits);
          }),
          (BN.prototype.ushln = function ushln(bits) {
            return this.clone().iushln(bits);
          }),
          (BN.prototype.shrn = function shrn(bits) {
            return this.clone().ishrn(bits);
          }),
          (BN.prototype.ushrn = function ushrn(bits) {
            return this.clone().iushrn(bits);
          }),
          (BN.prototype.testn = function testn(bit) {
            assert("number" == typeof bit && 0 <= bit);
            var r = bit % 26,
              bit = (bit - r) / 26;
            return !(this.length <= bit || !(this.words[bit] & (1 << r)));
          }),
          (BN.prototype.imaskn = function imaskn(bits) {
            assert("number" == typeof bits && 0 <= bits);
            var r = bits % 26,
              bits = (bits - r) / 26;
            return (
              assert(
                0 === this.negative,
                "imaskn works only with positive numbers"
              ),
              this.length <= bits
                ? this
                : (0 != r && bits++,
                  (this.length = Math.min(bits, this.length)),
                  0 != r &&
                    (this.words[this.length - 1] &=
                      67108863 ^ ((67108863 >>> r) << r)),
                  this._strip())
            );
          }),
          (BN.prototype.maskn = function maskn(bits) {
            return this.clone().imaskn(bits);
          }),
          (BN.prototype.iaddn = function iaddn(num) {
            return (
              assert("number" == typeof num),
              assert(num < 67108864),
              num < 0
                ? this.isubn(-num)
                : 0 !== this.negative
                ? (1 === this.length && (0 | this.words[0]) <= num
                    ? ((this.words[0] = num - (0 | this.words[0])),
                      (this.negative = 0))
                    : ((this.negative = 0),
                      this.isubn(num),
                      (this.negative = 1)),
                  this)
                : this._iaddn(num)
            );
          }),
          (BN.prototype._iaddn = function _iaddn(num) {
            this.words[0] += num;
            for (var i = 0; i < this.length && 67108864 <= this.words[i]; i++)
              (this.words[i] -= 67108864),
                i === this.length - 1
                  ? (this.words[i + 1] = 1)
                  : this.words[i + 1]++;
            return (this.length = Math.max(this.length, i + 1)), this;
          }),
          (BN.prototype.isubn = function isubn(num) {
            if (
              (assert("number" == typeof num), assert(num < 67108864), num < 0)
            )
              return this.iaddn(-num);
            if (0 !== this.negative)
              return (
                (this.negative = 0), this.iaddn(num), (this.negative = 1), this
              );
            if (
              ((this.words[0] -= num), 1 === this.length && this.words[0] < 0)
            )
              (this.words[0] = -this.words[0]), (this.negative = 1);
            else
              for (var i = 0; i < this.length && this.words[i] < 0; i++)
                (this.words[i] += 67108864), --this.words[i + 1];
            return this._strip();
          }),
          (BN.prototype.addn = function addn(num) {
            return this.clone().iaddn(num);
          }),
          (BN.prototype.subn = function subn(num) {
            return this.clone().isubn(num);
          }),
          (BN.prototype.iabs = function iabs() {
            return (this.negative = 0), this;
          }),
          (BN.prototype.abs = function abs() {
            return this.clone().iabs();
          }),
          (BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
            for (
              var len = num.length + shift,
                carry = (this._expand(len), 0),
                i = 0;
              i < num.length;
              i++
            ) {
              var w = (0 | this.words[i + shift]) + carry,
                right = (0 | num.words[i]) * mul,
                carry =
                  ((w -= 67108863 & right) >> 26) - ((right / 67108864) | 0);
              this.words[i + shift] = 67108863 & w;
            }
            for (; i < this.length - shift; i++)
              (carry = (w = (0 | this.words[i + shift]) + carry) >> 26),
                (this.words[i + shift] = 67108863 & w);
            if (0 !== carry) {
              for (assert(-1 === carry), i = carry = 0; i < this.length; i++)
                (carry = (w = -(0 | this.words[i]) + carry) >> 26),
                  (this.words[i] = 67108863 & w);
              this.negative = 1;
            }
            return this._strip();
          }),
          (BN.prototype._wordDiv = function _wordDiv(num, mode) {
            this.length, num.length;
            var q,
              a = this.clone(),
              b = num,
              bhi = 0 | b.words[b.length - 1],
              m =
                (0 != (num = 26 - this._countBits(bhi)) &&
                  ((b = b.ushln(num)),
                  a.iushln(num),
                  (bhi = 0 | b.words[b.length - 1])),
                a.length - b.length);
            if ("mod" !== mode) {
              ((q = new BN(null)).length = 1 + m),
                (q.words = new Array(q.length));
              for (var i = 0; i < q.length; i++) q.words[i] = 0;
            }
            var diff = a.clone()._ishlnsubmul(b, 1, m);
            0 === diff.negative && ((a = diff), q) && (q.words[m] = 1);
            for (var j = m - 1; 0 <= j; j--) {
              var qj =
                  67108864 * (0 | a.words[b.length + j]) +
                  (0 | a.words[b.length + j - 1]),
                qj = Math.min((qj / bhi) | 0, 67108863);
              for (a._ishlnsubmul(b, qj, j); 0 !== a.negative; )
                qj--,
                  (a.negative = 0),
                  a._ishlnsubmul(b, 1, j),
                  a.isZero() || (a.negative ^= 1);
              q && (q.words[j] = qj);
            }
            return (
              q && q._strip(),
              a._strip(),
              "div" !== mode && 0 != num && a.iushrn(num),
              { div: q || null, mod: a }
            );
          }),
          (BN.prototype.divmod = function divmod(num, mode, positive) {
            var div, mod, res;
            return (
              assert(!num.isZero()),
              this.isZero()
                ? { div: new BN(0), mod: new BN(0) }
                : 0 !== this.negative && 0 === num.negative
                ? ((res = this.neg().divmod(num, mode)),
                  "mod" !== mode && (div = res.div.neg()),
                  "div" !== mode &&
                    ((mod = res.mod.neg()), positive) &&
                    0 !== mod.negative &&
                    mod.iadd(num),
                  { div: div, mod: mod })
                : 0 === this.negative && 0 !== num.negative
                ? ((res = this.divmod(num.neg(), mode)),
                  {
                    div: (div = "mod" !== mode ? res.div.neg() : div),
                    mod: res.mod,
                  })
                : 0 != (this.negative & num.negative)
                ? ((res = this.neg().divmod(num.neg(), mode)),
                  "div" !== mode &&
                    ((mod = res.mod.neg()), positive) &&
                    0 !== mod.negative &&
                    mod.isub(num),
                  { div: res.div, mod: mod })
                : num.length > this.length || this.cmp(num) < 0
                ? { div: new BN(0), mod: this }
                : 1 === num.length
                ? "div" === mode
                  ? { div: this.divn(num.words[0]), mod: null }
                  : "mod" === mode
                  ? { div: null, mod: new BN(this.modrn(num.words[0])) }
                  : {
                      div: this.divn(num.words[0]),
                      mod: new BN(this.modrn(num.words[0])),
                    }
                : this._wordDiv(num, mode)
            );
          }),
          (BN.prototype.div = function div(num) {
            return this.divmod(num, "div", !1).div;
          }),
          (BN.prototype.mod = function mod(num) {
            return this.divmod(num, "mod", !1).mod;
          }),
          (BN.prototype.umod = function umod(num) {
            return this.divmod(num, "mod", !0).mod;
          }),
          (BN.prototype.divRound = function divRound(num) {
            var half,
              mod,
              dm = this.divmod(num);
            return dm.mod.isZero() ||
              ((mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod),
              (half = num.ushrn(1)),
              (num = num.andln(1)),
              (mod = mod.cmp(half)) < 0) ||
              (1 === num && 0 === mod)
              ? dm.div
              : 0 !== dm.div.negative
              ? dm.div.isubn(1)
              : dm.div.iaddn(1);
          }),
          (BN.prototype.modrn = function modrn(num) {
            for (
              var isNegNum = num < 0,
                p =
                  (assert((num = isNegNum ? -num : num) <= 67108863),
                  (1 << 26) % num),
                acc = 0,
                i = this.length - 1;
              0 <= i;
              i--
            )
              acc = (p * acc + (0 | this.words[i])) % num;
            return isNegNum ? -acc : acc;
          }),
          (BN.prototype.modn = function modn(num) {
            return this.modrn(num);
          }),
          (BN.prototype.idivn = function idivn(num) {
            for (
              var isNegNum = num < 0,
                carry = (assert((num = isNegNum ? -num : num) <= 67108863), 0),
                i = this.length - 1;
              0 <= i;
              i--
            ) {
              var w = (0 | this.words[i]) + 67108864 * carry;
              (this.words[i] = (w / num) | 0), (carry = w % num);
            }
            return this._strip(), isNegNum ? this.ineg() : this;
          }),
          (BN.prototype.divn = function divn(num) {
            return this.clone().idivn(num);
          }),
          (BN.prototype.egcd = function egcd(p) {
            assert(0 === p.negative), assert(!p.isZero());
            for (
              var x = this,
                y = p.clone(),
                x = 0 !== x.negative ? x.umod(p) : x.clone(),
                A = new BN(1),
                B = new BN(0),
                C = new BN(0),
                D = new BN(1),
                g = 0;
              x.isEven() && y.isEven();

            )
              x.iushrn(1), y.iushrn(1), ++g;
            for (var yp = y.clone(), xp = x.clone(); !x.isZero(); ) {
              for (
                var i = 0, im = 1;
                0 == (x.words[0] & im) && i < 26;
                ++i, im <<= 1
              );
              if (0 < i)
                for (x.iushrn(i); 0 < i--; )
                  (A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)),
                    A.iushrn(1),
                    B.iushrn(1);
              for (
                var j = 0, jm = 1;
                0 == (y.words[0] & jm) && j < 26;
                ++j, jm <<= 1
              );
              if (0 < j)
                for (y.iushrn(j); 0 < j--; )
                  (C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)),
                    C.iushrn(1),
                    D.iushrn(1);
              0 <= x.cmp(y)
                ? (x.isub(y), A.isub(C), B.isub(D))
                : (y.isub(x), C.isub(A), D.isub(B));
            }
            return { a: C, b: D, gcd: y.iushln(g) };
          }),
          (BN.prototype._invmp = function _invmp(p) {
            assert(0 === p.negative), assert(!p.isZero());
            for (
              var res,
                a = this,
                b = p.clone(),
                a = 0 !== a.negative ? a.umod(p) : a.clone(),
                x1 = new BN(1),
                x2 = new BN(0),
                delta = b.clone();
              0 < a.cmpn(1) && 0 < b.cmpn(1);

            ) {
              for (
                var i = 0, im = 1;
                0 == (a.words[0] & im) && i < 26;
                ++i, im <<= 1
              );
              if (0 < i)
                for (a.iushrn(i); 0 < i--; )
                  x1.isOdd() && x1.iadd(delta), x1.iushrn(1);
              for (
                var j = 0, jm = 1;
                0 == (b.words[0] & jm) && j < 26;
                ++j, jm <<= 1
              );
              if (0 < j)
                for (b.iushrn(j); 0 < j--; )
                  x2.isOdd() && x2.iadd(delta), x2.iushrn(1);
              0 <= a.cmp(b)
                ? (a.isub(b), x1.isub(x2))
                : (b.isub(a), x2.isub(x1));
            }
            return (
              (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) < 0 && res.iadd(p), res
            );
          }),
          (BN.prototype.gcd = function gcd(num) {
            if (this.isZero()) return num.abs();
            if (num.isZero()) return this.abs();
            var a = this.clone(),
              b = num.clone();
            a.negative = 0;
            for (
              var shift = (b.negative = 0);
              a.isEven() && b.isEven();
              shift++
            )
              a.iushrn(1), b.iushrn(1);
            for (;;) {
              for (; a.isEven(); ) a.iushrn(1);
              for (; b.isEven(); ) b.iushrn(1);
              var r = a.cmp(b);
              if (r < 0)
                var t = a,
                  a = b,
                  b = t;
              else if (0 === r || 0 === b.cmpn(1)) break;
              a.isub(b);
            }
            return b.iushln(shift);
          }),
          (BN.prototype.invm = function invm(num) {
            return this.egcd(num).a.umod(num);
          }),
          (BN.prototype.isEven = function isEven() {
            return 0 == (1 & this.words[0]);
          }),
          (BN.prototype.isOdd = function isOdd() {
            return 1 == (1 & this.words[0]);
          }),
          (BN.prototype.andln = function andln(num) {
            return this.words[0] & num;
          }),
          (BN.prototype.bincn = function bincn(bit) {
            assert("number" == typeof bit);
            var r = bit % 26,
              bit = (bit - r) / 26,
              r = 1 << r;
            if (this.length <= bit)
              this._expand(1 + bit), (this.words[bit] |= r);
            else {
              for (
                var carry = r, i = bit;
                0 !== carry && i < this.length;
                i++
              ) {
                var w = 0 | this.words[i],
                  carry = (w += carry) >>> 26;
                (w &= 67108863), (this.words[i] = w);
              }
              0 !== carry && ((this.words[i] = carry), this.length++);
            }
            return this;
          }),
          (BN.prototype.isZero = function isZero() {
            return 1 === this.length && 0 === this.words[0];
          }),
          (BN.prototype.cmpn = function cmpn(num) {
            var negative = num < 0;
            return 0 === this.negative || negative
              ? 0 === this.negative && negative
                ? 1
                : (this._strip(),
                  (negative =
                    1 < this.length
                      ? 1
                      : (assert(
                          (num = negative ? -num : num) <= 67108863,
                          "Number is too big"
                        ),
                        (negative = 0 | this.words[0]) === num
                          ? 0
                          : negative < num
                          ? -1
                          : 1)),
                  0 !== this.negative ? 0 | -negative : negative)
              : -1;
          }),
          (BN.prototype.cmp = function cmp(num) {
            return 0 !== this.negative && 0 === num.negative
              ? -1
              : 0 === this.negative && 0 !== num.negative
              ? 1
              : ((num = this.ucmp(num)), 0 !== this.negative ? 0 | -num : num);
          }),
          (BN.prototype.ucmp = function ucmp(num) {
            if (this.length > num.length) return 1;
            if (this.length < num.length) return -1;
            for (var res = 0, i = this.length - 1; 0 <= i; i--) {
              var a = 0 | this.words[i],
                b = 0 | num.words[i];
              if (a != b) {
                a < b ? (res = -1) : b < a && (res = 1);
                break;
              }
            }
            return res;
          }),
          (BN.prototype.gtn = function gtn(num) {
            return 1 === this.cmpn(num);
          }),
          (BN.prototype.gt = function gt(num) {
            return 1 === this.cmp(num);
          }),
          (BN.prototype.gten = function gten(num) {
            return 0 <= this.cmpn(num);
          }),
          (BN.prototype.gte = function gte(num) {
            return 0 <= this.cmp(num);
          }),
          (BN.prototype.ltn = function ltn(num) {
            return -1 === this.cmpn(num);
          }),
          (BN.prototype.lt = function lt(num) {
            return -1 === this.cmp(num);
          }),
          (BN.prototype.lten = function lten(num) {
            return this.cmpn(num) <= 0;
          }),
          (BN.prototype.lte = function lte(num) {
            return this.cmp(num) <= 0;
          }),
          (BN.prototype.eqn = function eqn(num) {
            return 0 === this.cmpn(num);
          }),
          (BN.prototype.eq = function eq(num) {
            return 0 === this.cmp(num);
          }),
          (BN.red = function red(num) {
            return new Red(num);
          }),
          (BN.prototype.toRed = function toRed(ctx) {
            return (
              assert(!this.red, "Already a number in reduction context"),
              assert(0 === this.negative, "red works only with positives"),
              ctx.convertTo(this)._forceRed(ctx)
            );
          }),
          (BN.prototype.fromRed = function fromRed() {
            return (
              assert(
                this.red,
                "fromRed works only with numbers in reduction context"
              ),
              this.red.convertFrom(this)
            );
          }),
          (BN.prototype._forceRed = function _forceRed(ctx) {
            return (this.red = ctx), this;
          }),
          (BN.prototype.forceRed = function forceRed(ctx) {
            return (
              assert(!this.red, "Already a number in reduction context"),
              this._forceRed(ctx)
            );
          }),
          (BN.prototype.redAdd = function redAdd(num) {
            return (
              assert(this.red, "redAdd works only with red numbers"),
              this.red.add(this, num)
            );
          }),
          (BN.prototype.redIAdd = function redIAdd(num) {
            return (
              assert(this.red, "redIAdd works only with red numbers"),
              this.red.iadd(this, num)
            );
          }),
          (BN.prototype.redSub = function redSub(num) {
            return (
              assert(this.red, "redSub works only with red numbers"),
              this.red.sub(this, num)
            );
          }),
          (BN.prototype.redISub = function redISub(num) {
            return (
              assert(this.red, "redISub works only with red numbers"),
              this.red.isub(this, num)
            );
          }),
          (BN.prototype.redShl = function redShl(num) {
            return (
              assert(this.red, "redShl works only with red numbers"),
              this.red.shl(this, num)
            );
          }),
          (BN.prototype.redMul = function redMul(num) {
            return (
              assert(this.red, "redMul works only with red numbers"),
              this.red._verify2(this, num),
              this.red.mul(this, num)
            );
          }),
          (BN.prototype.redIMul = function redIMul(num) {
            return (
              assert(this.red, "redMul works only with red numbers"),
              this.red._verify2(this, num),
              this.red.imul(this, num)
            );
          }),
          (BN.prototype.redSqr = function redSqr() {
            return (
              assert(this.red, "redSqr works only with red numbers"),
              this.red._verify1(this),
              this.red.sqr(this)
            );
          }),
          (BN.prototype.redISqr = function redISqr() {
            return (
              assert(this.red, "redISqr works only with red numbers"),
              this.red._verify1(this),
              this.red.isqr(this)
            );
          }),
          (BN.prototype.redSqrt = function redSqrt() {
            return (
              assert(this.red, "redSqrt works only with red numbers"),
              this.red._verify1(this),
              this.red.sqrt(this)
            );
          }),
          (BN.prototype.redInvm = function redInvm() {
            return (
              assert(this.red, "redInvm works only with red numbers"),
              this.red._verify1(this),
              this.red.invm(this)
            );
          }),
          (BN.prototype.redNeg = function redNeg() {
            return (
              assert(this.red, "redNeg works only with red numbers"),
              this.red._verify1(this),
              this.red.neg(this)
            );
          }),
          (BN.prototype.redPow = function redPow(num) {
            return (
              assert(this.red && !num.red, "redPow(normalNum)"),
              this.red._verify1(this),
              this.red.pow(this, num)
            );
          });
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          (this.name = name),
            (this.p = new BN(p, 16)),
            (this.n = this.p.bitLength()),
            (this.k = new BN(1).iushln(this.n).isub(this.p)),
            (this.tmp = this._tmp());
        }
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        function Red(m) {
          var prime;
          "string" == typeof m
            ? ((prime = BN._prime(m)), (this.m = prime.p), (this.prime = prime))
            : (assert(m.gtn(1), "modulus must be greater than 1"),
              (this.m = m),
              (this.prime = null));
        }
        function Mont(m) {
          Red.call(this, m),
            (this.shift = this.m.bitLength()),
            this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
            (this.r = new BN(1).iushln(this.shift)),
            (this.r2 = this.imod(this.r.sqr())),
            (this.rinv = this.r._invmp(this.m)),
            (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
            (this.minv = this.minv.umod(this.r)),
            (this.minv = this.r.sub(this.minv));
        }
        (MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return (tmp.words = new Array(Math.ceil(this.n / 13))), tmp;
        }),
          (MPrime.prototype.ireduce = function ireduce(num) {
            for (
              var rlen, r = num;
              this.split(r, this.tmp),
                (rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()) >
                  this.n;

            );
            num = rlen < this.n ? -1 : r.ucmp(this.p);
            return (
              0 === num
                ? ((r.words[0] = 0), (r.length = 1))
                : 0 < num
                ? r.isub(this.p)
                : void 0 !== r.strip
                ? r.strip()
                : r._strip(),
              r
            );
          }),
          (MPrime.prototype.split = function split(input, out) {
            input.iushrn(this.n, 0, out);
          }),
          (MPrime.prototype.imulK = function imulK(num) {
            return num.imul(this.k);
          }),
          inherits(K256, MPrime),
          (K256.prototype.split = function split(input, output) {
            for (var outLen = Math.min(input.length, 9), i = 0; i < outLen; i++)
              output.words[i] = input.words[i];
            if (((output.length = outLen), input.length <= 9))
              (input.words[0] = 0), (input.length = 1);
            else {
              var prev = input.words[9];
              for (
                output.words[output.length++] = 4194303 & prev, i = 10;
                i < input.length;
                i++
              ) {
                var next = 0 | input.words[i];
                (input.words[i - 10] = ((4194303 & next) << 4) | (prev >>> 22)),
                  (prev = next);
              }
              0 === (input.words[i - 10] = prev >>>= 22) && 10 < input.length
                ? (input.length -= 10)
                : (input.length -= 9);
            }
          }),
          (K256.prototype.imulK = function imulK(num) {
            (num.words[num.length] = 0),
              (num.words[num.length + 1] = 0),
              (num.length += 2);
            for (var lo = 0, i = 0; i < num.length; i++) {
              var w = 0 | num.words[i];
              (lo += 977 * w),
                (num.words[i] = 67108863 & lo),
                (lo = 64 * w + ((lo / 67108864) | 0));
            }
            return (
              0 === num.words[num.length - 1] &&
                (num.length--, 0 === num.words[num.length - 1]) &&
                num.length--,
              num
            );
          }),
          inherits(P224, MPrime),
          inherits(P192, MPrime),
          inherits(P25519, MPrime),
          (P25519.prototype.imulK = function imulK(num) {
            for (var carry = 0, i = 0; i < num.length; i++) {
              var hi = 19 * (0 | num.words[i]) + carry,
                lo = 67108863 & hi;
              (hi >>>= 26), (num.words[i] = lo), (carry = hi);
            }
            return 0 !== carry && (num.words[num.length++] = carry), num;
          }),
          (BN._prime = function prime(name) {
            if (primes[name]) return primes[name];
            var prime;
            if ("k256" === name) prime = new K256();
            else if ("p224" === name) prime = new P224();
            else if ("p192" === name) prime = new P192();
            else {
              if ("p25519" !== name) throw new Error("Unknown prime " + name);
              prime = new P25519();
            }
            return (primes[name] = prime);
          }),
          (Red.prototype._verify1 = function _verify1(a) {
            assert(0 === a.negative, "red works only with positives"),
              assert(a.red, "red works only with red numbers");
          }),
          (Red.prototype._verify2 = function _verify2(a, b) {
            assert(
              0 == (a.negative | b.negative),
              "red works only with positives"
            ),
              assert(
                a.red && a.red === b.red,
                "red works only with red numbers"
              );
          }),
          (Red.prototype.imod = function imod(a) {
            return this.prime
              ? this.prime.ireduce(a)._forceRed(this)
              : (move(a, a.umod(this.m)._forceRed(this)), a);
          }),
          (Red.prototype.neg = function neg(a) {
            return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
          }),
          (Red.prototype.add = function add(a, b) {
            this._verify2(a, b);
            a = a.add(b);
            return 0 <= a.cmp(this.m) && a.isub(this.m), a._forceRed(this);
          }),
          (Red.prototype.iadd = function iadd(a, b) {
            this._verify2(a, b);
            a = a.iadd(b);
            return 0 <= a.cmp(this.m) && a.isub(this.m), a;
          }),
          (Red.prototype.sub = function sub(a, b) {
            this._verify2(a, b);
            a = a.sub(b);
            return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this);
          }),
          (Red.prototype.isub = function isub(a, b) {
            this._verify2(a, b);
            a = a.isub(b);
            return a.cmpn(0) < 0 && a.iadd(this.m), a;
          }),
          (Red.prototype.shl = function shl(a, num) {
            return this._verify1(a), this.imod(a.ushln(num));
          }),
          (Red.prototype.imul = function imul(a, b) {
            return this._verify2(a, b), this.imod(a.imul(b));
          }),
          (Red.prototype.mul = function mul(a, b) {
            return this._verify2(a, b), this.imod(a.mul(b));
          }),
          (Red.prototype.isqr = function isqr(a) {
            return this.imul(a, a.clone());
          }),
          (Red.prototype.sqr = function sqr(a) {
            return this.mul(a, a);
          }),
          (Red.prototype.sqrt = function sqrt(a) {
            if (a.isZero()) return a.clone();
            var mod3 = this.m.andln(3);
            if ((assert(mod3 % 2 == 1), 3 === mod3))
              return (
                (mod3 = this.m.add(new BN(1)).iushrn(2)), this.pow(a, mod3)
              );
            for (
              var q = this.m.subn(1), s = 0;
              !q.isZero() && 0 === q.andln(1);

            )
              s++, q.iushrn(1);
            assert(!q.isZero());
            for (
              var one = new BN(1).toRed(this),
                nOne = one.redNeg(),
                lpow = this.m.subn(1).iushrn(1),
                z = new BN(2 * (z = this.m.bitLength()) * z).toRed(this);
              0 !== this.pow(z, lpow).cmp(nOne);

            )
              z.redIAdd(nOne);
            for (
              var c = this.pow(z, q),
                r = this.pow(a, q.addn(1).iushrn(1)),
                t = this.pow(a, q),
                m = s;
              0 !== t.cmp(one);

            ) {
              for (var tmp = t, i = 0; 0 !== tmp.cmp(one); i++)
                tmp = tmp.redSqr();
              assert(i < m);
              var b = this.pow(c, new BN(1).iushln(m - i - 1)),
                r = r.redMul(b),
                c = b.redSqr(),
                t = t.redMul(c),
                m = i;
            }
            return r;
          }),
          (Red.prototype.invm = function invm(a) {
            a = a._invmp(this.m);
            return 0 !== a.negative
              ? ((a.negative = 0), this.imod(a).redNeg())
              : this.imod(a);
          }),
          (Red.prototype.pow = function pow(a, num) {
            if (num.isZero()) return new BN(1).toRed(this);
            if (0 === num.cmpn(1)) return a.clone();
            var wnd = new Array(16);
            (wnd[0] = new BN(1).toRed(this)), (wnd[1] = a);
            for (var i = 2; i < wnd.length; i++)
              wnd[i] = this.mul(wnd[i - 1], a);
            var res = wnd[0],
              current = 0,
              currentLen = 0,
              start = num.bitLength() % 26;
            for (0 === start && (start = 26), i = num.length - 1; 0 <= i; i--) {
              for (var word = num.words[i], j = start - 1; 0 <= j; j--) {
                var bit = (word >> j) & 1;
                res !== wnd[0] && (res = this.sqr(res)),
                  0 == bit && 0 === current
                    ? (currentLen = 0)
                    : ((current = (current << 1) | bit),
                      (4 === ++currentLen || (0 === i && 0 === j)) &&
                        ((res = this.mul(res, wnd[current])),
                        (current = currentLen = 0)));
              }
              start = 26;
            }
            return res;
          }),
          (Red.prototype.convertTo = function convertTo(num) {
            var r = num.umod(this.m);
            return r === num ? r.clone() : r;
          }),
          (Red.prototype.convertFrom = function convertFrom(num) {
            num = num.clone();
            return (num.red = null), num;
          }),
          (BN.mont = function mont(num) {
            return new Mont(num);
          }),
          inherits(Mont, Red),
          (Mont.prototype.convertTo = function convertTo(num) {
            return this.imod(num.ushln(this.shift));
          }),
          (Mont.prototype.convertFrom = function convertFrom(num) {
            num = this.imod(num.mul(this.rinv));
            return (num.red = null), num;
          }),
          (Mont.prototype.imul = function imul(a, b) {
            return a.isZero() || b.isZero()
              ? ((a.words[0] = 0), (a.length = 1), a)
              : ((b = (a = a.imul(b))
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m)),
                0 <= (b = a = a.isub(b).iushrn(this.shift)).cmp(this.m)
                  ? (b = a.isub(this.m))
                  : a.cmpn(0) < 0 && (b = a.iadd(this.m)),
                b._forceRed(this));
          }),
          (Mont.prototype.mul = function mul(a, b) {
            return (
              a.isZero() || b.isZero()
                ? new BN(0)
                : ((b = (a = a.mul(b))
                    .maskn(this.shift)
                    .mul(this.minv)
                    .imaskn(this.shift)
                    .mul(this.m)),
                  0 <= (b = a = a.isub(b).iushrn(this.shift)).cmp(this.m)
                    ? (b = a.isub(this.m))
                    : a.cmpn(0) < 0 && (b = a.iadd(this.m)),
                  b)
            )._forceRed(this);
          }),
          (Mont.prototype.invm = function invm(a) {
            return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
          });
      })((module = __webpack_require__.nmd(module)), this);
    },
    5375: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";
      var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                void 0 === k2 && (k2 = k),
                  Object.defineProperty(o, k2, {
                    enumerable: !0,
                    get: function () {
                      return m[k];
                    },
                  });
              }
            : function (o, m, k, k2) {
                o[(k2 = void 0 === k2 ? k : k2)] = m[k];
              }),
        __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: !0,
                  value: v,
                });
              }
            : function (o, v) {
                o.default = v;
              }),
        __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var d,
              c = arguments.length,
              r =
                c < 3
                  ? target
                  : null === desc
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; 0 <= i; i--)
                (d = decorators[i]) &&
                  (r =
                    (c < 3
                      ? d(r)
                      : 3 < c
                      ? d(target, key, r)
                      : d(target, key)) || r);
            return 3 < c && r && Object.defineProperty(target, key, r), r;
          },
        __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod)
              for (var k in mod)
                "default" !== k &&
                  Object.hasOwnProperty.call(mod, k) &&
                  __createBinding(result, mod, k);
            return __setModuleDefault(result, mod), result;
          },
        __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
      Object.defineProperty(exports, "__esModule", { value: !0 }),
        (exports.deserializeUnchecked =
          exports.deserialize =
          exports.serialize =
          exports.BinaryReader =
          exports.BinaryWriter =
          exports.BorshError =
          exports.baseDecode =
          exports.baseEncode =
            void 0);
      const bn_js_1 = __importDefault(__webpack_require__(7240)),
        bs58_1 = __importDefault(__webpack_require__(1049));
      __importDefault = __importStar(__webpack_require__(6261));
      const textDecoder = new (
        "function" != typeof TextDecoder
          ? __importDefault.TextDecoder
          : TextDecoder
      )("utf-8", { fatal: !0 });
      (exports.baseEncode = function baseEncode(value) {
        return (
          "string" == typeof value && (value = Buffer.from(value, "utf8")),
          bs58_1.default.encode(Buffer.from(value))
        );
      }),
        (exports.baseDecode = function baseDecode(value) {
          return Buffer.from(bs58_1.default.decode(value));
        });
      class BorshError extends Error {
        constructor(message) {
          super(message),
            (this.fieldPath = []),
            (this.originalMessage = message);
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName),
            (this.message =
              this.originalMessage + ": " + this.fieldPath.join("."));
        }
      }
      exports.BorshError = BorshError;
      class BinaryWriter {
        constructor() {
          (this.buf = Buffer.alloc(1024)), (this.length = 0);
        }
        maybeResize() {
          this.buf.length < 16 + this.length &&
            (this.buf = Buffer.concat([this.buf, Buffer.alloc(1024)]));
        }
        writeU8(value) {
          this.maybeResize(),
            this.buf.writeUInt8(value, this.length),
            (this.length += 1);
        }
        writeU16(value) {
          this.maybeResize(),
            this.buf.writeUInt16LE(value, this.length),
            (this.length += 2);
        }
        writeU32(value) {
          this.maybeResize(),
            this.buf.writeUInt32LE(value, this.length),
            (this.length += 4);
        }
        writeU64(value) {
          this.maybeResize(),
            this.writeBuffer(
              Buffer.from(new bn_js_1.default(value).toArray("le", 8))
            );
        }
        writeU128(value) {
          this.maybeResize(),
            this.writeBuffer(
              Buffer.from(new bn_js_1.default(value).toArray("le", 16))
            );
        }
        writeU256(value) {
          this.maybeResize(),
            this.writeBuffer(
              Buffer.from(new bn_js_1.default(value).toArray("le", 32))
            );
        }
        writeU512(value) {
          this.maybeResize(),
            this.writeBuffer(
              Buffer.from(new bn_js_1.default(value).toArray("le", 64))
            );
        }
        writeBuffer(buffer) {
          (this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(1024),
          ])),
            (this.length += buffer.length);
        }
        writeString(str) {
          this.maybeResize();
          str = Buffer.from(str, "utf8");
          this.writeU32(str.length), this.writeBuffer(str);
        }
        writeFixedArray(array) {
          this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
          this.maybeResize(), this.writeU32(array.length);
          for (const elem of array) this.maybeResize(), fn(elem);
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      }
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function (...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              args = e.code;
              if (
                0 <=
                ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(args)
              )
                throw new BorshError(
                  "Reached the end of buffer when deserializing"
                );
            }
            throw e;
          }
        };
      }
      exports.BinaryWriter = BinaryWriter;
      class BinaryReader {
        constructor(buf) {
          (this.buf = buf), (this.offset = 0);
        }
        readU8() {
          var value = this.buf.readUInt8(this.offset);
          return (this.offset += 1), value;
        }
        readU16() {
          var value = this.buf.readUInt16LE(this.offset);
          return (this.offset += 2), value;
        }
        readU32() {
          var value = this.buf.readUInt32LE(this.offset);
          return (this.offset += 4), value;
        }
        readU64() {
          var buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          var buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          var buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          var buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length)
            throw new BorshError(
              `Expected buffer length ${len} isn't within bounds`
            );
          var result = this.buf.slice(this.offset, this.offset + len);
          return (this.offset += len), result;
        }
        readString() {
          var len = this.readU32(),
            len = this.readBuffer(len);
          try {
            return textDecoder.decode(len);
          } catch (e) {
            throw new BorshError("Error decoding UTF-8 string: " + e);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          var len = this.readU32(),
            result = Array();
          for (let i = 0; i < len; ++i) result.push(fn());
          return result;
        }
      }
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if ("string" == typeof fieldType)
            writer["write" + capitalizeFirstLetter(fieldType)](value);
          else if (fieldType instanceof Array)
            if ("number" == typeof fieldType[0]) {
              if (value.length !== fieldType[0])
                throw new BorshError(
                  `Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`
                );
              writer.writeFixedArray(value);
            } else if (
              2 === fieldType.length &&
              "number" == typeof fieldType[1]
            ) {
              if (value.length !== fieldType[1])
                throw new BorshError(
                  `Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`
                );
              for (let i = 0; i < fieldType[1]; i++)
                serializeField(schema, null, value[i], fieldType[0], writer);
            } else
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
          else if (void 0 !== fieldType.kind)
            switch (fieldType.kind) {
              case "option":
                null == value
                  ? writer.writeU8(0)
                  : (writer.writeU8(1),
                    serializeField(
                      schema,
                      fieldName,
                      value,
                      fieldType.type,
                      writer
                    ));
                break;
              case "map":
                writer.writeU32(value.size),
                  value.forEach((val, key) => {
                    serializeField(
                      schema,
                      fieldName,
                      key,
                      fieldType.key,
                      writer
                    ),
                      serializeField(
                        schema,
                        fieldName,
                        val,
                        fieldType.value,
                        writer
                      );
                  });
                break;
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          else serializeStruct(schema, value, writer);
        } catch (error) {
          throw (
            (error instanceof BorshError && error.addToFieldPath(fieldName),
            error)
          );
        }
      }
      function serializeStruct(schema, obj, writer) {
        if ("function" == typeof obj.borshSerialize) obj.borshSerialize(writer);
        else {
          var structSchema = schema.get(obj.constructor);
          if (!structSchema)
            throw new BorshError(
              `Class ${obj.constructor.name} is missing in schema`
            );
          if ("struct" === structSchema.kind)
            structSchema.fields.map(([fieldName, fieldType]) => {
              serializeField(
                schema,
                fieldName,
                obj[fieldName],
                fieldType,
                writer
              );
            });
          else {
            if ("enum" !== structSchema.kind)
              throw new BorshError(
                `Unexpected schema kind: ${structSchema.kind} for ` +
                  obj.constructor.name
              );
            var name = obj[structSchema.field];
            for (let idx = 0; idx < structSchema.values.length; ++idx) {
              var [fieldName, fieldType] = structSchema.values[idx];
              if (fieldName === name) {
                writer.writeU8(idx),
                  serializeField(
                    schema,
                    fieldName,
                    obj[fieldName],
                    fieldType,
                    writer
                  );
                break;
              }
            }
          }
        }
      }
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if ("string" == typeof fieldType)
            return reader["read" + capitalizeFirstLetter(fieldType)]();
          if (fieldType instanceof Array) {
            if ("number" == typeof fieldType[0])
              return reader.readFixedArray(fieldType[0]);
            if ("number" != typeof fieldType[1])
              return reader.readArray(() =>
                deserializeField(schema, fieldName, fieldType[0], reader)
              );
            var arr = [];
            for (let i = 0; i < fieldType[1]; i++)
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            return arr;
          }
          if ("option" === fieldType.kind)
            return reader.readU8()
              ? deserializeField(schema, fieldName, fieldType.type, reader)
              : void 0;
          if ("map" !== fieldType.kind)
            return deserializeStruct(schema, fieldType, reader);
          var map = new Map(),
            length = reader.readU32();
          for (let i = 0; i < length; i++) {
            var key = deserializeField(
                schema,
                fieldName,
                fieldType.key,
                reader
              ),
              val = deserializeField(
                schema,
                fieldName,
                fieldType.value,
                reader
              );
            map.set(key, val);
          }
          return map;
        } catch (error) {
          throw (
            (error instanceof BorshError && error.addToFieldPath(fieldName),
            error)
          );
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if ("function" == typeof classType.borshDeserialize)
          return classType.borshDeserialize(reader);
        var structSchema = schema.get(classType);
        if (!structSchema)
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        if ("struct" === structSchema.kind) {
          var fieldName,
            fieldType,
            result = {};
          for ([fieldName, fieldType] of schema.get(classType).fields)
            result[fieldName] = deserializeField(
              schema,
              fieldName,
              fieldType,
              reader
            );
          return new classType(result);
        }
        if ("enum" !== structSchema.kind)
          throw new BorshError(
            `Unexpected schema kind: ${structSchema.kind} for ` +
              classType.constructor.name
          );
        {
          var idx = reader.readU8();
          if (idx >= structSchema.values.length)
            throw new BorshError(`Enum index: ${idx} is out of range`);
          const [fieldName, fieldType] = structSchema.values[idx];
          return new classType({
            [fieldName]: deserializeField(schema, fieldName, fieldType, reader),
          });
        }
      }
      __decorate([handlingRangeError], BinaryReader.prototype, "readU8", null),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU16",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU32",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU64",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU128",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU256",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readU512",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readString",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readFixedArray",
          null
        ),
        __decorate(
          [handlingRangeError],
          BinaryReader.prototype,
          "readArray",
          null
        ),
        (exports.BinaryReader = BinaryReader),
        (exports.serialize = function serialize(
          schema,
          obj,
          Writer = BinaryWriter
        ) {
          return (
            (Writer = new Writer()),
            serializeStruct(schema, obj, Writer),
            Writer.toArray()
          );
        }),
        (exports.deserialize = function deserialize(
          schema,
          classType,
          buffer,
          Reader = BinaryReader
        ) {
          if (
            ((Reader = new Reader(buffer)),
            (schema = deserializeStruct(schema, classType, Reader)),
            Reader.offset < buffer.length)
          )
            throw new BorshError(
              `Unexpected ${
                buffer.length - Reader.offset
              } bytes after deserialized data`
            );
          return schema;
        }),
        (exports.deserializeUnchecked = function deserializeUnchecked(
          schema,
          classType,
          buffer,
          Reader = BinaryReader
        ) {
          return deserializeStruct(schema, classType, new Reader(buffer));
        });
    },
    6194: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _Buffer = __webpack_require__(1817).Buffer;
      module.exports = function base(ALPHABET) {
        if (255 <= ALPHABET.length) throw new TypeError("Alphabet too long");
        for (
          var BASE_MAP = new Uint8Array(256), j = 0;
          j < BASE_MAP.length;
          j++
        )
          BASE_MAP[j] = 255;
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i),
            xc = x.charCodeAt(0);
          if (255 !== BASE_MAP[xc]) throw new TypeError(x + " is ambiguous");
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length,
          LEADER = ALPHABET.charAt(0),
          FACTOR = Math.log(BASE) / Math.log(256),
          iFACTOR = Math.log(256) / Math.log(BASE);
        function decodeUnsafe(source) {
          if ("string" != typeof source) throw new TypeError("Expected String");
          if (0 === source.length) return _Buffer.alloc(0);
          for (var psz = 0, zeroes = 0, length = 0; source[psz] === LEADER; )
            zeroes++, psz++;
          for (
            var size = ((source.length - psz) * FACTOR + 1) >>> 0,
              b256 = new Uint8Array(size);
            source[psz];

          ) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (255 === carry) return;
            for (
              var i = 0, it3 = size - 1;
              (0 !== carry || i < length) && -1 !== it3;
              it3--, i++
            )
              (carry += (BASE * b256[it3]) >>> 0),
                (b256[it3] = carry % 256 >>> 0),
                (carry = (carry / 256) >>> 0);
            if (0 !== carry) throw new Error("Non-zero carry");
            (length = i), psz++;
          }
          for (var it4 = size - length; it4 !== size && 0 === b256[it4]; )
            it4++;
          for (
            var vch = _Buffer.allocUnsafe(zeroes + (size - it4)),
              j = (vch.fill(0, 0, zeroes), zeroes);
            it4 !== size;

          )
            vch[j++] = b256[it4++];
          return vch;
        }
        return {
          encode: function encode(source) {
            if (
              ((Array.isArray(source) || source instanceof Uint8Array) &&
                (source = _Buffer.from(source)),
              !_Buffer.isBuffer(source))
            )
              throw new TypeError("Expected Buffer");
            if (0 === source.length) return "";
            for (
              var zeroes = 0, length = 0, pbegin = 0, pend = source.length;
              pbegin !== pend && 0 === source[pbegin];

            )
              pbegin++, zeroes++;
            for (
              var size = ((pend - pbegin) * iFACTOR + 1) >>> 0,
                b58 = new Uint8Array(size);
              pbegin !== pend;

            ) {
              for (
                var carry = source[pbegin], i = 0, it1 = size - 1;
                (0 !== carry || i < length) && -1 !== it1;
                it1--, i++
              )
                (carry += (256 * b58[it1]) >>> 0),
                  (b58[it1] = carry % BASE >>> 0),
                  (carry = (carry / BASE) >>> 0);
              if (0 !== carry) throw new Error("Non-zero carry");
              (length = i), pbegin++;
            }
            for (var it2 = size - length; it2 !== size && 0 === b58[it2]; )
              it2++;
            for (var str = LEADER.repeat(zeroes); it2 < size; ++it2)
              str += ALPHABET.charAt(b58[it2]);
            return str;
          },
          decodeUnsafe: decodeUnsafe,
          decode: function decode(string) {
            if ((string = decodeUnsafe(string))) return string;
            throw new Error("Non-base" + BASE + " character");
          },
        };
      };
    },
    1049: (module, __unused_webpack_exports, __webpack_require__) => {
      __webpack_require__ = __webpack_require__(6194);
      module.exports = __webpack_require__(
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      );
    },
    463: (module, __unused_webpack_exports, __webpack_require__) => {
      __webpack_require__ = __webpack_require__(1736);
      module.exports = __webpack_require__(
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      );
    },
    8891: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const base64 = __webpack_require__(7322),
        ieee754 = __webpack_require__(8239);
      __webpack_require__ =
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? Symbol.for("nodejs.util.inspect.custom")
          : null;
      (exports.Buffer = Buffer),
        (exports.SlowBuffer = function SlowBuffer(length) {
          +length != length && (length = 0);
          return Buffer.alloc(+length);
        }),
        (exports.INSPECT_MAX_BYTES = 50);
      const K_MAX_LENGTH = 2147483647;
      function createBuffer(length) {
        if (length > K_MAX_LENGTH)
          throw new RangeError(
            'The value "' + length + '" is invalid for option "size"'
          );
        length = new Uint8Array(length);
        return Object.setPrototypeOf(length, Buffer.prototype), length;
      }
      function Buffer(arg, encodingOrOffset, length) {
        if ("number" != typeof arg) return from(arg, encodingOrOffset, length);
        if ("string" == typeof encodingOrOffset)
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return allocUnsafe(arg);
      }
      function from(value, encodingOrOffset, length) {
        if ("string" == typeof value)
          return (function fromString(string, encoding) {
            ("string" == typeof encoding && "" !== encoding) ||
              (encoding = "utf8");
            if (!Buffer.isEncoding(encoding))
              throw new TypeError("Unknown encoding: " + encoding);
            var length = 0 | byteLength(string, encoding);
            let buf = createBuffer(length);
            string = buf.write(string, encoding);
            string !== length && (buf = buf.slice(0, string));
            return buf;
          })(value, encodingOrOffset);
        if (ArrayBuffer.isView(value))
          return (function fromArrayView(arrayView) {
            {
              var copy;
              if (isInstance(arrayView, Uint8Array))
                return fromArrayBuffer(
                  (copy = new Uint8Array(arrayView)).buffer,
                  copy.byteOffset,
                  copy.byteLength
                );
            }
            return fromArrayLike(arrayView);
          })(value);
        if (null != value) {
          if (
            isInstance(value, ArrayBuffer) ||
            (value && isInstance(value.buffer, ArrayBuffer))
          )
            return fromArrayBuffer(value, encodingOrOffset, length);
          if (
            "undefined" != typeof SharedArrayBuffer &&
            (isInstance(value, SharedArrayBuffer) ||
              (value && isInstance(value.buffer, SharedArrayBuffer)))
          )
            return fromArrayBuffer(value, encodingOrOffset, length);
          if ("number" == typeof value)
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            );
          var valueOf = value.valueOf && value.valueOf();
          if (null != valueOf && valueOf !== value)
            return Buffer.from(valueOf, encodingOrOffset, length);
          valueOf = (function fromObject(obj) {
            {
              var len, buf;
              if (Buffer.isBuffer(obj))
                return (
                  (len = 0 | checked(obj.length)),
                  0 !== (buf = createBuffer(len)).length &&
                    obj.copy(buf, 0, 0, len),
                  buf
                );
            }
            if (void 0 !== obj.length)
              return "number" != typeof obj.length || numberIsNaN(obj.length)
                ? createBuffer(0)
                : fromArrayLike(obj);
            if ("Buffer" === obj.type && Array.isArray(obj.data))
              return fromArrayLike(obj.data);
          })(value);
          if (valueOf) return valueOf;
          if (
            "undefined" != typeof Symbol &&
            null != Symbol.toPrimitive &&
            "function" == typeof value[Symbol.toPrimitive]
          )
            return Buffer.from(
              value[Symbol.toPrimitive]("string"),
              encodingOrOffset,
              length
            );
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof value
        );
      }
      function assertSize(size) {
        if ("number" != typeof size)
          throw new TypeError('"size" argument must be of type number');
        if (size < 0)
          throw new RangeError(
            'The value "' + size + '" is invalid for option "size"'
          );
      }
      function allocUnsafe(size) {
        return assertSize(size), createBuffer(size < 0 ? 0 : 0 | checked(size));
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : 0 | checked(array.length),
          buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) buf[i] = 255 & array[i];
        return buf;
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (array.byteLength < byteOffset + (length || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let buf;
        return (
          (buf =
            void 0 === byteOffset && void 0 === length
              ? new Uint8Array(array)
              : void 0 === length
              ? new Uint8Array(array, byteOffset)
              : new Uint8Array(array, byteOffset, length)),
          Object.setPrototypeOf(buf, Buffer.prototype),
          buf
        );
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH)
          throw new RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x" +
              K_MAX_LENGTH.toString(16) +
              " bytes"
          );
        return 0 | length;
      }
      function byteLength(string, encoding) {
        if (Buffer.isBuffer(string)) return string.length;
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
          return string.byteLength;
        if ("string" != typeof string)
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof string
          );
        var len = string.length,
          mustMatch = 2 < arguments.length && !0 === arguments[2];
        if (!mustMatch && 0 === len) return 0;
        let loweredCase = !1;
        for (;;)
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * len;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase)
                return mustMatch ? -1 : utf8ToBytes(string).length;
              (encoding = ("" + encoding).toLowerCase()), (loweredCase = !0);
          }
      }
      function slowToString(encoding, start, end) {
        let loweredCase = !1;
        if ((start = void 0 === start || start < 0 ? 0 : start) > this.length)
          return "";
        if (
          (end = void 0 === end || end > this.length ? this.length : end) <= 0
        )
          return "";
        if ((end >>>= 0) <= (start >>>= 0)) return "";
        for (encoding = encoding || "utf8"; ; )
          switch (encoding) {
            case "hex":
              return (function hexSlice(buf, start, end) {
                var len = buf.length;
                (!start || start < 0) && (start = 0);
                (!end || end < 0 || len < end) && (end = len);
                let out = "";
                for (let i = start; i < end; ++i)
                  out += hexSliceLookupTable[buf[i]];
                return out;
              })(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return (function asciiSlice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i)
                  ret += String.fromCharCode(127 & buf[i]);
                return ret;
              })(this, start, end);
            case "latin1":
            case "binary":
              return (function latin1Slice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i)
                  ret += String.fromCharCode(buf[i]);
                return ret;
              })(this, start, end);
            case "base64":
              return (function base64Slice(buf, start, end) {
                return 0 === start && end === buf.length
                  ? base64.fromByteArray(buf)
                  : base64.fromByteArray(buf.slice(start, end));
              })(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return (function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                let res = "";
                for (let i = 0; i < bytes.length - 1; i += 2)
                  res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                return res;
              })(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              (encoding = (encoding + "").toLowerCase()), (loweredCase = !0);
          }
      }
      function swap(b, n, m) {
        var i = b[n];
        (b[n] = b[m]), (b[m] = i);
      }
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (0 === buffer.length) return -1;
        if (
          ("string" == typeof byteOffset
            ? ((encoding = byteOffset), (byteOffset = 0))
            : 2147483647 < byteOffset
            ? (byteOffset = 2147483647)
            : byteOffset < -2147483648 && (byteOffset = -2147483648),
          (byteOffset =
            (byteOffset = numberIsNaN((byteOffset = +byteOffset))
              ? dir
                ? 0
                : buffer.length - 1
              : byteOffset) < 0
              ? buffer.length + byteOffset
              : byteOffset) >= buffer.length)
        ) {
          if (dir) return -1;
          byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (!dir) return -1;
          byteOffset = 0;
        }
        if (
          ("string" == typeof val && (val = Buffer.from(val, encoding)),
          Buffer.isBuffer(val))
        )
          return 0 === val.length
            ? -1
            : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        if ("number" == typeof val)
          return (
            (val &= 255),
            "function" == typeof Uint8Array.prototype.indexOf
              ? (dir
                  ? Uint8Array.prototype.indexOf
                  : Uint8Array.prototype.lastIndexOf
                ).call(buffer, val, byteOffset)
              : arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          );
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1,
          arrLength = arr.length,
          valLength = val.length;
        if (
          void 0 !== encoding &&
          ("ucs2" === (encoding = String(encoding).toLowerCase()) ||
            "ucs-2" === encoding ||
            "utf16le" === encoding ||
            "utf-16le" === encoding)
        ) {
          if (arr.length < 2 || val.length < 2) return -1;
          (indexSize = 2),
            (arrLength /= 2),
            (valLength /= 2),
            (byteOffset /= 2);
        }
        function read(buf, i) {
          return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++)
            if (
              read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)
            ) {
              if (
                (-1 === foundIndex && (foundIndex = i),
                i - foundIndex + 1 === valLength)
              )
                return foundIndex * indexSize;
            } else
              -1 !== foundIndex && (i -= i - foundIndex), (foundIndex = -1);
        } else
          for (
            byteOffset + valLength > arrLength &&
              (byteOffset = arrLength - valLength),
              i = byteOffset;
            0 <= i;
            i--
          ) {
            let found = !0;
            for (let j = 0; j < valLength; j++)
              if (read(arr, i + j) !== read(val, j)) {
                found = !1;
                break;
              }
            if (found) return i;
          }
        return -1;
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(
          (function asciiToBytes(str) {
            var byteArray = [];
            for (let i = 0; i < str.length; ++i)
              byteArray.push(255 & str.charCodeAt(i));
            return byteArray;
          })(string),
          buf,
          offset,
          length
        );
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(
          (function utf16leToBytes(str, units) {
            var c, hi;
            var byteArray = [];
            for (let i = 0; i < str.length && !((units -= 2) < 0); ++i)
              (c = str.charCodeAt(i)),
                (hi = c >> 8),
                byteArray.push(c % 256),
                byteArray.push(hi);
            return byteArray;
          })(string, buf.length - offset),
          buf,
          offset,
          length
        );
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        let i = start;
        for (; i < end; ) {
          var firstByte = buf[i];
          let codePoint = null,
            bytesPerSequence =
              239 < firstByte
                ? 4
                : 223 < firstByte
                ? 3
                : 191 < firstByte
                ? 2
                : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                firstByte < 128 && (codePoint = firstByte);
                break;
              case 2:
                128 == (192 & (secondByte = buf[i + 1])) &&
                  127 <
                    (tempCodePoint =
                      ((31 & firstByte) << 6) | (63 & secondByte)) &&
                  (codePoint = tempCodePoint);
                break;
              case 3:
                (secondByte = buf[i + 1]),
                  (thirdByte = buf[i + 2]),
                  128 == (192 & secondByte) &&
                    128 == (192 & thirdByte) &&
                    2047 <
                      (tempCodePoint =
                        ((15 & firstByte) << 12) |
                        ((63 & secondByte) << 6) |
                        (63 & thirdByte)) &&
                    (tempCodePoint < 55296 || 57343 < tempCodePoint) &&
                    (codePoint = tempCodePoint);
                break;
              case 4:
                (secondByte = buf[i + 1]),
                  (thirdByte = buf[i + 2]),
                  (fourthByte = buf[i + 3]),
                  128 == (192 & secondByte) &&
                    128 == (192 & thirdByte) &&
                    128 == (192 & fourthByte) &&
                    65535 <
                      (tempCodePoint =
                        ((15 & firstByte) << 18) |
                        ((63 & secondByte) << 12) |
                        ((63 & thirdByte) << 6) |
                        (63 & fourthByte)) &&
                    tempCodePoint < 1114112 &&
                    (codePoint = tempCodePoint);
            }
          }
          null === codePoint
            ? ((codePoint = 65533), (bytesPerSequence = 1))
            : 65535 < codePoint &&
              ((codePoint -= 65536),
              res.push(((codePoint >>> 10) & 1023) | 55296),
              (codePoint = 56320 | (1023 & codePoint))),
            res.push(codePoint),
            (i += bytesPerSequence);
        }
        return (function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH)
            return String.fromCharCode.apply(String, codePoints);
          let res = "",
            i = 0;
          for (; i < len; )
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
            );
          return res;
        })(res);
      }
      (exports.kMaxLength = K_MAX_LENGTH),
        (Buffer.TYPED_ARRAY_SUPPORT = (function typedArraySupport() {
          try {
            var arr = new Uint8Array(1),
              proto = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(proto, Uint8Array.prototype),
              Object.setPrototypeOf(arr, proto),
              42 === arr.foo()
            );
          } catch (e) {
            return !1;
          }
        })()) ||
          "undefined" == typeof console ||
          "function" != typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(Buffer.prototype, "parent", {
          enumerable: !0,
          get: function () {
            if (Buffer.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(Buffer.prototype, "offset", {
          enumerable: !0,
          get: function () {
            if (Buffer.isBuffer(this)) return this.byteOffset;
          },
        }),
        (Buffer.poolSize = 8192),
        (Buffer.from = from),
        Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(Buffer, Uint8Array),
        (Buffer.alloc = function alloc(size, fill, encoding) {
          return (
            assertSize(size),
            !(size <= 0) && void 0 !== fill
              ? "string" == typeof encoding
                ? createBuffer(size).fill(fill, encoding)
                : createBuffer(size).fill(fill)
              : createBuffer(size)
          );
        }),
        (Buffer.allocUnsafe = allocUnsafe),
        (Buffer.allocUnsafeSlow = allocUnsafe),
        (Buffer.isBuffer = function isBuffer(b) {
          return null != b && !0 === b._isBuffer && b !== Buffer.prototype;
        }),
        (Buffer.compare = function compare(a, b) {
          if (
            (isInstance(a, Uint8Array) &&
              (a = Buffer.from(a, a.offset, a.byteLength)),
            isInstance(b, Uint8Array) &&
              (b = Buffer.from(b, b.offset, b.byteLength)),
            !Buffer.isBuffer(a) || !Buffer.isBuffer(b))
          )
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (a === b) return 0;
          let x = a.length,
            y = b.length;
          for (let i = 0, len = Math.min(x, y); i < len; ++i)
            if (a[i] !== b[i]) {
              (x = a[i]), (y = b[i]);
              break;
            }
          return x < y ? -1 : y < x ? 1 : 0;
        }),
        (Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === list.length) return Buffer.alloc(0);
          let i;
          if (void 0 === length)
            for (length = 0, i = 0; i < list.length; ++i)
              length += list[i].length;
          var buffer = Buffer.allocUnsafe(length);
          let pos = 0;
          for (i = 0; i < list.length; ++i) {
            let buf = list[i];
            if (isInstance(buf, Uint8Array))
              pos + buf.length > buffer.length
                ? (buf = Buffer.isBuffer(buf) ? buf : Buffer.from(buf)).copy(
                    buffer,
                    pos
                  )
                : Uint8Array.prototype.set.call(buffer, buf, pos);
            else {
              if (!Buffer.isBuffer(buf))
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              buf.copy(buffer, pos);
            }
            pos += buf.length;
          }
          return buffer;
        }),
        (Buffer.byteLength = byteLength),
        (Buffer.prototype._isBuffer = !0),
        (Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let i = 0; i < len; i += 2) swap(this, i, i + 1);
          return this;
        }),
        (Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let i = 0; i < len; i += 4)
            swap(this, i, i + 3), swap(this, i + 1, i + 2);
          return this;
        }),
        (Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let i = 0; i < len; i += 8)
            swap(this, i, i + 7),
              swap(this, i + 1, i + 6),
              swap(this, i + 2, i + 5),
              swap(this, i + 3, i + 4);
          return this;
        }),
        (Buffer.prototype.toLocaleString = Buffer.prototype.toString =
          function toString() {
            var length = this.length;
            return 0 === length
              ? ""
              : 0 === arguments.length
              ? utf8Slice(this, 0, length)
              : slowToString.apply(this, arguments);
          }),
        (Buffer.prototype.equals = function equals(b) {
          if (Buffer.isBuffer(b))
            return this === b || 0 === Buffer.compare(this, b);
          throw new TypeError("Argument must be a Buffer");
        }),
        (Buffer.prototype.inspect = function inspect() {
          let str = "";
          var max = exports.INSPECT_MAX_BYTES;
          return (
            (str = this.toString("hex", 0, max)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > max && (str += " ... "),
            "<Buffer " + str + ">"
          );
        }),
        __webpack_require__ &&
          (Buffer.prototype[__webpack_require__] = Buffer.prototype.inspect),
        (Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd
        ) {
          if (
            (isInstance(target, Uint8Array) &&
              (target = Buffer.from(target, target.offset, target.byteLength)),
            !Buffer.isBuffer(target))
          )
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof target
            );
          if (
            (void 0 === end && (end = target ? target.length : 0),
            void 0 === thisStart && (thisStart = 0),
            void 0 === thisEnd && (thisEnd = this.length),
            (start = void 0 === start ? 0 : start) < 0 ||
              end > target.length ||
              thisStart < 0 ||
              thisEnd > this.length)
          )
            throw new RangeError("out of range index");
          if (thisEnd <= thisStart && end <= start) return 0;
          if (thisEnd <= thisStart) return -1;
          if (end <= start) return 1;
          if (this === target) return 0;
          let x = (thisEnd >>>= 0) - (thisStart >>>= 0),
            y = (end >>>= 0) - (start >>>= 0);
          var len = Math.min(x, y),
            thisCopy = this.slice(thisStart, thisEnd),
            targetCopy = target.slice(start, end);
          for (let i = 0; i < len; ++i)
            if (thisCopy[i] !== targetCopy[i]) {
              (x = thisCopy[i]), (y = targetCopy[i]);
              break;
            }
          return x < y ? -1 : y < x ? 1 : 0;
        }),
        (Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding
        ) {
          return -1 !== this.indexOf(val, byteOffset, encoding);
        }),
        (Buffer.prototype.indexOf = function indexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
        }),
        (Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
        }),
        (Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding
        ) {
          if (void 0 === offset)
            (encoding = "utf8"), (length = this.length), (offset = 0);
          else if (void 0 === length && "string" == typeof offset)
            (encoding = offset), (length = this.length), (offset = 0);
          else {
            if (!isFinite(offset))
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            (offset >>>= 0),
              isFinite(length)
                ? ((length >>>= 0), void 0 === encoding && (encoding = "utf8"))
                : ((encoding = length), (length = void 0));
          }
          var remaining = this.length - offset;
          if (
            ((void 0 === length || remaining < length) && (length = remaining),
            (0 < string.length && (length < 0 || offset < 0)) ||
              offset > this.length)
          )
            throw new RangeError("Attempt to write outside buffer bounds");
          encoding = encoding || "utf8";
          let loweredCase = !1;
          for (;;)
            switch (encoding) {
              case "hex":
                return (function hexWrite(buf, string, offset, length) {
                  offset = Number(offset) || 0;
                  var remaining = buf.length - offset;
                  (!length || remaining < (length = Number(length))) &&
                    (length = remaining),
                    (remaining = string.length) / 2 < length &&
                      (length = remaining / 2);
                  let i;
                  for (i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(2 * i, 2), 16);
                    if (numberIsNaN(parsed)) return i;
                    buf[offset + i] = parsed;
                  }
                  return i;
                })(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return (function utf8Write(buf, string, offset, length) {
                  return blitBuffer(
                    utf8ToBytes(string, buf.length - offset),
                    buf,
                    offset,
                    length
                  );
                })(this, string, offset, length);
              case "ascii":
              case "latin1":
              case "binary":
                return asciiWrite(this, string, offset, length);
              case "base64":
                return (function base64Write(buf, string, offset, length) {
                  return blitBuffer(base64ToBytes(string), buf, offset, length);
                })(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                (encoding = ("" + encoding).toLowerCase()), (loweredCase = !0);
            }
        }),
        (Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        });
      const MAX_ARGUMENTS_LENGTH = 4096;
      function checkOffset(offset, ext, length) {
        if (offset % 1 != 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (length < offset + ext)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (max < value || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        (min = Number(value & BigInt(4294967295))),
          (buf[offset++] = min),
          (buf[offset++] = min >>= 8),
          (buf[offset++] = min >>= 8),
          (buf[offset++] = min >>= 8),
          (max = Number((value >> BigInt(32)) & BigInt(4294967295)));
        return (
          (buf[offset++] = max),
          (buf[offset++] = max >>= 8),
          (buf[offset++] = max >>= 8),
          (buf[offset++] = max >>= 8),
          offset
        );
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        (min = Number(value & BigInt(4294967295))),
          (buf[offset + 7] = min),
          (buf[offset + 6] = min >>= 8),
          (buf[offset + 5] = min >>= 8),
          (buf[offset + 4] = min >>= 8),
          (max = Number((value >> BigInt(32)) & BigInt(4294967295)));
        return (
          (buf[offset + 3] = max),
          (buf[offset + 2] = max >>= 8),
          (buf[offset + 1] = max >>= 8),
          (buf[offset] = max >>= 8),
          offset + 8
        );
      }
      function checkIEEE754(buf, value, offset, ext) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        return (
          (value = +value),
          (offset >>>= 0),
          noAssert || checkIEEE754(buf, 0, offset, 4),
          ieee754.write(buf, value, offset, littleEndian, 23, 4),
          offset + 4
        );
      }
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        return (
          (value = +value),
          (offset >>>= 0),
          noAssert || checkIEEE754(buf, 0, offset, 8),
          ieee754.write(buf, value, offset, littleEndian, 52, 8),
          offset + 8
        );
      }
      (Buffer.prototype.slice = function slice(start, end) {
        var len = this.length,
          len =
            ((start = ~~start) < 0
              ? (start += len) < 0 && (start = 0)
              : len < start && (start = len),
            (end = void 0 === end ? len : ~~end) < 0
              ? (end += len) < 0 && (end = 0)
              : len < end && (end = len),
            end < start && (end = start),
            this.subarray(start, end));
        return Object.setPrototypeOf(len, Buffer.prototype), len;
      }),
        (Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE =
          function readUIntLE(offset, byteLength, noAssert) {
            (offset >>>= 0),
              (byteLength >>>= 0),
              noAssert || checkOffset(offset, byteLength, this.length);
            let val = this[offset],
              mul = 1,
              i = 0;
            for (; ++i < byteLength && (mul *= 256); )
              val += this[offset + i] * mul;
            return val;
          }),
        (Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE =
          function readUIntBE(offset, byteLength, noAssert) {
            (offset >>>= 0),
              (byteLength >>>= 0),
              noAssert || checkOffset(offset, byteLength, this.length);
            let val = this[offset + --byteLength],
              mul = 1;
            for (; 0 < byteLength && (mul *= 256); )
              val += this[offset + --byteLength] * mul;
            return val;
          }),
        (Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 =
          function readUInt8(offset, noAssert) {
            return (
              (offset >>>= 0),
              noAssert || checkOffset(offset, 1, this.length),
              this[offset]
            );
          }),
        (Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE =
          function readUInt16LE(offset, noAssert) {
            return (
              (offset >>>= 0),
              noAssert || checkOffset(offset, 2, this.length),
              this[offset] | (this[offset + 1] << 8)
            );
          }),
        (Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE =
          function readUInt16BE(offset, noAssert) {
            return (
              (offset >>>= 0),
              noAssert || checkOffset(offset, 2, this.length),
              (this[offset] << 8) | this[offset + 1]
            );
          }),
        (Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE =
          function readUInt32LE(offset, noAssert) {
            return (
              (offset >>>= 0),
              noAssert || checkOffset(offset, 4, this.length),
              (this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
                16777216 * this[offset + 3]
            );
          }),
        (Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE =
          function readUInt32BE(offset, noAssert) {
            return (
              (offset >>>= 0),
              noAssert || checkOffset(offset, 4, this.length),
              16777216 * this[offset] +
                ((this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3])
            );
          }),
        (Buffer.prototype.readBigUInt64LE = defineBigIntMethod(
          function readBigUInt64LE(offset) {
            validateNumber((offset >>>= 0), "offset");
            var first = this[offset],
              last = this[offset + 7],
              first =
                ((void 0 !== first && void 0 !== last) ||
                  boundsError(offset, this.length - 8),
                first +
                  256 * this[++offset] +
                  65536 * this[++offset] +
                  this[++offset] * 2 ** 24),
              offset =
                this[++offset] +
                256 * this[++offset] +
                65536 * this[++offset] +
                last * 2 ** 24;
            return BigInt(first) + (BigInt(offset) << BigInt(32));
          }
        )),
        (Buffer.prototype.readBigUInt64BE = defineBigIntMethod(
          function readBigUInt64BE(offset) {
            validateNumber((offset >>>= 0), "offset");
            var first = this[offset],
              last = this[offset + 7],
              first =
                ((void 0 !== first && void 0 !== last) ||
                  boundsError(offset, this.length - 8),
                first * 2 ** 24 +
                  65536 * this[++offset] +
                  256 * this[++offset] +
                  this[++offset]),
              offset =
                this[++offset] * 2 ** 24 +
                65536 * this[++offset] +
                256 * this[++offset] +
                last;
            return (BigInt(first) << BigInt(32)) + BigInt(offset);
          }
        )),
        (Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          (offset >>>= 0),
            (byteLength >>>= 0),
            noAssert || checkOffset(offset, byteLength, this.length);
          let val = this[offset],
            mul = 1,
            i = 0;
          for (; ++i < byteLength && (mul *= 256); )
            val += this[offset + i] * mul;
          return (
            (mul *= 128),
            val >= mul && (val -= Math.pow(2, 8 * byteLength)),
            val
          );
        }),
        (Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          (offset >>>= 0),
            (byteLength >>>= 0),
            noAssert || checkOffset(offset, byteLength, this.length);
          let i = byteLength,
            mul = 1,
            val = this[offset + --i];
          for (; 0 < i && (mul *= 256); ) val += this[offset + --i] * mul;
          return (
            (mul *= 128),
            val >= mul && (val -= Math.pow(2, 8 * byteLength)),
            val
          );
        }),
        (Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 1, this.length),
            128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset]
          );
        }),
        (Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          (offset >>>= 0), noAssert || checkOffset(offset, 2, this.length);
          noAssert = this[offset] | (this[offset + 1] << 8);
          return 32768 & noAssert ? 4294901760 | noAssert : noAssert;
        }),
        (Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          (offset >>>= 0), noAssert || checkOffset(offset, 2, this.length);
          noAssert = this[offset + 1] | (this[offset] << 8);
          return 32768 & noAssert ? 4294901760 | noAssert : noAssert;
        }),
        (Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 4, this.length),
            this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16) |
              (this[offset + 3] << 24)
          );
        }),
        (Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 4, this.length),
            (this[offset] << 24) |
              (this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3]
          );
        }),
        (Buffer.prototype.readBigInt64LE = defineBigIntMethod(
          function readBigInt64LE(offset) {
            validateNumber((offset >>>= 0), "offset");
            var first = this[offset],
              last = this[offset + 7],
              last =
                ((void 0 !== first && void 0 !== last) ||
                  boundsError(offset, this.length - 8),
                this[offset + 4] +
                  256 * this[offset + 5] +
                  65536 * this[offset + 6] +
                  (last << 24));
            return (
              (BigInt(last) << BigInt(32)) +
              BigInt(
                first +
                  256 * this[++offset] +
                  65536 * this[++offset] +
                  this[++offset] * 2 ** 24
              )
            );
          }
        )),
        (Buffer.prototype.readBigInt64BE = defineBigIntMethod(
          function readBigInt64BE(offset) {
            validateNumber((offset >>>= 0), "offset");
            var first = this[offset],
              last = this[offset + 7],
              first =
                ((void 0 !== first && void 0 !== last) ||
                  boundsError(offset, this.length - 8),
                (first << 24) +
                  65536 * this[++offset] +
                  256 * this[++offset] +
                  this[++offset]);
            return (
              (BigInt(first) << BigInt(32)) +
              BigInt(
                this[++offset] * 2 ** 24 +
                  65536 * this[++offset] +
                  256 * this[++offset] +
                  last
              )
            );
          }
        )),
        (Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 4, this.length),
            ieee754.read(this, offset, !0, 23, 4)
          );
        }),
        (Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 4, this.length),
            ieee754.read(this, offset, !1, 23, 4)
          );
        }),
        (Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert
        ) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 8, this.length),
            ieee754.read(this, offset, !0, 52, 8)
          );
        }),
        (Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert
        ) {
          return (
            (offset >>>= 0),
            noAssert || checkOffset(offset, 8, this.length),
            ieee754.read(this, offset, !1, 52, 8)
          );
        }),
        (Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE =
          function writeUIntLE(value, offset, byteLength, noAssert) {
            (value = +value),
              (offset >>>= 0),
              (byteLength >>>= 0),
              noAssert ||
                checkInt(
                  this,
                  value,
                  offset,
                  byteLength,
                  Math.pow(2, 8 * byteLength) - 1,
                  0
                );
            let mul = 1,
              i = 0;
            for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); )
              this[offset + i] = (value / mul) & 255;
            return offset + byteLength;
          }),
        (Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE =
          function writeUIntBE(value, offset, byteLength, noAssert) {
            (value = +value),
              (offset >>>= 0),
              (byteLength >>>= 0),
              noAssert ||
                checkInt(
                  this,
                  value,
                  offset,
                  byteLength,
                  Math.pow(2, 8 * byteLength) - 1,
                  0
                );
            let i = byteLength - 1,
              mul = 1;
            for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); )
              this[offset + i] = (value / mul) & 255;
            return offset + byteLength;
          }),
        (Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 =
          function writeUInt8(value, offset, noAssert) {
            return (
              (value = +value),
              (offset >>>= 0),
              noAssert || checkInt(this, value, offset, 1, 255, 0),
              (this[offset] = 255 & value),
              offset + 1
            );
          }),
        (Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE =
          function writeUInt16LE(value, offset, noAssert) {
            return (
              (value = +value),
              (offset >>>= 0),
              noAssert || checkInt(this, value, offset, 2, 65535, 0),
              (this[offset] = 255 & value),
              (this[offset + 1] = value >>> 8),
              offset + 2
            );
          }),
        (Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE =
          function writeUInt16BE(value, offset, noAssert) {
            return (
              (value = +value),
              (offset >>>= 0),
              noAssert || checkInt(this, value, offset, 2, 65535, 0),
              (this[offset] = value >>> 8),
              (this[offset + 1] = 255 & value),
              offset + 2
            );
          }),
        (Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE =
          function writeUInt32LE(value, offset, noAssert) {
            return (
              (value = +value),
              (offset >>>= 0),
              noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
              (this[offset + 3] = value >>> 24),
              (this[offset + 2] = value >>> 16),
              (this[offset + 1] = value >>> 8),
              (this[offset] = 255 & value),
              offset + 4
            );
          }),
        (Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE =
          function writeUInt32BE(value, offset, noAssert) {
            return (
              (value = +value),
              (offset >>>= 0),
              noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
              (this[offset] = value >>> 24),
              (this[offset + 1] = value >>> 16),
              (this[offset + 2] = value >>> 8),
              (this[offset + 3] = 255 & value),
              offset + 4
            );
          }),
        (Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(
          function writeBigUInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff")
            );
          }
        )),
        (Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(
          function writeBigUInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff")
            );
          }
        )),
        (Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          (value = +value),
            (offset >>>= 0),
            noAssert ||
              checkInt(
                this,
                value,
                offset,
                byteLength,
                (noAssert = Math.pow(2, 8 * byteLength - 1)) - 1,
                -noAssert
              );
          let i = 0,
            mul = 1,
            sub = 0;
          for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); )
            value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1),
              (this[offset + i] = (((value / mul) >> 0) - sub) & 255);
          return offset + byteLength;
        }),
        (Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          (value = +value),
            (offset >>>= 0),
            noAssert ||
              checkInt(
                this,
                value,
                offset,
                byteLength,
                (noAssert = Math.pow(2, 8 * byteLength - 1)) - 1,
                -noAssert
              );
          let i = byteLength - 1,
            mul = 1,
            sub = 0;
          for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); )
            value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1),
              (this[offset + i] = (((value / mul) >> 0) - sub) & 255);
          return offset + byteLength;
        }),
        (Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert
        ) {
          return (
            (value = +value),
            (offset >>>= 0),
            noAssert || checkInt(this, value, offset, 1, 127, -128),
            (this[offset] =
              255 & (value = value < 0 ? 255 + value + 1 : value)),
            offset + 1
          );
        }),
        (Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert
        ) {
          return (
            (value = +value),
            (offset >>>= 0),
            noAssert || checkInt(this, value, offset, 2, 32767, -32768),
            (this[offset] = 255 & value),
            (this[offset + 1] = value >>> 8),
            offset + 2
          );
        }),
        (Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert
        ) {
          return (
            (value = +value),
            (offset >>>= 0),
            noAssert || checkInt(this, value, offset, 2, 32767, -32768),
            (this[offset] = value >>> 8),
            (this[offset + 1] = 255 & value),
            offset + 2
          );
        }),
        (Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert
        ) {
          return (
            (value = +value),
            (offset >>>= 0),
            noAssert ||
              checkInt(this, value, offset, 4, 2147483647, -2147483648),
            (this[offset] = 255 & value),
            (this[offset + 1] = value >>> 8),
            (this[offset + 2] = value >>> 16),
            (this[offset + 3] = value >>> 24),
            offset + 4
          );
        }),
        (Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert
        ) {
          return (
            (value = +value),
            (offset >>>= 0),
            noAssert ||
              checkInt(this, value, offset, 4, 2147483647, -2147483648),
            (this[offset] =
              (value = value < 0 ? 4294967295 + value + 1 : value) >>> 24),
            (this[offset + 1] = value >>> 16),
            (this[offset + 2] = value >>> 8),
            (this[offset + 3] = 255 & value),
            offset + 4
          );
        }),
        (Buffer.prototype.writeBigInt64LE = defineBigIntMethod(
          function writeBigInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(
              this,
              value,
              offset,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff")
            );
          }
        )),
        (Buffer.prototype.writeBigInt64BE = defineBigIntMethod(
          function writeBigInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(
              this,
              value,
              offset,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff")
            );
          }
        )),
        (Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, !0, noAssert);
        }),
        (Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, !1, noAssert);
        }),
        (Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, !0, noAssert);
        }),
        (Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, !1, noAssert);
        }),
        (Buffer.prototype.copy = function copy(
          target,
          targetStart,
          start,
          end
        ) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer");
          if (
            ((start = start || 0),
            end || 0 === end || (end = this.length),
            targetStart >= target.length && (targetStart = target.length),
            (end = 0 < end && end < start ? start : end) === start)
          )
            return 0;
          if (0 === target.length || 0 === this.length) return 0;
          if ((targetStart = targetStart || 0) < 0)
            throw new RangeError("targetStart out of bounds");
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          end > this.length && (end = this.length);
          var len =
            (end =
              target.length - targetStart < end - start
                ? target.length - targetStart + start
                : end) - start;
          return (
            this === target &&
            "function" == typeof Uint8Array.prototype.copyWithin
              ? this.copyWithin(targetStart, start, end)
              : Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                ),
            len
          );
        }),
        (Buffer.prototype.fill = function fill(val, start, end, encoding) {
          if ("string" == typeof val) {
            if (
              ("string" == typeof start
                ? ((encoding = start), (start = 0), (end = this.length))
                : "string" == typeof end &&
                  ((encoding = end), (end = this.length)),
              void 0 !== encoding && "string" != typeof encoding)
            )
              throw new TypeError("encoding must be a string");
            if ("string" == typeof encoding && !Buffer.isEncoding(encoding))
              throw new TypeError("Unknown encoding: " + encoding);
            var code;
            1 === val.length &&
              ((code = val.charCodeAt(0)),
              ("utf8" === encoding && code < 128) || "latin1" === encoding) &&
              (val = code);
          } else
            "number" == typeof val
              ? (val &= 255)
              : "boolean" == typeof val && (val = Number(val));
          if (start < 0 || this.length < start || this.length < end)
            throw new RangeError("Out of range index");
          if (!(end <= start)) {
            (start >>>= 0), (end = void 0 === end ? this.length : end >>> 0);
            let i;
            if ("number" == typeof (val = val || 0))
              for (i = start; i < end; ++i) this[i] = val;
            else {
              var bytes = Buffer.isBuffer(val)
                  ? val
                  : Buffer.from(val, encoding),
                len = bytes.length;
              if (0 === len)
                throw new TypeError(
                  'The value "' + val + '" is invalid for argument "value"'
                );
              for (i = 0; i < end - start; ++i)
                this[i + start] = bytes[i % len];
            }
          }
          return this;
        });
      const errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super(),
              Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: !0,
                configurable: !0,
              }),
              (this.name = this.name + ` [${sym}]`),
              this.stack,
              delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: value,
              writable: !0,
            });
          }
          toString() {
            return this.name + ` [${sym}]: ` + this.message;
          }
        };
      }
      function addNumericalSeparator(val) {
        let res = "",
          i = val.length;
        for (var start = "-" === val[0] ? 1 : 0; i >= 4 + start; i -= 3)
          res = "_" + val.slice(i - 3, i) + res;
        return "" + val.slice(0, i) + res;
      }
      function checkIntBI(value, min, max, buf, offset, byteLength) {
        if (max < value || value < min) {
          var n = "bigint" == typeof min ? "n" : "";
          let range;
          throw (
            ((range =
              3 < byteLength
                ? 0 === min || min === BigInt(0)
                  ? `>= 0${n} and < 2${n} ** ` + 8 * (byteLength + 1) + n
                  : `>= -(2${n} ** ${
                      8 * (byteLength + 1) - 1
                    }${n}) and < 2 ** ` +
                    (8 * (byteLength + 1) - 1) +
                    n
                : `>= ${min}${n} and <= ` + max + n),
            new errors.ERR_OUT_OF_RANGE("value", range, value))
          );
        }
        !(function checkBounds(buf, offset, byteLength) {
          validateNumber(offset, "offset"),
            (void 0 !== buf[offset] && void 0 !== buf[offset + byteLength]) ||
              boundsError(offset, buf.length - (byteLength + 1));
        })(buf, offset, byteLength);
      }
      function validateNumber(value, name) {
        if ("number" != typeof value)
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value)
          throw (
            (validateNumber(value, type),
            new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value))
          );
        if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ` + length,
          value
        );
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function (name) {
          return name
            ? name + " is outside of buffer bounds"
            : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ),
        E(
          "ERR_INVALID_ARG_TYPE",
          function (name, actual) {
            return (
              `The "${name}" argument must be of type number. Received type ` +
              typeof actual
            );
          },
          TypeError
        ),
        E(
          "ERR_OUT_OF_RANGE",
          function (str, range, input) {
            str = `The value of "${str}" is out of range.`;
            let received = input;
            return (
              Number.isInteger(input) && Math.abs(input) > 2 ** 32
                ? (received = addNumericalSeparator(String(input)))
                : "bigint" == typeof input &&
                  ((received = String(input)),
                  (input > BigInt(2) ** BigInt(32) ||
                    input < -(BigInt(2) ** BigInt(32))) &&
                    (received = addNumericalSeparator(received)),
                  (received += "n")),
              (str += ` It must be ${range}. Received ` + received)
            );
          },
          RangeError
        );
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function utf8ToBytes(string, units) {
        units = units || 1 / 0;
        let codePoint;
        var length = string.length;
        let leadSurrogate = null;
        var bytes = [];
        for (let i = 0; i < length; ++i) {
          if (55295 < (codePoint = string.charCodeAt(i)) && codePoint < 57344) {
            if (!leadSurrogate) {
              if (56319 < codePoint) {
                -1 < (units -= 3) && bytes.push(239, 191, 189);
                continue;
              }
              if (i + 1 === length) {
                -1 < (units -= 3) && bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              -1 < (units -= 3) && bytes.push(239, 191, 189),
                (leadSurrogate = codePoint);
              continue;
            }
            codePoint =
              65536 + (((leadSurrogate - 55296) << 10) | (codePoint - 56320));
          } else
            leadSurrogate && -1 < (units -= 3) && bytes.push(239, 191, 189);
          if (((leadSurrogate = null), codePoint < 128)) {
            if (--units < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push((codePoint >> 6) | 192, (63 & codePoint) | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              (codePoint >> 12) | 224,
              ((codePoint >> 6) & 63) | 128,
              (63 & codePoint) | 128
            );
          } else {
            if (!(codePoint < 1114112)) throw new Error("Invalid code point");
            if ((units -= 4) < 0) break;
            bytes.push(
              (codePoint >> 18) | 240,
              ((codePoint >> 12) & 63) | 128,
              ((codePoint >> 6) & 63) | 128,
              (63 & codePoint) | 128
            );
          }
        }
        return bytes;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(
          (function base64clean(str) {
            if (
              (str = (str = str.split("=")[0])
                .trim()
                .replace(INVALID_BASE64_RE, "")).length < 2
            )
              return "";
            for (; str.length % 4 != 0; ) str += "=";
            return str;
          })(str)
        );
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (
          i = 0;
          i < length && !(i + offset >= dst.length || i >= src.length);
          ++i
        )
          dst[i + offset] = src[i];
        return i;
      }
      function isInstance(obj, type) {
        return (
          obj instanceof type ||
          (null != obj &&
            null != obj.constructor &&
            null != obj.constructor.name &&
            obj.constructor.name === type.name)
        );
      }
      function numberIsNaN(obj) {
        return obj != obj;
      }
      const hexSliceLookupTable = (function () {
        var table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          var i16 = 16 * i;
          for (let j = 0; j < 16; ++j)
            table[i16 + j] = "0123456789abcdef"[i] + "0123456789abcdef"[j];
        }
        return table;
      })();
      function defineBigIntMethod(fn) {
        return "undefined" == typeof BigInt ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    },
    6805: function (module, exports) {
      var global = "undefined" != typeof self ? self : this,
        __self__ = ((F.prototype = global), new F());
      function F() {
        (this.fetch = !1), (this.DOMException = global.DOMException);
      }
      !(function (self) {
        !(function (exports) {
          var viewClasses,
            isArrayBufferView,
            support_searchParams = "URLSearchParams" in self,
            support_iterable = "Symbol" in self && "iterator" in Symbol,
            support_blob =
              "FileReader" in self &&
              "Blob" in self &&
              (function () {
                try {
                  return new Blob(), !0;
                } catch (e) {
                  return !1;
                }
              })(),
            support_formData = "FormData" in self,
            support_arrayBuffer = "ArrayBuffer" in self;
          function normalizeName(name) {
            if (
              ("string" != typeof name && (name = String(name)),
              /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name))
            )
              throw new TypeError("Invalid character in header field name");
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            return (value = "string" != typeof value ? String(value) : value);
          }
          function iteratorFor(items) {
            var iterator = {
              next: function () {
                var value = items.shift();
                return { done: void 0 === value, value: value };
              },
            };
            return (
              support_iterable &&
                (iterator[Symbol.iterator] = function () {
                  return iterator;
                }),
              iterator
            );
          }
          function Headers(headers) {
            (this.map = {}),
              headers instanceof Headers
                ? headers.forEach(function (value, name) {
                    this.append(name, value);
                  }, this)
                : Array.isArray(headers)
                ? headers.forEach(function (header) {
                    this.append(header[0], header[1]);
                  }, this)
                : headers &&
                  Object.getOwnPropertyNames(headers).forEach(function (name) {
                    this.append(name, headers[name]);
                  }, this);
          }
          function consumed(body) {
            if (body.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            body.bodyUsed = !0;
          }
          function fileReaderReady(reader) {
            return new Promise(function (resolve, reject) {
              (reader.onload = function () {
                resolve(reader.result);
              }),
                (reader.onerror = function () {
                  reject(reader.error);
                });
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader(),
              promise = fileReaderReady(reader);
            return reader.readAsArrayBuffer(blob), promise;
          }
          function bufferClone(buf) {
            var view;
            return buf.slice
              ? buf.slice(0)
              : ((view = new Uint8Array(buf.byteLength)).set(
                  new Uint8Array(buf)
                ),
                view.buffer);
          }
          function Body() {
            return (
              (this.bodyUsed = !1),
              (this._initBody = function (body) {
                (this._bodyInit = body)
                  ? "string" == typeof body
                    ? (this._bodyText = body)
                    : support_blob && Blob.prototype.isPrototypeOf(body)
                    ? (this._bodyBlob = body)
                    : support_formData && FormData.prototype.isPrototypeOf(body)
                    ? (this._bodyFormData = body)
                    : support_searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(body)
                    ? (this._bodyText = body.toString())
                    : support_arrayBuffer &&
                      support_blob &&
                      (function isDataView(obj) {
                        return obj && DataView.prototype.isPrototypeOf(obj);
                      })(body)
                    ? ((this._bodyArrayBuffer = bufferClone(body.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : support_arrayBuffer &&
                      (ArrayBuffer.prototype.isPrototypeOf(body) ||
                        isArrayBufferView(body))
                    ? (this._bodyArrayBuffer = bufferClone(body))
                    : (this._bodyText = body =
                        Object.prototype.toString.call(body))
                  : (this._bodyText = ""),
                  this.headers.get("content-type") ||
                    ("string" == typeof body
                      ? this.headers.set(
                          "content-type",
                          "text/plain;charset=UTF-8"
                        )
                      : this._bodyBlob && this._bodyBlob.type
                      ? this.headers.set("content-type", this._bodyBlob.type)
                      : support_searchParams &&
                        URLSearchParams.prototype.isPrototypeOf(body) &&
                        this.headers.set(
                          "content-type",
                          "application/x-www-form-urlencoded;charset=UTF-8"
                        ));
              }),
              support_blob &&
                ((this.blob = function () {
                  var rejected = consumed(this);
                  if (rejected) return rejected;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as blob");
                  return Promise.resolve(new Blob([this._bodyText]));
                }),
                (this.arrayBuffer = function () {
                  return this._bodyArrayBuffer
                    ? consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                    : this.blob().then(readBlobAsArrayBuffer);
                })),
              (this.text = function () {
                var rejected = consumed(this);
                if (rejected) return rejected;
                if (this._bodyBlob)
                  return (function readBlobAsText(blob) {
                    var reader = new FileReader(),
                      promise = fileReaderReady(reader);
                    return reader.readAsText(blob), promise;
                  })(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(
                    (function readArrayBufferAsText(buf) {
                      for (
                        var view = new Uint8Array(buf),
                          chars = new Array(view.length),
                          i = 0;
                        i < view.length;
                        i++
                      )
                        chars[i] = String.fromCharCode(view[i]);
                      return chars.join("");
                    })(this._bodyArrayBuffer)
                  );
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as text");
                return Promise.resolve(this._bodyText);
              }),
              support_formData &&
                (this.formData = function () {
                  return this.text().then(decode);
                }),
              (this.json = function () {
                return this.text().then(JSON.parse);
              }),
              this
            );
          }
          support_arrayBuffer &&
            ((viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ]),
            (isArrayBufferView =
              ArrayBuffer.isView ||
              function (obj) {
                return (
                  obj &&
                  -1 < viewClasses.indexOf(Object.prototype.toString.call(obj))
                );
              })),
            (Headers.prototype.append = function (name, value) {
              (name = normalizeName(name)), (value = normalizeValue(value));
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ", " + value : value;
            }),
            (Headers.prototype.delete = function (name) {
              delete this.map[normalizeName(name)];
            }),
            (Headers.prototype.get = function (name) {
              return (
                (name = normalizeName(name)),
                this.has(name) ? this.map[name] : null
              );
            }),
            (Headers.prototype.has = function (name) {
              return this.map.hasOwnProperty(normalizeName(name));
            }),
            (Headers.prototype.set = function (name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            }),
            (Headers.prototype.forEach = function (callback, thisArg) {
              for (var name in this.map)
                this.map.hasOwnProperty(name) &&
                  callback.call(thisArg, this.map[name], name, this);
            }),
            (Headers.prototype.keys = function () {
              var items = [];
              return (
                this.forEach(function (value, name) {
                  items.push(name);
                }),
                iteratorFor(items)
              );
            }),
            (Headers.prototype.values = function () {
              var items = [];
              return (
                this.forEach(function (value) {
                  items.push(value);
                }),
                iteratorFor(items)
              );
            }),
            (Headers.prototype.entries = function () {
              var items = [];
              return (
                this.forEach(function (value, name) {
                  items.push([name, value]);
                }),
                iteratorFor(items)
              );
            }),
            support_iterable &&
              (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function Request(input, options) {
            var body = (options = options || {}).body;
            if (input instanceof Request) {
              if (input.bodyUsed) throw new TypeError("Already read");
              (this.url = input.url),
                (this.credentials = input.credentials),
                options.headers || (this.headers = new Headers(input.headers)),
                (this.method = input.method),
                (this.mode = input.mode),
                (this.signal = input.signal),
                body ||
                  null == input._bodyInit ||
                  ((body = input._bodyInit), (input.bodyUsed = !0));
            } else this.url = String(input);
            if (
              ((this.credentials =
                options.credentials || this.credentials || "same-origin"),
              (!options.headers && this.headers) ||
                (this.headers = new Headers(options.headers)),
              (this.method = (function normalizeMethod(method) {
                var upcased = method.toUpperCase();
                return -1 < methods.indexOf(upcased) ? upcased : method;
              })(options.method || this.method || "GET")),
              (this.mode = options.mode || this.mode || null),
              (this.signal = options.signal || this.signal),
              (this.referrer = null),
              ("GET" === this.method || "HEAD" === this.method) && body)
            )
              throw new TypeError("Body not allowed for GET or HEAD requests");
            this._initBody(body);
          }
          function decode(body) {
            var form = new FormData();
            return (
              body
                .trim()
                .split("&")
                .forEach(function (bytes) {
                  var name;
                  bytes &&
                    ((name = (bytes = bytes.split("="))
                      .shift()
                      .replace(/\+/g, " ")),
                    (bytes = bytes.join("=").replace(/\+/g, " ")),
                    form.append(
                      decodeURIComponent(name),
                      decodeURIComponent(bytes)
                    ));
                }),
              form
            );
          }
          function Response(bodyInit, options) {
            (options = options || {}),
              (this.type = "default"),
              (this.status = void 0 === options.status ? 200 : options.status),
              (this.ok = 200 <= this.status && this.status < 300),
              (this.statusText =
                "statusText" in options ? options.statusText : "OK"),
              (this.headers = new Headers(options.headers)),
              (this.url = options.url || ""),
              this._initBody(bodyInit);
          }
          (Request.prototype.clone = function () {
            return new Request(this, { body: this._bodyInit });
          }),
            Body.call(Request.prototype),
            Body.call(Response.prototype),
            (Response.prototype.clone = function () {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url,
              });
            }),
            (Response.error = function () {
              var response = new Response(null, { status: 0, statusText: "" });
              return (response.type = "error"), response;
            });
          var redirectStatuses = [301, 302, 303, 307, 308];
          (Response.redirect = function (url, status) {
            if (-1 === redirectStatuses.indexOf(status))
              throw new RangeError("Invalid status code");
            return new Response(null, {
              status: status,
              headers: { location: url },
            });
          }),
            (exports.DOMException = self.DOMException);
          try {
            new exports.DOMException();
          } catch (err) {
            (exports.DOMException = function (message, name) {
              (this.message = message), (this.name = name);
              name = Error(message);
              this.stack = name.stack;
            }),
              (exports.DOMException.prototype = Object.create(Error.prototype)),
              (exports.DOMException.prototype.constructor =
                exports.DOMException);
          }
          function fetch(input, init) {
            return new Promise(function (resolve, reject) {
              var request = new Request(input, init);
              if (request.signal && request.signal.aborted)
                return reject(
                  new exports.DOMException("Aborted", "AbortError")
                );
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              (xhr.onload = function () {
                var options = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: (function parseHeaders(rawHeaders) {
                      var headers = new Headers();
                      return (
                        rawHeaders
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split(/\r?\n/)
                          .forEach(function (line) {
                            var line = line.split(":"),
                              key = line.shift().trim();
                            key &&
                              ((line = line.join(":").trim()),
                              headers.append(key, line));
                          }),
                        headers
                      );
                    })(xhr.getAllResponseHeaders() || ""),
                  },
                  body =
                    ((options.url =
                      "responseURL" in xhr
                        ? xhr.responseURL
                        : options.headers.get("X-Request-URL")),
                    "response" in xhr ? xhr.response : xhr.responseText);
                resolve(new Response(body, options));
              }),
                (xhr.onerror = function () {
                  reject(new TypeError("Network request failed"));
                }),
                (xhr.ontimeout = function () {
                  reject(new TypeError("Network request failed"));
                }),
                (xhr.onabort = function () {
                  reject(new exports.DOMException("Aborted", "AbortError"));
                }),
                xhr.open(request.method, request.url, !0),
                "include" === request.credentials
                  ? (xhr.withCredentials = !0)
                  : "omit" === request.credentials &&
                    (xhr.withCredentials = !1),
                "responseType" in xhr &&
                  support_blob &&
                  (xhr.responseType = "blob"),
                request.headers.forEach(function (value, name) {
                  xhr.setRequestHeader(name, value);
                }),
                request.signal &&
                  (request.signal.addEventListener("abort", abortXhr),
                  (xhr.onreadystatechange = function () {
                    4 === xhr.readyState &&
                      request.signal.removeEventListener("abort", abortXhr);
                  })),
                xhr.send(
                  void 0 === request._bodyInit ? null : request._bodyInit
                );
            });
          }
          (fetch.polyfill = !0),
            self.fetch ||
              ((self.fetch = fetch),
              (self.Headers = Headers),
              (self.Request = Request),
              (self.Response = Response)),
            (exports.Headers = Headers),
            (exports.Request = Request),
            (exports.Response = Response),
            (exports.fetch = fetch),
            Object.defineProperty(exports, "__esModule", { value: !0 });
        })({});
      })(__self__),
        (__self__.fetch.ponyfill = !0),
        delete __self__.fetch.polyfill;
      ((exports = __self__.fetch).default = __self__.fetch),
        (exports.fetch = __self__.fetch),
        (exports.Headers = __self__.Headers),
        (exports.Request = __self__.Request),
        (exports.Response = __self__.Response),
        (module.exports = exports);
    },
    792: (module) => {
      "use strict";
      var has = Object.prototype.hasOwnProperty,
        prefix = "~";
      function Events() {}
      function EE(fn, context, once) {
        (this.fn = fn), (this.context = context), (this.once = once || !1);
      }
      function addListener(emitter, event, fn, context, once) {
        if ("function" != typeof fn)
          throw new TypeError("The listener must be a function");
        (fn = new EE(fn, context || emitter, once)),
          (context = prefix ? prefix + event : event);
        return (
          emitter._events[context]
            ? emitter._events[context].fn
              ? (emitter._events[context] = [emitter._events[context], fn])
              : emitter._events[context].push(fn)
            : ((emitter._events[context] = fn), emitter._eventsCount++),
          emitter
        );
      }
      function clearEvent(emitter, evt) {
        0 == --emitter._eventsCount
          ? (emitter._events = new Events())
          : delete emitter._events[evt];
      }
      function EventEmitter() {
        (this._events = new Events()), (this._eventsCount = 0);
      }
      Object.create &&
        ((Events.prototype = Object.create(null)),
        new Events().__proto__ || (prefix = !1)),
        (EventEmitter.prototype.eventNames = function eventNames() {
          var events,
            name,
            names = [];
          if (0 === this._eventsCount) return names;
          for (name in (events = this._events))
            has.call(events, name) && names.push(prefix ? name.slice(1) : name);
          return Object.getOwnPropertySymbols
            ? names.concat(Object.getOwnPropertySymbols(events))
            : names;
        }),
        (EventEmitter.prototype.listeners = function listeners(event) {
          var event = prefix ? prefix + event : event,
            handlers = this._events[event];
          if (!handlers) return [];
          if (handlers.fn) return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)
            ee[i] = handlers[i].fn;
          return ee;
        }),
        (EventEmitter.prototype.listenerCount = function listenerCount(event) {
          (event = prefix ? prefix + event : event),
            (event = this._events[event]);
          return event ? (event.fn ? 1 : event.length) : 0;
        }),
        (EventEmitter.prototype.emit = function emit(
          event,
          a1,
          a2,
          a3,
          a4,
          a5
        ) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return !1;
          var args,
            listeners = this._events[evt],
            len = arguments.length;
          if (listeners.fn) {
            switch (
              (listeners.once &&
                this.removeListener(event, listeners.fn, void 0, !0),
              len)
            ) {
              case 1:
                return listeners.fn.call(listeners.context), !0;
              case 2:
                return listeners.fn.call(listeners.context, a1), !0;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), !0;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), !0;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0;
              case 6:
                return (
                  listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0
                );
            }
            for (i = 1, args = new Array(len - 1); i < len; i++)
              args[i - 1] = arguments[i];
            listeners.fn.apply(listeners.context, args);
          } else
            for (var j, length = listeners.length, i = 0; i < length; i++)
              switch (
                (listeners[i].once &&
                  this.removeListener(event, listeners[i].fn, void 0, !0),
                len)
              ) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++)
                      args[j - 1] = arguments[j];
                  listeners[i].fn.apply(listeners[i].context, args);
              }
          return !0;
        }),
        (EventEmitter.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, !1);
        }),
        (EventEmitter.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, !0);
        }),
        (EventEmitter.prototype.removeListener = function removeListener(
          event,
          fn,
          context,
          once
        ) {
          event = prefix ? prefix + event : event;
          if (this._events[event])
            if (fn) {
              var listeners = this._events[event];
              if (listeners.fn)
                listeners.fn !== fn ||
                  (once && !listeners.once) ||
                  (context && listeners.context !== context) ||
                  clearEvent(this, event);
              else {
                for (
                  var i = 0, events = [], length = listeners.length;
                  i < length;
                  i++
                )
                  (listeners[i].fn !== fn ||
                    (once && !listeners[i].once) ||
                    (context && listeners[i].context !== context)) &&
                    events.push(listeners[i]);
                events.length
                  ? (this._events[event] =
                      1 === events.length ? events[0] : events)
                  : clearEvent(this, event);
              }
            } else clearEvent(this, event);
          return this;
        }),
        (EventEmitter.prototype.removeAllListeners =
          function removeAllListeners(event) {
            return (
              event
                ? ((event = prefix ? prefix + event : event),
                  this._events[event] && clearEvent(this, event))
                : ((this._events = new Events()), (this._eventsCount = 0)),
              this
            );
          }),
        (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
        (EventEmitter.prototype.addListener = EventEmitter.prototype.on),
        (EventEmitter.prefixed = prefix),
        (module.exports = EventEmitter.EventEmitter = EventEmitter);
    },
    6827: (module) => {
      "use strict";
      var R = "object" == typeof Reflect ? Reflect : null,
        ReflectApply =
          R && "function" == typeof R.apply
            ? R.apply
            : function ReflectApply(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args);
              };
      var ReflectOwnKeys =
          R && "function" == typeof R.ownKeys
            ? R.ownKeys
            : Object.getOwnPropertySymbols
            ? function ReflectOwnKeys(target) {
                return Object.getOwnPropertyNames(target).concat(
                  Object.getOwnPropertySymbols(target)
                );
              }
            : function ReflectOwnKeys(target) {
                return Object.getOwnPropertyNames(target);
              },
        NumberIsNaN =
          Number.isNaN ||
          function NumberIsNaN(value) {
            return value != value;
          };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      (module.exports = EventEmitter),
        (module.exports.once = function once(emitter, name) {
          return new Promise(function (resolve, reject) {
            function errorListener(err) {
              emitter.removeListener(name, resolver), reject(err);
            }
            function resolver() {
              "function" == typeof emitter.removeListener &&
                emitter.removeListener("error", errorListener),
                resolve([].slice.call(arguments));
            }
            eventTargetAgnosticAddListener(emitter, name, resolver, {
              once: !0,
            }),
              "error" !== name &&
                (function addErrorHandlerIfEventEmitter(
                  emitter,
                  handler,
                  flags
                ) {
                  "function" == typeof emitter.on &&
                    eventTargetAgnosticAddListener(
                      emitter,
                      "error",
                      handler,
                      flags
                    );
                })(emitter, errorListener, { once: !0 });
          });
        }),
        ((EventEmitter.EventEmitter = EventEmitter).prototype._events = void 0),
        (EventEmitter.prototype._eventsCount = 0),
        (EventEmitter.prototype._maxListeners = void 0);
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if ("function" != typeof listener)
          throw new TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof listener
          );
      }
      function _getMaxListeners(that) {
        return void 0 === that._maxListeners
          ? EventEmitter.defaultMaxListeners
          : that._maxListeners;
      }
      function _addListener(target, type, listener, prepend) {
        var events, existing;
        return (
          checkListener(listener),
          void 0 === (events = target._events)
            ? ((events = target._events = Object.create(null)),
              (target._eventsCount = 0))
            : (void 0 !== events.newListener &&
                (target.emit(
                  "newListener",
                  type,
                  listener.listener || listener
                ),
                (events = target._events)),
              (existing = events[type])),
          void 0 === existing
            ? ((existing = events[type] = listener), ++target._eventsCount)
            : ("function" == typeof existing
                ? (existing = events[type] =
                    prepend ? [listener, existing] : [existing, listener])
                : prepend
                ? existing.unshift(listener)
                : existing.push(listener),
              0 < (events = _getMaxListeners(target)) &&
                existing.length > events &&
                !existing.warned &&
                ((existing.warned = !0),
                ((prepend = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    " " +
                    String(type) +
                    " listeners added. Use emitter.setMaxListeners() to increase limit"
                )).name = "MaxListenersExceededWarning"),
                (prepend.emitter = target),
                (prepend.type = type),
                (prepend.count = existing.length),
                (function ProcessEmitWarning(warning) {
                  console && console.warn && console.warn(warning);
                })(prepend))),
          target
        );
      }
      function _onceWrap(target, type, listener) {
        (target = {
          fired: !1,
          wrapFn: void 0,
          target: target,
          type: type,
          listener: listener,
        }),
          (type = function onceWrapper() {
            if (!this.fired)
              return (
                this.target.removeListener(this.type, this.wrapFn),
                (this.fired = !0),
                0 === arguments.length
                  ? this.listener.call(this.target)
                  : this.listener.apply(this.target, arguments)
              );
          }.bind(target));
        return (type.listener = listener), (target.wrapFn = type);
      }
      function _listeners(target, type, unwrap) {
        var target = target._events;
        return void 0 === target || void 0 === (target = target[type])
          ? []
          : "function" == typeof target
          ? unwrap
            ? [target.listener || target]
            : [target]
          : unwrap
          ? (function unwrapListeners(arr) {
              for (var ret = new Array(arr.length), i = 0; i < ret.length; ++i)
                ret[i] = arr[i].listener || arr[i];
              return ret;
            })(target)
          : arrayClone(target, target.length);
      }
      function listenerCount(type) {
        var events = this._events;
        if (void 0 !== events) {
          events = events[type];
          if ("function" == typeof events) return 1;
          if (void 0 !== events) return events.length;
        }
        return 0;
      }
      function arrayClone(arr, n) {
        for (var copy = new Array(n), i = 0; i < n; ++i) copy[i] = arr[i];
        return copy;
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if ("function" == typeof emitter.on)
          flags.once
            ? emitter.once(name, listener)
            : emitter.on(name, listener);
        else {
          if ("function" != typeof emitter.addEventListener)
            throw new TypeError(
              'The "emitter" argument must be of type EventEmitter. Received type ' +
                typeof emitter
            );
          emitter.addEventListener(name, function wrapListener(arg) {
            flags.once && emitter.removeEventListener(name, wrapListener),
              listener(arg);
          });
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return defaultMaxListeners;
        },
        set: function (arg) {
          if ("number" != typeof arg || arg < 0 || NumberIsNaN(arg))
            throw new RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                arg +
                "."
            );
          defaultMaxListeners = arg;
        },
      }),
        (EventEmitter.init = function () {
          (void 0 !== this._events &&
            this._events !== Object.getPrototypeOf(this)._events) ||
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if ("number" != typeof n || n < 0 || NumberIsNaN(n))
            throw new RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                n +
                "."
            );
          return (this._maxListeners = n), this;
        }),
        (EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        }),
        (EventEmitter.prototype.emit = function emit(type) {
          for (var args = [], i = 1; i < arguments.length; i++)
            args.push(arguments[i]);
          var doError = "error" === type,
            events = this._events;
          if (void 0 !== events) doError = doError && void 0 === events.error;
          else if (!doError) return !1;
          if (doError) {
            if ((er = 0 < args.length ? args[0] : er) instanceof Error)
              throw er;
            doError = new Error(
              "Unhandled error." + (er ? " (" + er.message + ")" : "")
            );
            throw ((doError.context = er), doError);
          }
          var er = events[type];
          if (void 0 === er) return !1;
          if ("function" == typeof er) ReflectApply(er, this, args);
          else
            for (
              var len = er.length, listeners = arrayClone(er, len), i = 0;
              i < len;
              ++i
            )
              ReflectApply(listeners[i], this, args);
          return !0;
        }),
        (EventEmitter.prototype.on = EventEmitter.prototype.addListener =
          function addListener(type, listener) {
            return _addListener(this, type, listener, !1);
          }),
        (EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, !0);
        }),
        (EventEmitter.prototype.once = function once(type, listener) {
          return (
            checkListener(listener),
            this.on(type, _onceWrap(this, type, listener)),
            this
          );
        }),
        (EventEmitter.prototype.prependOnceListener =
          function prependOnceListener(type, listener) {
            return (
              checkListener(listener),
              this.prependListener(type, _onceWrap(this, type, listener)),
              this
            );
          }),
        (EventEmitter.prototype.off = EventEmitter.prototype.removeListener =
          function removeListener(type, listener) {
            var list, events, position, i, originalListener;
            if (
              (checkListener(listener),
              void 0 !== (events = this._events) &&
                void 0 !== (list = events[type]))
            )
              if (list === listener || list.listener === listener)
                0 == --this._eventsCount
                  ? (this._events = Object.create(null))
                  : (delete events[type],
                    events.removeListener &&
                      this.emit(
                        "removeListener",
                        type,
                        list.listener || listener
                      ));
              else if ("function" != typeof list) {
                for (position = -1, i = list.length - 1; 0 <= i; i--)
                  if (list[i] === listener || list[i].listener === listener) {
                    (originalListener = list[i].listener), (position = i);
                    break;
                  }
                if (position < 0) return this;
                0 === position
                  ? list.shift()
                  : (function spliceOne(list, index) {
                      for (; index + 1 < list.length; index++)
                        list[index] = list[index + 1];
                      list.pop();
                    })(list, position),
                  1 === list.length && (events[type] = list[0]),
                  void 0 !== events.removeListener &&
                    this.emit(
                      "removeListener",
                      type,
                      originalListener || listener
                    );
              }
            return this;
          }),
        (EventEmitter.prototype.removeAllListeners =
          function removeAllListeners(type) {
            var listeners,
              events = this._events;
            if (void 0 !== events)
              if (void 0 === events.removeListener)
                0 === arguments.length
                  ? ((this._events = Object.create(null)),
                    (this._eventsCount = 0))
                  : void 0 !== events[type] &&
                    (0 == --this._eventsCount
                      ? (this._events = Object.create(null))
                      : delete events[type]);
              else if (0 === arguments.length) {
                for (
                  var key, keys = Object.keys(events), i = 0;
                  i < keys.length;
                  ++i
                )
                  "removeListener" !== (key = keys[i]) &&
                    this.removeAllListeners(key);
                this.removeAllListeners("removeListener"),
                  (this._events = Object.create(null)),
                  (this._eventsCount = 0);
              } else if ("function" == typeof (listeners = events[type]))
                this.removeListener(type, listeners);
              else if (void 0 !== listeners)
                for (i = listeners.length - 1; 0 <= i; i--)
                  this.removeListener(type, listeners[i]);
            return this;
          }),
        (EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, !0);
        }),
        (EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, !1);
        }),
        (EventEmitter.listenerCount = function (emitter, type) {
          return "function" == typeof emitter.listenerCount
            ? emitter.listenerCount(type)
            : listenerCount.call(emitter, type);
        }),
        (EventEmitter.prototype.listenerCount = listenerCount),
        (EventEmitter.prototype.eventNames = function eventNames() {
          return 0 < this._eventsCount ? ReflectOwnKeys(this._events) : [];
        });
    },
    7472: (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      !(function () {
        "use strict";
        function HowlerGlobal() {
          this.init();
        }
        function Howl(o) {
          o.src && 0 !== o.src.length
            ? this.init(o)
            : console.error(
                "An array of source files must be passed with any new Howl."
              );
        }
        HowlerGlobal.prototype = {
          init: function () {
            var self = this || Howler;
            return (
              (self._counter = 1e3),
              (self._html5AudioPool = []),
              (self.html5PoolSize = 10),
              (self._codecs = {}),
              (self._howls = []),
              (self._muted = !1),
              (self._volume = 1),
              (self._canPlayEvent = "canplaythrough"),
              (self._navigator =
                "undefined" != typeof window && window.navigator
                  ? window.navigator
                  : null),
              (self.masterGain = null),
              (self.noAudio = !1),
              (self.usingWebAudio = !0),
              (self.autoSuspend = !0),
              (self.ctx = null),
              (self.autoUnlock = !0),
              self._setup(),
              self
            );
          },
          volume: function (vol) {
            var self = this || Howler;
            if (
              ((vol = parseFloat(vol)),
              self.ctx || setupAudioContext(),
              void 0 !== vol && 0 <= vol && vol <= 1)
            ) {
              if (((self._volume = vol), !self._muted)) {
                self.usingWebAudio &&
                  self.masterGain.gain.setValueAtTime(
                    vol,
                    Howler.ctx.currentTime
                  );
                for (var i = 0; i < self._howls.length; i++)
                  if (!self._howls[i]._webAudio)
                    for (
                      var ids = self._howls[i]._getSoundIds(), j = 0;
                      j < ids.length;
                      j++
                    ) {
                      var sound = self._howls[i]._soundById(ids[j]);
                      sound &&
                        sound._node &&
                        (sound._node.volume = sound._volume * vol);
                    }
              }
              return self;
            }
            return self._volume;
          },
          mute: function (muted) {
            var self = this || Howler;
            self.ctx || setupAudioContext(),
              (self._muted = muted),
              self.usingWebAudio &&
                self.masterGain.gain.setValueAtTime(
                  muted ? 0 : self._volume,
                  Howler.ctx.currentTime
                );
            for (var i = 0; i < self._howls.length; i++)
              if (!self._howls[i]._webAudio)
                for (
                  var ids = self._howls[i]._getSoundIds(), j = 0;
                  j < ids.length;
                  j++
                ) {
                  var sound = self._howls[i]._soundById(ids[j]);
                  sound &&
                    sound._node &&
                    (sound._node.muted = !!muted || sound._muted);
                }
            return self;
          },
          stop: function () {
            for (var self = this || Howler, i = 0; i < self._howls.length; i++)
              self._howls[i].stop();
            return self;
          },
          unload: function () {
            for (
              var self = this || Howler, i = self._howls.length - 1;
              0 <= i;
              i--
            )
              self._howls[i].unload();
            return (
              self.usingWebAudio &&
                self.ctx &&
                void 0 !== self.ctx.close &&
                (self.ctx.close(), (self.ctx = null), setupAudioContext()),
              self
            );
          },
          codecs: function (ext) {
            return (this || Howler)._codecs[ext.replace(/^x-/, "")];
          },
          _setup: function () {
            var self = this || Howler;
            if (
              ((self.state = (self.ctx && self.ctx.state) || "suspended"),
              self._autoSuspend(),
              !self.usingWebAudio)
            )
              if ("undefined" != typeof Audio)
                try {
                  void 0 === new Audio().oncanplaythrough &&
                    (self._canPlayEvent = "canplay");
                } catch (e) {
                  self.noAudio = !0;
                }
              else self.noAudio = !0;
            try {
              new Audio().muted && (self.noAudio = !0);
            } catch (e) {}
            return self.noAudio || self._setupCodecs(), self;
          },
          _setupCodecs: function () {
            var mpegTest,
              checkOpera,
              ua,
              checkSafari,
              self = this || Howler,
              audioTest = null;
            try {
              audioTest = "undefined" != typeof Audio ? new Audio() : null;
            } catch (err) {
              return self;
            }
            return (
              audioTest &&
                "function" == typeof audioTest.canPlayType &&
                ((mpegTest = audioTest
                  .canPlayType("audio/mpeg;")
                  .replace(/^no$/, "")),
                (checkOpera =
                  (checkOpera = (ua = self._navigator
                    ? self._navigator.userAgent
                    : "").match(/OPR\/(\d+)/g)) &&
                  parseInt(checkOpera[0].split("/")[1], 10) < 33),
                (checkSafari =
                  -1 !== ua.indexOf("Safari") && -1 === ua.indexOf("Chrome")),
                (ua = ua.match(/Version\/(.*?) /)),
                (checkSafari = checkSafari && ua && parseInt(ua[1], 10) < 15),
                (self._codecs = {
                  mp3: !(
                    checkOpera ||
                    (!mpegTest &&
                      !audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))
                  ),
                  mpeg: !!mpegTest,
                  opus: !!audioTest
                    .canPlayType('audio/ogg; codecs="opus"')
                    .replace(/^no$/, ""),
                  ogg: !!audioTest
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  oga: !!audioTest
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  wav: !!(
                    audioTest.canPlayType('audio/wav; codecs="1"') ||
                    audioTest.canPlayType("audio/wav")
                  ).replace(/^no$/, ""),
                  aac: !!audioTest
                    .canPlayType("audio/aac;")
                    .replace(/^no$/, ""),
                  caf: !!audioTest
                    .canPlayType("audio/x-caf;")
                    .replace(/^no$/, ""),
                  m4a: !!(
                    audioTest.canPlayType("audio/x-m4a;") ||
                    audioTest.canPlayType("audio/m4a;") ||
                    audioTest.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  m4b: !!(
                    audioTest.canPlayType("audio/x-m4b;") ||
                    audioTest.canPlayType("audio/m4b;") ||
                    audioTest.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  mp4: !!(
                    audioTest.canPlayType("audio/x-mp4;") ||
                    audioTest.canPlayType("audio/mp4;") ||
                    audioTest.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  weba: !(
                    checkSafari ||
                    !audioTest
                      .canPlayType('audio/webm; codecs="vorbis"')
                      .replace(/^no$/, "")
                  ),
                  webm: !(
                    checkSafari ||
                    !audioTest
                      .canPlayType('audio/webm; codecs="vorbis"')
                      .replace(/^no$/, "")
                  ),
                  dolby: !!audioTest
                    .canPlayType('audio/mp4; codecs="ec-3"')
                    .replace(/^no$/, ""),
                  flac: !!(
                    audioTest.canPlayType("audio/x-flac;") ||
                    audioTest.canPlayType("audio/flac;")
                  ).replace(/^no$/, ""),
                })),
              self
            );
          },
          _unlockAudio: function () {
            var unlock,
              self = this || Howler;
            if (!self._audioUnlocked && self.ctx)
              return (
                (self._audioUnlocked = !1),
                (self.autoUnlock = !1),
                self._mobileUnloaded ||
                  44100 === self.ctx.sampleRate ||
                  ((self._mobileUnloaded = !0), self.unload()),
                (self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050)),
                (unlock = function (e) {
                  for (; self._html5AudioPool.length < self.html5PoolSize; )
                    try {
                      var audioNode = new Audio();
                      (audioNode._unlocked = !0),
                        self._releaseHtml5Audio(audioNode);
                    } catch (e) {
                      self.noAudio = !0;
                      break;
                    }
                  for (var i = 0; i < self._howls.length; i++)
                    if (!self._howls[i]._webAudio)
                      for (
                        var ids = self._howls[i]._getSoundIds(), j = 0;
                        j < ids.length;
                        j++
                      ) {
                        var sound = self._howls[i]._soundById(ids[j]);
                        sound &&
                          sound._node &&
                          !sound._node._unlocked &&
                          ((sound._node._unlocked = !0), sound._node.load());
                      }
                  self._autoResume();
                  var source = self.ctx.createBufferSource();
                  (source.buffer = self._scratchBuffer),
                    source.connect(self.ctx.destination),
                    void 0 === source.start
                      ? source.noteOn(0)
                      : source.start(0),
                    "function" == typeof self.ctx.resume && self.ctx.resume(),
                    (source.onended = function () {
                      source.disconnect(0),
                        (self._audioUnlocked = !0),
                        document.removeEventListener("touchstart", unlock, !0),
                        document.removeEventListener("touchend", unlock, !0),
                        document.removeEventListener("click", unlock, !0),
                        document.removeEventListener("keydown", unlock, !0);
                      for (var i = 0; i < self._howls.length; i++)
                        self._howls[i]._emit("unlock");
                    });
                }),
                document.addEventListener("touchstart", unlock, !0),
                document.addEventListener("touchend", unlock, !0),
                document.addEventListener("click", unlock, !0),
                document.addEventListener("keydown", unlock, !0),
                self
              );
          },
          _obtainHtml5Audio: function () {
            var self = this || Howler;
            return self._html5AudioPool.length
              ? self._html5AudioPool.pop()
              : ((self = new Audio().play()) &&
                  "undefined" != typeof Promise &&
                  (self instanceof Promise || "function" == typeof self.then) &&
                  self.catch(function () {
                    console.warn(
                      "HTML5 Audio pool exhausted, returning potentially locked audio object."
                    );
                  }),
                new Audio());
          },
          _releaseHtml5Audio: function (audio) {
            var self = this || Howler;
            return audio._unlocked && self._html5AudioPool.push(audio), self;
          },
          _autoSuspend: function () {
            var self = this;
            if (
              self.autoSuspend &&
              self.ctx &&
              void 0 !== self.ctx.suspend &&
              Howler.usingWebAudio
            ) {
              for (var i = 0; i < self._howls.length; i++)
                if (self._howls[i]._webAudio)
                  for (var j = 0; j < self._howls[i]._sounds.length; j++)
                    if (!self._howls[i]._sounds[j]._paused) return self;
              return (
                self._suspendTimer && clearTimeout(self._suspendTimer),
                (self._suspendTimer = setTimeout(function () {
                  var handleSuspension;
                  self.autoSuspend &&
                    ((self._suspendTimer = null),
                    (self.state = "suspending"),
                    (handleSuspension = function () {
                      (self.state = "suspended"),
                        self._resumeAfterSuspend &&
                          (delete self._resumeAfterSuspend, self._autoResume());
                    }),
                    self.ctx
                      .suspend()
                      .then(handleSuspension, handleSuspension));
                }, 3e4)),
                self
              );
            }
          },
          _autoResume: function () {
            var self = this;
            if (self.ctx && void 0 !== self.ctx.resume && Howler.usingWebAudio)
              return (
                "running" === self.state &&
                "interrupted" !== self.ctx.state &&
                self._suspendTimer
                  ? (clearTimeout(self._suspendTimer),
                    (self._suspendTimer = null))
                  : "suspended" === self.state ||
                    ("running" === self.state &&
                      "interrupted" === self.ctx.state)
                  ? (self.ctx.resume().then(function () {
                      self.state = "running";
                      for (var i = 0; i < self._howls.length; i++)
                        self._howls[i]._emit("resume");
                    }),
                    self._suspendTimer &&
                      (clearTimeout(self._suspendTimer),
                      (self._suspendTimer = null)))
                  : "suspending" === self.state &&
                    (self._resumeAfterSuspend = !0),
                self
              );
          },
        };
        var Howler = new HowlerGlobal(),
          Sound =
            ((Howl.prototype = {
              init: function (o) {
                var self = this;
                return (
                  Howler.ctx || setupAudioContext(),
                  (self._autoplay = o.autoplay || !1),
                  (self._format =
                    "string" != typeof o.format ? o.format : [o.format]),
                  (self._html5 = o.html5 || !1),
                  (self._muted = o.mute || !1),
                  (self._loop = o.loop || !1),
                  (self._pool = o.pool || 5),
                  (self._preload =
                    ("boolean" != typeof o.preload &&
                      "metadata" !== o.preload) ||
                    o.preload),
                  (self._rate = o.rate || 1),
                  (self._sprite = o.sprite || {}),
                  (self._src = "string" != typeof o.src ? o.src : [o.src]),
                  (self._volume = void 0 !== o.volume ? o.volume : 1),
                  (self._xhr = {
                    method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
                    headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
                    withCredentials:
                      !(!o.xhr || !o.xhr.withCredentials) &&
                      o.xhr.withCredentials,
                  }),
                  (self._duration = 0),
                  (self._state = "unloaded"),
                  (self._sounds = []),
                  (self._endTimers = {}),
                  (self._queue = []),
                  (self._playLock = !1),
                  (self._onend = o.onend ? [{ fn: o.onend }] : []),
                  (self._onfade = o.onfade ? [{ fn: o.onfade }] : []),
                  (self._onload = o.onload ? [{ fn: o.onload }] : []),
                  (self._onloaderror = o.onloaderror
                    ? [{ fn: o.onloaderror }]
                    : []),
                  (self._onplayerror = o.onplayerror
                    ? [{ fn: o.onplayerror }]
                    : []),
                  (self._onpause = o.onpause ? [{ fn: o.onpause }] : []),
                  (self._onplay = o.onplay ? [{ fn: o.onplay }] : []),
                  (self._onstop = o.onstop ? [{ fn: o.onstop }] : []),
                  (self._onmute = o.onmute ? [{ fn: o.onmute }] : []),
                  (self._onvolume = o.onvolume ? [{ fn: o.onvolume }] : []),
                  (self._onrate = o.onrate ? [{ fn: o.onrate }] : []),
                  (self._onseek = o.onseek ? [{ fn: o.onseek }] : []),
                  (self._onunlock = o.onunlock ? [{ fn: o.onunlock }] : []),
                  (self._onresume = []),
                  (self._webAudio = Howler.usingWebAudio && !self._html5),
                  void 0 !== Howler.ctx &&
                    Howler.ctx &&
                    Howler.autoUnlock &&
                    Howler._unlockAudio(),
                  Howler._howls.push(self),
                  self._autoplay &&
                    self._queue.push({
                      event: "play",
                      action: function () {
                        self.play();
                      },
                    }),
                  self._preload && "none" !== self._preload && self.load(),
                  self
                );
              },
              load: function () {
                var url = null;
                if (Howler.noAudio)
                  this._emit("loaderror", null, "No audio support.");
                else {
                  "string" == typeof this._src && (this._src = [this._src]);
                  for (var ext, str, i = 0; i < this._src.length; i++) {
                    if (this._format && this._format[i]) ext = this._format[i];
                    else {
                      if ("string" != typeof (str = this._src[i])) {
                        this._emit(
                          "loaderror",
                          null,
                          "Non-string found in selected audio sources - ignoring."
                        );
                        continue;
                      }
                      ext =
                        (ext =
                          (ext = /^data:audio\/([^;,]+);/i.exec(str)) ||
                          /\.([^.]+)$/.exec(str.split("?", 1)[0])) &&
                        ext[1].toLowerCase();
                    }
                    if (
                      (ext ||
                        console.warn(
                          'No file extension was found. Consider using the "format" property or specify an extension.'
                        ),
                      ext && Howler.codecs(ext))
                    ) {
                      url = this._src[i];
                      break;
                    }
                  }
                  if (url)
                    return (
                      (this._src = url),
                      (this._state = "loading"),
                      "https:" === window.location.protocol &&
                        "http:" === url.slice(0, 5) &&
                        ((this._html5 = !0), (this._webAudio = !1)),
                      new Sound(this),
                      this._webAudio && loadBuffer(this),
                      this
                    );
                  this._emit(
                    "loaderror",
                    null,
                    "No codec support for selected audio sources."
                  );
                }
              },
              play: function (sprite, internal) {
                var self = this,
                  id = null;
                if ("number" == typeof sprite) (id = sprite), (sprite = null);
                else {
                  if (
                    "string" == typeof sprite &&
                    "loaded" === self._state &&
                    !self._sprite[sprite]
                  )
                    return null;
                  if (
                    void 0 === sprite &&
                    ((sprite = "__default"), !self._playLock)
                  ) {
                    for (var num = 0, i = 0; i < self._sounds.length; i++)
                      self._sounds[i]._paused &&
                        !self._sounds[i]._ended &&
                        (num++, (id = self._sounds[i]._id));
                    1 === num ? (sprite = null) : (id = null);
                  }
                }
                var soundId,
                  sound = id ? self._soundById(id) : self._inactiveSound();
                if (!sound) return null;
                if (
                  (id && !sprite && (sprite = sound._sprite || "__default"),
                  "loaded" !== self._state)
                )
                  return (
                    (sound._sprite = sprite),
                    (sound._ended = !1),
                    (soundId = sound._id),
                    self._queue.push({
                      event: "play",
                      action: function () {
                        self.play(soundId);
                      },
                    }),
                    soundId
                  );
                if (id && !sound._paused)
                  return internal || self._loadQueue("play"), sound._id;
                self._webAudio && Howler._autoResume();
                var node,
                  playHtml5,
                  playWebAudio,
                  listener,
                  seek = Math.max(
                    0,
                    0 < sound._seek
                      ? sound._seek
                      : self._sprite[sprite][0] / 1e3
                  ),
                  duration = Math.max(
                    0,
                    (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3 -
                      seek
                  ),
                  timeout = (1e3 * duration) / Math.abs(sound._rate),
                  start = self._sprite[sprite][0] / 1e3,
                  stop =
                    (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3,
                  setParams =
                    ((sound._sprite = sprite),
                    (sound._ended = !1),
                    function () {
                      (sound._paused = !1),
                        (sound._seek = seek),
                        (sound._start = start),
                        (sound._stop = stop),
                        (sound._loop = !(
                          !sound._loop && !self._sprite[sprite][2]
                        ));
                    });
                if (!(stop <= seek))
                  return (
                    (node = sound._node),
                    self._webAudio
                      ? ((playWebAudio = function () {
                          (self._playLock = !1),
                            setParams(),
                            self._refreshBuffer(sound);
                          var vol =
                            sound._muted || self._muted ? 0 : sound._volume;
                          node.gain.setValueAtTime(vol, Howler.ctx.currentTime),
                            (sound._playStart = Howler.ctx.currentTime),
                            void 0 === node.bufferSource.start
                              ? sound._loop
                                ? node.bufferSource.noteGrainOn(0, seek, 86400)
                                : node.bufferSource.noteGrainOn(
                                    0,
                                    seek,
                                    duration
                                  )
                              : sound._loop
                              ? node.bufferSource.start(0, seek, 86400)
                              : node.bufferSource.start(0, seek, duration),
                            timeout !== 1 / 0 &&
                              (self._endTimers[sound._id] = setTimeout(
                                self._ended.bind(self, sound),
                                timeout
                              )),
                            internal ||
                              setTimeout(function () {
                                self._emit("play", sound._id),
                                  self._loadQueue();
                              }, 0);
                        }),
                        "running" === Howler.state &&
                        "interrupted" !== Howler.ctx.state
                          ? playWebAudio()
                          : ((self._playLock = !0),
                            self.once("resume", playWebAudio),
                            self._clearTimer(sound._id)))
                      : ((playHtml5 = function () {
                          (node.currentTime = seek),
                            (node.muted =
                              sound._muted ||
                              self._muted ||
                              Howler._muted ||
                              node.muted),
                            (node.volume = sound._volume * Howler.volume()),
                            (node.playbackRate = sound._rate);
                          try {
                            var play = node.play();
                            play &&
                            "undefined" != typeof Promise &&
                            (play instanceof Promise ||
                              "function" == typeof play.then)
                              ? ((self._playLock = !0),
                                setParams(),
                                play
                                  .then(function () {
                                    (self._playLock = !1),
                                      (node._unlocked = !0),
                                      internal
                                        ? self._loadQueue()
                                        : self._emit("play", sound._id);
                                  })
                                  .catch(function () {
                                    (self._playLock = !1),
                                      self._emit(
                                        "playerror",
                                        sound._id,
                                        "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                      ),
                                      (sound._ended = !0),
                                      (sound._paused = !0);
                                  }))
                              : internal ||
                                ((self._playLock = !1),
                                setParams(),
                                self._emit("play", sound._id)),
                              (node.playbackRate = sound._rate),
                              node.paused
                                ? self._emit(
                                    "playerror",
                                    sound._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  )
                                : "__default" !== sprite || sound._loop
                                ? (self._endTimers[sound._id] = setTimeout(
                                    self._ended.bind(self, sound),
                                    timeout
                                  ))
                                : ((self._endTimers[sound._id] = function () {
                                    self._ended(sound),
                                      node.removeEventListener(
                                        "ended",
                                        self._endTimers[sound._id],
                                        !1
                                      );
                                  }),
                                  node.addEventListener(
                                    "ended",
                                    self._endTimers[sound._id],
                                    !1
                                  ));
                          } catch (err) {
                            self._emit("playerror", sound._id, err);
                          }
                        }),
                        "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                          node.src && ((node.src = self._src), node.load()),
                        (playWebAudio =
                          (window && window.ejecta) ||
                          (!node.readyState && Howler._navigator.isCocoonJS)),
                        3 <= node.readyState || playWebAudio
                          ? playHtml5()
                          : ((self._playLock = !0),
                            (self._state = "loading"),
                            (listener = function () {
                              (self._state = "loaded"),
                                playHtml5(),
                                node.removeEventListener(
                                  Howler._canPlayEvent,
                                  listener,
                                  !1
                                );
                            }),
                            node.addEventListener(
                              Howler._canPlayEvent,
                              listener,
                              !1
                            ),
                            self._clearTimer(sound._id))),
                    sound._id
                  );
                self._ended(sound);
              },
              pause: function (id) {
                var self = this;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "pause",
                    action: function () {
                      self.pause(id);
                    },
                  });
                else
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    self._clearTimer(ids[i]);
                    var sound = self._soundById(ids[i]);
                    if (
                      sound &&
                      !sound._paused &&
                      ((sound._seek = self.seek(ids[i])),
                      (sound._rateSeek = 0),
                      (sound._paused = !0),
                      self._stopFade(ids[i]),
                      sound._node)
                    )
                      if (self._webAudio) {
                        if (!sound._node.bufferSource) continue;
                        void 0 === sound._node.bufferSource.stop
                          ? sound._node.bufferSource.noteOff(0)
                          : sound._node.bufferSource.stop(0),
                          self._cleanBuffer(sound._node);
                      } else
                        (isNaN(sound._node.duration) &&
                          sound._node.duration !== 1 / 0) ||
                          sound._node.pause();
                    arguments[1] ||
                      self._emit("pause", sound ? sound._id : null);
                  }
                return self;
              },
              stop: function (id, internal) {
                var self = this;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "stop",
                    action: function () {
                      self.stop(id);
                    },
                  });
                else
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    self._clearTimer(ids[i]);
                    var sound = self._soundById(ids[i]);
                    sound &&
                      ((sound._seek = sound._start || 0),
                      (sound._rateSeek = 0),
                      (sound._paused = !0),
                      (sound._ended = !0),
                      self._stopFade(ids[i]),
                      sound._node &&
                        (self._webAudio
                          ? sound._node.bufferSource &&
                            (void 0 === sound._node.bufferSource.stop
                              ? sound._node.bufferSource.noteOff(0)
                              : sound._node.bufferSource.stop(0),
                            self._cleanBuffer(sound._node))
                          : (isNaN(sound._node.duration) &&
                              sound._node.duration !== 1 / 0) ||
                            ((sound._node.currentTime = sound._start || 0),
                            sound._node.pause(),
                            sound._node.duration === 1 / 0 &&
                              self._clearSound(sound._node))),
                      internal || self._emit("stop", sound._id));
                  }
                return self;
              },
              mute: function (muted, id) {
                var self = this;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "mute",
                    action: function () {
                      self.mute(muted, id);
                    },
                  });
                else {
                  if (void 0 === id) {
                    if ("boolean" != typeof muted) return self._muted;
                    self._muted = muted;
                  }
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    var sound = self._soundById(ids[i]);
                    sound &&
                      ((sound._muted = muted),
                      sound._interval && self._stopFade(sound._id),
                      self._webAudio && sound._node
                        ? sound._node.gain.setValueAtTime(
                            muted ? 0 : sound._volume,
                            Howler.ctx.currentTime
                          )
                        : sound._node &&
                          (sound._node.muted = !!Howler._muted || muted),
                      self._emit("mute", sound._id));
                  }
                }
                return self;
              },
              volume: function () {
                var vol,
                  sound,
                  self = this,
                  args = arguments;
                if (0 === args.length) return self._volume;
                if (
                  (1 === args.length ||
                  (2 === args.length && void 0 === args[1])
                    ? 0 <= self._getSoundIds().indexOf(args[0])
                      ? (id = parseInt(args[0], 10))
                      : (vol = parseFloat(args[0]))
                    : 2 <= args.length &&
                      ((vol = parseFloat(args[0])),
                      (id = parseInt(args[1], 10))),
                  !(void 0 !== vol && 0 <= vol && vol <= 1))
                )
                  return (sound = id ? self._soundById(id) : self._sounds[0])
                    ? sound._volume
                    : 0;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "volume",
                    action: function () {
                      self.volume.apply(self, args);
                    },
                  });
                else {
                  void 0 === id && (self._volume = vol);
                  for (
                    var id = self._getSoundIds(id), i = 0;
                    i < id.length;
                    i++
                  )
                    (sound = self._soundById(id[i])) &&
                      ((sound._volume = vol),
                      args[2] || self._stopFade(id[i]),
                      self._webAudio && sound._node && !sound._muted
                        ? sound._node.gain.setValueAtTime(
                            vol,
                            Howler.ctx.currentTime
                          )
                        : sound._node &&
                          !sound._muted &&
                          (sound._node.volume = vol * Howler.volume()),
                      self._emit("volume", sound._id));
                }
                return self;
              },
              fade: function (from, to, len, id) {
                var self = this;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "fade",
                    action: function () {
                      self.fade(from, to, len, id);
                    },
                  });
                else {
                  (from = Math.min(Math.max(0, parseFloat(from)), 1)),
                    (to = Math.min(Math.max(0, parseFloat(to)), 1)),
                    (len = parseFloat(len)),
                    self.volume(from, id);
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    var currentTime,
                      end,
                      sound = self._soundById(ids[i]);
                    sound &&
                      (id || self._stopFade(ids[i]),
                      self._webAudio &&
                        !sound._muted &&
                        ((end =
                          (currentTime = Howler.ctx.currentTime) + len / 1e3),
                        (sound._volume = from),
                        sound._node.gain.setValueAtTime(from, currentTime),
                        sound._node.gain.linearRampToValueAtTime(to, end)),
                      self._startFadeInterval(
                        sound,
                        from,
                        to,
                        len,
                        ids[i],
                        void 0 === id
                      ));
                  }
                }
                return self;
              },
              _startFadeInterval: function (sound, from, to, len, id, isGroup) {
                var self = this,
                  vol = from,
                  diff = to - from,
                  steps = Math.abs(diff / 0.01),
                  steps = Math.max(4, 0 < steps ? len / steps : len),
                  lastTick = Date.now();
                (sound._fadeTo = to),
                  (sound._interval = setInterval(function () {
                    var tick = (Date.now() - lastTick) / len;
                    (lastTick = Date.now()),
                      (vol += diff * tick),
                      (vol = Math.round(100 * vol) / 100),
                      (vol = diff < 0 ? Math.max(to, vol) : Math.min(to, vol)),
                      self._webAudio
                        ? (sound._volume = vol)
                        : self.volume(vol, sound._id, !0),
                      isGroup && (self._volume = vol),
                      ((to < from && vol <= to) || (from < to && to <= vol)) &&
                        (clearInterval(sound._interval),
                        (sound._interval = null),
                        (sound._fadeTo = null),
                        self.volume(to, sound._id),
                        self._emit("fade", sound._id));
                  }, steps));
              },
              _stopFade: function (id) {
                var sound = this._soundById(id);
                return (
                  sound &&
                    sound._interval &&
                    (this._webAudio &&
                      sound._node.gain.cancelScheduledValues(
                        Howler.ctx.currentTime
                      ),
                    clearInterval(sound._interval),
                    (sound._interval = null),
                    this.volume(sound._fadeTo, id),
                    (sound._fadeTo = null),
                    this._emit("fade", id)),
                  this
                );
              },
              loop: function () {
                var loop,
                  id,
                  sound,
                  args = arguments;
                if (0 === args.length) return this._loop;
                if (1 === args.length) {
                  if ("boolean" != typeof args[0])
                    return (
                      !!(sound = this._soundById(parseInt(args[0], 10))) &&
                      sound._loop
                    );
                  this._loop = loop = args[0];
                } else
                  2 === args.length &&
                    ((loop = args[0]), (id = parseInt(args[1], 10)));
                for (
                  var ids = this._getSoundIds(id), i = 0;
                  i < ids.length;
                  i++
                )
                  (sound = this._soundById(ids[i])) &&
                    ((sound._loop = loop), this._webAudio) &&
                    sound._node &&
                    sound._node.bufferSource &&
                    (sound._node.bufferSource.loop = loop) &&
                    ((sound._node.bufferSource.loopStart = sound._start || 0),
                    (sound._node.bufferSource.loopEnd = sound._stop),
                    this.playing(ids[i])) &&
                    (this.pause(ids[i], !0), this.play(ids[i], !0));
                return this;
              },
              rate: function () {
                var rate,
                  self = this,
                  args = arguments;
                if (
                  (0 === args.length
                    ? (id = self._sounds[0]._id)
                    : 1 === args.length
                    ? 0 <= self._getSoundIds().indexOf(args[0])
                      ? (id = parseInt(args[0], 10))
                      : (rate = parseFloat(args[0]))
                    : 2 === args.length &&
                      ((rate = parseFloat(args[0])),
                      (id = parseInt(args[1], 10))),
                  "number" != typeof rate)
                )
                  return ((sound = self._soundById(id)) || self)._rate;
                if ("loaded" !== self._state || self._playLock)
                  self._queue.push({
                    event: "rate",
                    action: function () {
                      self.rate.apply(self, args);
                    },
                  });
                else {
                  void 0 === id && (self._rate = rate);
                  for (
                    var seek, sound, id = self._getSoundIds(id), i = 0;
                    i < id.length;
                    i++
                  )
                    (sound = self._soundById(id[i])) &&
                      (self.playing(id[i]) &&
                        ((sound._rateSeek = self.seek(id[i])),
                        (sound._playStart = self._webAudio
                          ? Howler.ctx.currentTime
                          : sound._playStart)),
                      (sound._rate = rate),
                      self._webAudio && sound._node && sound._node.bufferSource
                        ? sound._node.bufferSource.playbackRate.setValueAtTime(
                            rate,
                            Howler.ctx.currentTime
                          )
                        : sound._node && (sound._node.playbackRate = rate),
                      (seek = self.seek(id[i])),
                      (seek =
                        (1e3 *
                          ((self._sprite[sound._sprite][0] +
                            self._sprite[sound._sprite][1]) /
                            1e3 -
                            seek)) /
                        Math.abs(sound._rate)),
                      (!self._endTimers[id[i]] && sound._paused) ||
                        (self._clearTimer(id[i]),
                        (self._endTimers[id[i]] = setTimeout(
                          self._ended.bind(self, sound),
                          seek
                        ))),
                      self._emit("rate", sound._id));
                }
                return self;
              },
              seek: function () {
                var seek,
                  id,
                  self = this,
                  args = arguments;
                if (
                  (0 === args.length
                    ? self._sounds.length && (id = self._sounds[0]._id)
                    : 1 === args.length
                    ? 0 <= self._getSoundIds().indexOf(args[0])
                      ? (id = parseInt(args[0], 10))
                      : self._sounds.length &&
                        ((id = self._sounds[0]._id),
                        (seek = parseFloat(args[0])))
                    : 2 === args.length &&
                      ((seek = parseFloat(args[0])),
                      (id = parseInt(args[1], 10))),
                  void 0 === id)
                )
                  return 0;
                if (
                  "number" != typeof seek ||
                  ("loaded" === self._state && !self._playLock)
                ) {
                  var playing,
                    seekAndEmit,
                    emitSeek,
                    realTime,
                    rateSeek,
                    sound = self._soundById(id);
                  if (sound) {
                    if (!("number" == typeof seek && 0 <= seek))
                      return self._webAudio
                        ? ((realTime = self.playing(id)
                            ? Howler.ctx.currentTime - sound._playStart
                            : 0),
                          (rateSeek = sound._rateSeek
                            ? sound._rateSeek - sound._seek
                            : 0),
                          sound._seek +
                            (rateSeek + realTime * Math.abs(sound._rate)))
                        : sound._node.currentTime;
                    (playing = self.playing(id)) && self.pause(id, !0),
                      (sound._seek = seek),
                      (sound._ended = !1),
                      self._clearTimer(id),
                      self._webAudio ||
                        !sound._node ||
                        isNaN(sound._node.duration) ||
                        (sound._node.currentTime = seek),
                      (seekAndEmit = function () {
                        playing && self.play(id, !0), self._emit("seek", id);
                      }),
                      playing && !self._webAudio
                        ? ((emitSeek = function () {
                            self._playLock
                              ? setTimeout(emitSeek, 0)
                              : seekAndEmit();
                          }),
                          setTimeout(emitSeek, 0))
                        : seekAndEmit();
                  }
                } else
                  self._queue.push({
                    event: "seek",
                    action: function () {
                      self.seek.apply(self, args);
                    },
                  });
                return self;
              },
              playing: function (id) {
                if ("number" == typeof id)
                  return !!(id = this._soundById(id)) && !id._paused;
                for (var i = 0; i < this._sounds.length; i++)
                  if (!this._sounds[i]._paused) return !0;
                return !1;
              },
              duration: function (id) {
                var duration = this._duration,
                  id = this._soundById(id);
                return (duration = id
                  ? this._sprite[id._sprite][1] / 1e3
                  : duration);
              },
              state: function () {
                return this._state;
              },
              unload: function () {
                for (
                  var self = this, sounds = self._sounds, i = 0;
                  i < sounds.length;
                  i++
                )
                  sounds[i]._paused || self.stop(sounds[i]._id),
                    self._webAudio ||
                      (self._clearSound(sounds[i]._node),
                      sounds[i]._node.removeEventListener(
                        "error",
                        sounds[i]._errorFn,
                        !1
                      ),
                      sounds[i]._node.removeEventListener(
                        Howler._canPlayEvent,
                        sounds[i]._loadFn,
                        !1
                      ),
                      sounds[i]._node.removeEventListener(
                        "ended",
                        sounds[i]._endFn,
                        !1
                      ),
                      Howler._releaseHtml5Audio(sounds[i]._node)),
                    delete sounds[i]._node,
                    self._clearTimer(sounds[i]._id);
                for (
                  var index = Howler._howls.indexOf(self),
                    remCache =
                      (0 <= index && Howler._howls.splice(index, 1), !0),
                    i = 0;
                  i < Howler._howls.length;
                  i++
                )
                  if (
                    Howler._howls[i]._src === self._src ||
                    0 <= self._src.indexOf(Howler._howls[i]._src)
                  ) {
                    remCache = !1;
                    break;
                  }
                return (
                  cache && remCache && delete cache[self._src],
                  (Howler.noAudio = !1),
                  (self._state = "unloaded"),
                  (self._sounds = []),
                  (self = null)
                );
              },
              on: function (event, fn, id, once) {
                event = this["_on" + event];
                return (
                  "function" == typeof fn &&
                    event.push(
                      once ? { id: id, fn: fn, once: once } : { id: id, fn: fn }
                    ),
                  this
                );
              },
              off: function (event, fn, id) {
                var events = this["_on" + event],
                  i = 0;
                if (
                  ("number" == typeof fn && ((id = fn), (fn = null)), fn || id)
                )
                  for (i = 0; i < events.length; i++) {
                    var isId = id === events[i].id;
                    if ((fn === events[i].fn && isId) || (!fn && isId)) {
                      events.splice(i, 1);
                      break;
                    }
                  }
                else if (event) this["_on" + event] = [];
                else
                  for (
                    var keys = Object.keys(this), i = 0;
                    i < keys.length;
                    i++
                  )
                    0 === keys[i].indexOf("_on") &&
                      Array.isArray(this[keys[i]]) &&
                      (this[keys[i]] = []);
                return this;
              },
              once: function (event, fn, id) {
                return this.on(event, fn, id, 1), this;
              },
              _emit: function (event, id, msg) {
                for (
                  var events = this["_on" + event], i = events.length - 1;
                  0 <= i;
                  i--
                )
                  (events[i].id && events[i].id !== id && "load" !== event) ||
                    (setTimeout(
                      function (fn) {
                        fn.call(this, id, msg);
                      }.bind(this, events[i].fn),
                      0
                    ),
                    events[i].once &&
                      this.off(event, events[i].fn, events[i].id));
                return this._loadQueue(event), this;
              },
              _loadQueue: function (event) {
                var task;
                return (
                  0 < this._queue.length &&
                    ((task = this._queue[0]).event === event &&
                      (this._queue.shift(), this._loadQueue()),
                    event || task.action()),
                  this
                );
              },
              _ended: function (sound) {
                var timeout,
                  sprite = sound._sprite;
                return (
                  !this._webAudio &&
                  sound._node &&
                  !sound._node.paused &&
                  !sound._node.ended &&
                  sound._node.currentTime < sound._stop
                    ? setTimeout(this._ended.bind(this, sound), 100)
                    : ((sprite = !(!sound._loop && !this._sprite[sprite][2])),
                      this._emit("end", sound._id),
                      !this._webAudio &&
                        sprite &&
                        this.stop(sound._id, !0).play(sound._id),
                      this._webAudio &&
                        sprite &&
                        (this._emit("play", sound._id),
                        (sound._seek = sound._start || 0),
                        (sound._rateSeek = 0),
                        (sound._playStart = Howler.ctx.currentTime),
                        (timeout =
                          (1e3 * (sound._stop - sound._start)) /
                          Math.abs(sound._rate)),
                        (this._endTimers[sound._id] = setTimeout(
                          this._ended.bind(this, sound),
                          timeout
                        ))),
                      this._webAudio &&
                        !sprite &&
                        ((sound._paused = !0),
                        (sound._ended = !0),
                        (sound._seek = sound._start || 0),
                        (sound._rateSeek = 0),
                        this._clearTimer(sound._id),
                        this._cleanBuffer(sound._node),
                        Howler._autoSuspend()),
                      this._webAudio || sprite || this.stop(sound._id, !0)),
                  this
                );
              },
              _clearTimer: function (id) {
                var sound;
                return (
                  this._endTimers[id] &&
                    ("function" != typeof this._endTimers[id]
                      ? clearTimeout(this._endTimers[id])
                      : (sound = this._soundById(id)) &&
                        sound._node &&
                        sound._node.removeEventListener(
                          "ended",
                          this._endTimers[id],
                          !1
                        ),
                    delete this._endTimers[id]),
                  this
                );
              },
              _soundById: function (id) {
                for (var i = 0; i < this._sounds.length; i++)
                  if (id === this._sounds[i]._id) return this._sounds[i];
                return null;
              },
              _inactiveSound: function () {
                this._drain();
                for (var i = 0; i < this._sounds.length; i++)
                  if (this._sounds[i]._ended) return this._sounds[i].reset();
                return new Sound(this);
              },
              _drain: function () {
                var limit = this._pool,
                  cnt = 0,
                  i = 0;
                if (!(this._sounds.length < limit)) {
                  for (i = 0; i < this._sounds.length; i++)
                    this._sounds[i]._ended && cnt++;
                  for (i = this._sounds.length - 1; 0 <= i; i--) {
                    if (cnt <= limit) return;
                    this._sounds[i]._ended &&
                      (this._webAudio &&
                        this._sounds[i]._node &&
                        this._sounds[i]._node.disconnect(0),
                      this._sounds.splice(i, 1),
                      cnt--);
                  }
                }
              },
              _getSoundIds: function (id) {
                if (void 0 !== id) return [id];
                for (var ids = [], i = 0; i < this._sounds.length; i++)
                  ids.push(this._sounds[i]._id);
                return ids;
              },
              _refreshBuffer: function (sound) {
                return (
                  (sound._node.bufferSource = Howler.ctx.createBufferSource()),
                  (sound._node.bufferSource.buffer = cache[this._src]),
                  sound._panner
                    ? sound._node.bufferSource.connect(sound._panner)
                    : sound._node.bufferSource.connect(sound._node),
                  (sound._node.bufferSource.loop = sound._loop),
                  sound._loop &&
                    ((sound._node.bufferSource.loopStart = sound._start || 0),
                    (sound._node.bufferSource.loopEnd = sound._stop || 0)),
                  sound._node.bufferSource.playbackRate.setValueAtTime(
                    sound._rate,
                    Howler.ctx.currentTime
                  ),
                  this
                );
              },
              _cleanBuffer: function (node) {
                var isIOS =
                  Howler._navigator &&
                  0 <= Howler._navigator.vendor.indexOf("Apple");
                if (node.bufferSource) {
                  if (
                    Howler._scratchBuffer &&
                    node.bufferSource &&
                    ((node.bufferSource.onended = null),
                    node.bufferSource.disconnect(0),
                    isIOS)
                  )
                    try {
                      node.bufferSource.buffer = Howler._scratchBuffer;
                    } catch (e) {}
                  node.bufferSource = null;
                }
                return this;
              },
              _clearSound: function (node) {
                /MSIE |Trident\//.test(
                  Howler._navigator && Howler._navigator.userAgent
                ) ||
                  (node.src =
                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
              },
            }),
            function (howl) {
              (this._parent = howl), this.init();
            }),
          cache =
            ((Sound.prototype = {
              init: function () {
                var parent = this._parent;
                return (
                  (this._muted = parent._muted),
                  (this._loop = parent._loop),
                  (this._volume = parent._volume),
                  (this._rate = parent._rate),
                  (this._seek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++Howler._counter),
                  parent._sounds.push(this),
                  this.create(),
                  this
                );
              },
              create: function () {
                var parent = this._parent,
                  volume =
                    Howler._muted || this._muted || this._parent._muted
                      ? 0
                      : this._volume;
                return (
                  parent._webAudio
                    ? ((this._node =
                        void 0 === Howler.ctx.createGain
                          ? Howler.ctx.createGainNode()
                          : Howler.ctx.createGain()),
                      this._node.gain.setValueAtTime(
                        volume,
                        Howler.ctx.currentTime
                      ),
                      (this._node.paused = !0),
                      this._node.connect(Howler.masterGain))
                    : Howler.noAudio ||
                      ((this._node = Howler._obtainHtml5Audio()),
                      (this._errorFn = this._errorListener.bind(this)),
                      this._node.addEventListener("error", this._errorFn, !1),
                      (this._loadFn = this._loadListener.bind(this)),
                      this._node.addEventListener(
                        Howler._canPlayEvent,
                        this._loadFn,
                        !1
                      ),
                      (this._endFn = this._endListener.bind(this)),
                      this._node.addEventListener("ended", this._endFn, !1),
                      (this._node.src = parent._src),
                      (this._node.preload =
                        !0 === parent._preload ? "auto" : parent._preload),
                      (this._node.volume = volume * Howler.volume()),
                      this._node.load()),
                  this
                );
              },
              reset: function () {
                var parent = this._parent;
                return (
                  (this._muted = parent._muted),
                  (this._loop = parent._loop),
                  (this._volume = parent._volume),
                  (this._rate = parent._rate),
                  (this._seek = 0),
                  (this._rateSeek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++Howler._counter),
                  this
                );
              },
              _errorListener: function () {
                this._parent._emit(
                  "loaderror",
                  this._id,
                  this._node.error ? this._node.error.code : 0
                ),
                  this._node.removeEventListener("error", this._errorFn, !1);
              },
              _loadListener: function () {
                var parent = this._parent;
                (parent._duration = Math.ceil(10 * this._node.duration) / 10),
                  0 === Object.keys(parent._sprite).length &&
                    (parent._sprite = {
                      __default: [0, 1e3 * parent._duration],
                    }),
                  "loaded" !== parent._state &&
                    ((parent._state = "loaded"),
                    parent._emit("load"),
                    parent._loadQueue()),
                  this._node.removeEventListener(
                    Howler._canPlayEvent,
                    this._loadFn,
                    !1
                  );
              },
              _endListener: function () {
                var parent = this._parent;
                parent._duration === 1 / 0 &&
                  ((parent._duration =
                    Math.ceil(10 * this._node.duration) / 10),
                  parent._sprite.__default[1] === 1 / 0 &&
                    (parent._sprite.__default[1] = 1e3 * parent._duration),
                  parent._ended(this)),
                  this._node.removeEventListener("ended", this._endFn, !1);
              },
            }),
            {}),
          loadBuffer = function (self) {
            var url = self._src;
            if (cache[url])
              (self._duration = cache[url].duration), loadSound(self);
            else if (/^data:[^;]+;base64,/.test(url)) {
              for (
                var data = atob(url.split(",")[1]),
                  dataView = new Uint8Array(data.length),
                  i = 0;
                i < data.length;
                ++i
              )
                dataView[i] = data.charCodeAt(i);
              decodeAudioData(dataView.buffer, self);
            } else {
              var xhr = new XMLHttpRequest();
              xhr.open(self._xhr.method, url, !0),
                (xhr.withCredentials = self._xhr.withCredentials),
                (xhr.responseType = "arraybuffer"),
                self._xhr.headers &&
                  Object.keys(self._xhr.headers).forEach(function (key) {
                    xhr.setRequestHeader(key, self._xhr.headers[key]);
                  }),
                (xhr.onload = function () {
                  var code = (xhr.status + "")[0];
                  "0" !== code && "2" !== code && "3" !== code
                    ? self._emit(
                        "loaderror",
                        null,
                        "Failed loading audio file with status: " +
                          xhr.status +
                          "."
                      )
                    : decodeAudioData(xhr.response, self);
                }),
                (xhr.onerror = function () {
                  self._webAudio &&
                    ((self._html5 = !0),
                    (self._webAudio = !1),
                    (self._sounds = []),
                    delete cache[url],
                    self.load());
                }),
                safeXhrSend(xhr);
            }
          },
          safeXhrSend = function (xhr) {
            try {
              xhr.send();
            } catch (e) {
              xhr.onerror();
            }
          },
          decodeAudioData = function (arraybuffer, self) {
            function error() {
              self._emit("loaderror", null, "Decoding audio data failed.");
            }
            function success(buffer) {
              buffer && 0 < self._sounds.length
                ? ((cache[self._src] = buffer), loadSound(self, buffer))
                : error();
            }
            "undefined" != typeof Promise &&
            1 === Howler.ctx.decodeAudioData.length
              ? Howler.ctx
                  .decodeAudioData(arraybuffer)
                  .then(success)
                  .catch(error)
              : Howler.ctx.decodeAudioData(arraybuffer, success, error);
          },
          loadSound = function (self, buffer) {
            buffer && !self._duration && (self._duration = buffer.duration),
              0 === Object.keys(self._sprite).length &&
                (self._sprite = { __default: [0, 1e3 * self._duration] }),
              "loaded" !== self._state &&
                ((self._state = "loaded"),
                self._emit("load"),
                self._loadQueue());
          },
          setupAudioContext = function () {
            if (Howler.usingWebAudio) {
              try {
                "undefined" != typeof AudioContext
                  ? (Howler.ctx = new AudioContext())
                  : "undefined" != typeof webkitAudioContext
                  ? (Howler.ctx = new webkitAudioContext())
                  : (Howler.usingWebAudio = !1);
              } catch (e) {
                Howler.usingWebAudio = !1;
              }
              Howler.ctx || (Howler.usingWebAudio = !1);
              var iOS = /iP(hone|od|ad)/.test(
                  Howler._navigator && Howler._navigator.platform
                ),
                appVersion =
                  Howler._navigator &&
                  Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                appVersion = appVersion ? parseInt(appVersion[1], 10) : null;
              iOS &&
                appVersion &&
                appVersion < 9 &&
                ((iOS = /safari/.test(
                  Howler._navigator && Howler._navigator.userAgent.toLowerCase()
                )),
                Howler._navigator) &&
                !iOS &&
                (Howler.usingWebAudio = !1),
                Howler.usingWebAudio &&
                  ((Howler.masterGain =
                    void 0 === Howler.ctx.createGain
                      ? Howler.ctx.createGainNode()
                      : Howler.ctx.createGain()),
                  Howler.masterGain.gain.setValueAtTime(
                    Howler._muted ? 0 : Howler._volume,
                    Howler.ctx.currentTime
                  ),
                  Howler.masterGain.connect(Howler.ctx.destination)),
                Howler._setup();
            }
          };
        void 0 !==
          (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return { Howler: Howler, Howl: Howl };
          }.apply(exports, [])) &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__),
          (exports.Howler = Howler),
          (exports.Howl = Howl),
          void 0 !== __webpack_require__.g
            ? ((__webpack_require__.g.HowlerGlobal = HowlerGlobal),
              (__webpack_require__.g.Howler = Howler),
              (__webpack_require__.g.Howl = Howl),
              (__webpack_require__.g.Sound = Sound))
            : "undefined" != typeof window &&
              ((window.HowlerGlobal = HowlerGlobal),
              (window.Howler = Howler),
              (window.Howl = Howl),
              (window.Sound = Sound));
      })(),
        (function () {
          "use strict";
          (HowlerGlobal.prototype._pos = [0, 0, 0]),
            (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
            (HowlerGlobal.prototype.stereo = function (pan) {
              if (this.ctx && this.ctx.listener)
                for (var i = this._howls.length - 1; 0 <= i; i--)
                  this._howls[i].stereo(pan);
              return this;
            }),
            (HowlerGlobal.prototype.pos = function (x, y, z) {
              if (this.ctx && this.ctx.listener) {
                if (
                  ((y = "number" != typeof y ? this._pos[1] : y),
                  (z = "number" != typeof z ? this._pos[2] : z),
                  "number" != typeof x)
                )
                  return this._pos;
                (this._pos = [x, y, z]),
                  void 0 !== this.ctx.listener.positionX
                    ? (this.ctx.listener.positionX.setTargetAtTime(
                        this._pos[0],
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.positionY.setTargetAtTime(
                        this._pos[1],
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.positionZ.setTargetAtTime(
                        this._pos[2],
                        Howler.ctx.currentTime,
                        0.1
                      ))
                    : this.ctx.listener.setPosition(
                        this._pos[0],
                        this._pos[1],
                        this._pos[2]
                      );
              }
              return this;
            }),
            (HowlerGlobal.prototype.orientation = function (
              x,
              y,
              z,
              xUp,
              yUp,
              zUp
            ) {
              if (this.ctx && this.ctx.listener) {
                var or = this._orientation;
                if (
                  ((y = "number" != typeof y ? or[1] : y),
                  (z = "number" != typeof z ? or[2] : z),
                  (xUp = "number" != typeof xUp ? or[3] : xUp),
                  (yUp = "number" != typeof yUp ? or[4] : yUp),
                  (zUp = "number" != typeof zUp ? or[5] : zUp),
                  "number" != typeof x)
                )
                  return or;
                (this._orientation = [x, y, z, xUp, yUp, zUp]),
                  void 0 !== this.ctx.listener.forwardX
                    ? (this.ctx.listener.forwardX.setTargetAtTime(
                        x,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.forwardY.setTargetAtTime(
                        y,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.forwardZ.setTargetAtTime(
                        z,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upX.setTargetAtTime(
                        xUp,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upY.setTargetAtTime(
                        yUp,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upZ.setTargetAtTime(
                        zUp,
                        Howler.ctx.currentTime,
                        0.1
                      ))
                    : this.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
              }
              return this;
            }),
            (Howl.prototype.init =
              ((_super = Howl.prototype.init),
              function (o) {
                return (
                  (this._orientation = o.orientation || [1, 0, 0]),
                  (this._stereo = o.stereo || null),
                  (this._pos = o.pos || null),
                  (this._pannerAttr = {
                    coneInnerAngle:
                      void 0 !== o.coneInnerAngle ? o.coneInnerAngle : 360,
                    coneOuterAngle:
                      void 0 !== o.coneOuterAngle ? o.coneOuterAngle : 360,
                    coneOuterGain:
                      void 0 !== o.coneOuterGain ? o.coneOuterGain : 0,
                    distanceModel:
                      void 0 !== o.distanceModel ? o.distanceModel : "inverse",
                    maxDistance: void 0 !== o.maxDistance ? o.maxDistance : 1e4,
                    panningModel:
                      void 0 !== o.panningModel ? o.panningModel : "HRTF",
                    refDistance: void 0 !== o.refDistance ? o.refDistance : 1,
                    rolloffFactor:
                      void 0 !== o.rolloffFactor ? o.rolloffFactor : 1,
                  }),
                  (this._onstereo = o.onstereo ? [{ fn: o.onstereo }] : []),
                  (this._onpos = o.onpos ? [{ fn: o.onpos }] : []),
                  (this._onorientation = o.onorientation
                    ? [{ fn: o.onorientation }]
                    : []),
                  _super.call(this, o)
                );
              })),
            (Howl.prototype.stereo = function (pan, id) {
              var self = this;
              if (self._webAudio)
                if ("loaded" !== self._state)
                  self._queue.push({
                    event: "stereo",
                    action: function () {
                      self.stereo(pan, id);
                    },
                  });
                else {
                  var pannerType =
                    void 0 === Howler.ctx.createStereoPanner
                      ? "spatial"
                      : "stereo";
                  if (void 0 === id) {
                    if ("number" != typeof pan) return self._stereo;
                    (self._stereo = pan), (self._pos = [pan, 0, 0]);
                  }
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                      if ("number" != typeof pan) return sound._stereo;
                      (sound._stereo = pan),
                        (sound._pos = [pan, 0, 0]),
                        sound._node &&
                          ((sound._pannerAttr.panningModel = "equalpower"),
                          (sound._panner && sound._panner.pan) ||
                            setupPanner(sound, pannerType),
                          "spatial" == pannerType
                            ? void 0 !== sound._panner.positionX
                              ? (sound._panner.positionX.setValueAtTime(
                                  pan,
                                  Howler.ctx.currentTime
                                ),
                                sound._panner.positionY.setValueAtTime(
                                  0,
                                  Howler.ctx.currentTime
                                ),
                                sound._panner.positionZ.setValueAtTime(
                                  0,
                                  Howler.ctx.currentTime
                                ))
                              : sound._panner.setPosition(pan, 0, 0)
                            : sound._panner.pan.setValueAtTime(
                                pan,
                                Howler.ctx.currentTime
                              )),
                        self._emit("stereo", sound._id);
                    }
                  }
                }
              return self;
            }),
            (Howl.prototype.pos = function (x, y, z, id) {
              var self = this;
              if (self._webAudio)
                if ("loaded" !== self._state)
                  self._queue.push({
                    event: "pos",
                    action: function () {
                      self.pos(x, y, z, id);
                    },
                  });
                else {
                  if (
                    ((y = "number" != typeof y ? 0 : y),
                    (z = "number" != typeof z ? -0.5 : z),
                    void 0 === id)
                  ) {
                    if ("number" != typeof x) return self._pos;
                    self._pos = [x, y, z];
                  }
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                      if ("number" != typeof x) return sound._pos;
                      (sound._pos = [x, y, z]),
                        sound._node &&
                          ((sound._panner && !sound._panner.pan) ||
                            setupPanner(sound, "spatial"),
                          void 0 !== sound._panner.positionX
                            ? (sound._panner.positionX.setValueAtTime(
                                x,
                                Howler.ctx.currentTime
                              ),
                              sound._panner.positionY.setValueAtTime(
                                y,
                                Howler.ctx.currentTime
                              ),
                              sound._panner.positionZ.setValueAtTime(
                                z,
                                Howler.ctx.currentTime
                              ))
                            : sound._panner.setPosition(x, y, z)),
                        self._emit("pos", sound._id);
                    }
                  }
                }
              return self;
            }),
            (Howl.prototype.orientation = function (x, y, z, id) {
              var self = this;
              if (self._webAudio)
                if ("loaded" !== self._state)
                  self._queue.push({
                    event: "orientation",
                    action: function () {
                      self.orientation(x, y, z, id);
                    },
                  });
                else {
                  if (
                    ((y = "number" != typeof y ? self._orientation[1] : y),
                    (z = "number" != typeof z ? self._orientation[2] : z),
                    void 0 === id)
                  ) {
                    if ("number" != typeof x) return self._orientation;
                    self._orientation = [x, y, z];
                  }
                  for (
                    var ids = self._getSoundIds(id), i = 0;
                    i < ids.length;
                    i++
                  ) {
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                      if ("number" != typeof x) return sound._orientation;
                      (sound._orientation = [x, y, z]),
                        sound._node &&
                          (sound._panner ||
                            (sound._pos ||
                              (sound._pos = self._pos || [0, 0, -0.5]),
                            setupPanner(sound, "spatial")),
                          void 0 !== sound._panner.orientationX
                            ? (sound._panner.orientationX.setValueAtTime(
                                x,
                                Howler.ctx.currentTime
                              ),
                              sound._panner.orientationY.setValueAtTime(
                                y,
                                Howler.ctx.currentTime
                              ),
                              sound._panner.orientationZ.setValueAtTime(
                                z,
                                Howler.ctx.currentTime
                              ))
                            : sound._panner.setOrientation(x, y, z)),
                        self._emit("orientation", sound._id);
                    }
                  }
                }
              return self;
            }),
            (Howl.prototype.pannerAttr = function () {
              var o,
                id,
                args = arguments;
              if (this._webAudio) {
                if (0 === args.length) return this._pannerAttr;
                if (1 === args.length) {
                  if ("object" != typeof args[0])
                    return (
                      (sound = this._soundById(parseInt(args[0], 10))) || this
                    )._pannerAttr;
                  (o = args[0]),
                    void 0 === id &&
                      (o.pannerAttr ||
                        (o.pannerAttr = {
                          coneInnerAngle: o.coneInnerAngle,
                          coneOuterAngle: o.coneOuterAngle,
                          coneOuterGain: o.coneOuterGain,
                          distanceModel: o.distanceModel,
                          maxDistance: o.maxDistance,
                          refDistance: o.refDistance,
                          rolloffFactor: o.rolloffFactor,
                          panningModel: o.panningModel,
                        }),
                      (this._pannerAttr = {
                        coneInnerAngle:
                          void 0 !== o.pannerAttr.coneInnerAngle
                            ? o.pannerAttr.coneInnerAngle
                            : this._coneInnerAngle,
                        coneOuterAngle:
                          void 0 !== o.pannerAttr.coneOuterAngle
                            ? o.pannerAttr.coneOuterAngle
                            : this._coneOuterAngle,
                        coneOuterGain:
                          void 0 !== o.pannerAttr.coneOuterGain
                            ? o.pannerAttr.coneOuterGain
                            : this._coneOuterGain,
                        distanceModel:
                          void 0 !== o.pannerAttr.distanceModel
                            ? o.pannerAttr.distanceModel
                            : this._distanceModel,
                        maxDistance:
                          void 0 !== o.pannerAttr.maxDistance
                            ? o.pannerAttr.maxDistance
                            : this._maxDistance,
                        refDistance:
                          void 0 !== o.pannerAttr.refDistance
                            ? o.pannerAttr.refDistance
                            : this._refDistance,
                        rolloffFactor:
                          void 0 !== o.pannerAttr.rolloffFactor
                            ? o.pannerAttr.rolloffFactor
                            : this._rolloffFactor,
                        panningModel:
                          void 0 !== o.pannerAttr.panningModel
                            ? o.pannerAttr.panningModel
                            : this._panningModel,
                      }));
                } else
                  2 === args.length &&
                    ((o = args[0]), (id = parseInt(args[1], 10)));
                for (
                  var pa, panner, sound, ids = this._getSoundIds(id), i = 0;
                  i < ids.length;
                  i++
                )
                  (sound = this._soundById(ids[i])) &&
                    ((pa = sound._pannerAttr),
                    (pa = {
                      coneInnerAngle: (void 0 !== o.coneInnerAngle ? o : pa)
                        .coneInnerAngle,
                      coneOuterAngle: (void 0 !== o.coneOuterAngle ? o : pa)
                        .coneOuterAngle,
                      coneOuterGain: (void 0 !== o.coneOuterGain ? o : pa)
                        .coneOuterGain,
                      distanceModel: (void 0 !== o.distanceModel ? o : pa)
                        .distanceModel,
                      maxDistance: (void 0 !== o.maxDistance ? o : pa)
                        .maxDistance,
                      refDistance: (void 0 !== o.refDistance ? o : pa)
                        .refDistance,
                      rolloffFactor: (void 0 !== o.rolloffFactor ? o : pa)
                        .rolloffFactor,
                      panningModel: (void 0 !== o.panningModel ? o : pa)
                        .panningModel,
                    }),
                    (panner = sound._panner) ||
                      (sound._pos || (sound._pos = this._pos || [0, 0, -0.5]),
                      setupPanner(sound, "spatial"),
                      (panner = sound._panner)),
                    (panner.coneInnerAngle = pa.coneInnerAngle),
                    (panner.coneOuterAngle = pa.coneOuterAngle),
                    (panner.coneOuterGain = pa.coneOuterGain),
                    (panner.distanceModel = pa.distanceModel),
                    (panner.maxDistance = pa.maxDistance),
                    (panner.refDistance = pa.refDistance),
                    (panner.rolloffFactor = pa.rolloffFactor),
                    (panner.panningModel = pa.panningModel));
              }
              return this;
            }),
            (Sound.prototype.init = (function (_super) {
              return function () {
                var parent = this._parent;
                (this._orientation = parent._orientation),
                  (this._stereo = parent._stereo),
                  (this._pos = parent._pos),
                  (this._pannerAttr = parent._pannerAttr),
                  _super.call(this),
                  this._stereo
                    ? parent.stereo(this._stereo)
                    : this._pos &&
                      parent.pos(
                        this._pos[0],
                        this._pos[1],
                        this._pos[2],
                        this._id
                      );
              };
            })(Sound.prototype.init)),
            (Sound.prototype.reset = (function (_super) {
              return function () {
                var parent = this._parent;
                return (
                  (this._orientation = parent._orientation),
                  (this._stereo = parent._stereo),
                  (this._pos = parent._pos),
                  (this._pannerAttr = parent._pannerAttr),
                  this._stereo
                    ? parent.stereo(this._stereo)
                    : this._pos
                    ? parent.pos(
                        this._pos[0],
                        this._pos[1],
                        this._pos[2],
                        this._id
                      )
                    : this._panner &&
                      (this._panner.disconnect(0),
                      (this._panner = void 0),
                      parent._refreshBuffer(this)),
                  _super.call(this)
                );
              };
            })(Sound.prototype.reset));
          var _super,
            setupPanner = function (sound, type) {
              "spatial" === (type = type || "spatial")
                ? ((sound._panner = Howler.ctx.createPanner()),
                  (sound._panner.coneInnerAngle =
                    sound._pannerAttr.coneInnerAngle),
                  (sound._panner.coneOuterAngle =
                    sound._pannerAttr.coneOuterAngle),
                  (sound._panner.coneOuterGain =
                    sound._pannerAttr.coneOuterGain),
                  (sound._panner.distanceModel =
                    sound._pannerAttr.distanceModel),
                  (sound._panner.maxDistance = sound._pannerAttr.maxDistance),
                  (sound._panner.refDistance = sound._pannerAttr.refDistance),
                  (sound._panner.rolloffFactor =
                    sound._pannerAttr.rolloffFactor),
                  (sound._panner.panningModel = sound._pannerAttr.panningModel),
                  void 0 !== sound._panner.positionX
                    ? (sound._panner.positionX.setValueAtTime(
                        sound._pos[0],
                        Howler.ctx.currentTime
                      ),
                      sound._panner.positionY.setValueAtTime(
                        sound._pos[1],
                        Howler.ctx.currentTime
                      ),
                      sound._panner.positionZ.setValueAtTime(
                        sound._pos[2],
                        Howler.ctx.currentTime
                      ))
                    : sound._panner.setPosition(
                        sound._pos[0],
                        sound._pos[1],
                        sound._pos[2]
                      ),
                  void 0 !== sound._panner.orientationX
                    ? (sound._panner.orientationX.setValueAtTime(
                        sound._orientation[0],
                        Howler.ctx.currentTime
                      ),
                      sound._panner.orientationY.setValueAtTime(
                        sound._orientation[1],
                        Howler.ctx.currentTime
                      ),
                      sound._panner.orientationZ.setValueAtTime(
                        sound._orientation[2],
                        Howler.ctx.currentTime
                      ))
                    : sound._panner.setOrientation(
                        sound._orientation[0],
                        sound._orientation[1],
                        sound._orientation[2]
                      ))
                : ((sound._panner = Howler.ctx.createStereoPanner()),
                  sound._panner.pan.setValueAtTime(
                    sound._stereo,
                    Howler.ctx.currentTime
                  )),
                sound._panner.connect(sound._node),
                sound._paused ||
                  sound._parent.pause(sound._id, !0).play(sound._id, !0);
            };
        })();
    },
    8239: (__unused_webpack_module, exports) => {
      (exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e,
          m,
          eLen = 8 * nBytes - mLen - 1,
          eMax = (1 << eLen) - 1,
          eBias = eMax >> 1,
          nBits = -7,
          i = isLE ? nBytes - 1 : 0,
          d = isLE ? -1 : 1,
          nBytes = buffer[offset + i];
        for (
          i += d,
            e = nBytes & ((1 << -nBits) - 1),
            nBytes >>= -nBits,
            nBits += eLen;
          0 < nBits;
          e = 256 * e + buffer[offset + i], i += d, nBits -= 8
        );
        for (
          m = e & ((1 << -nBits) - 1), e >>= -nBits, nBits += mLen;
          0 < nBits;
          m = 256 * m + buffer[offset + i], i += d, nBits -= 8
        );
        if (0 === e) e = 1 - eBias;
        else {
          if (e === eMax) return m ? NaN : (1 / 0) * (nBytes ? -1 : 1);
          (m += Math.pow(2, mLen)), (e -= eBias);
        }
        return (nBytes ? -1 : 1) * m * Math.pow(2, e - mLen);
      }),
        (exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e,
            m,
            eLen = 8 * nBytes - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            i = isLE ? 0 : nBytes - 1,
            d = isLE ? 1 : -1,
            nBytes = value < 0 || (0 === value && 1 / value < 0) ? 1 : 0;
          for (
            value = Math.abs(value),
              isNaN(value) || value === 1 / 0
                ? ((m = isNaN(value) ? 1 : 0), (e = eMax))
                : ((e = Math.floor(Math.log(value) / Math.LN2)),
                  value * (isLE = Math.pow(2, -e)) < 1 && (e--, (isLE *= 2)),
                  2 <=
                    (value +=
                      1 <= e + eBias
                        ? rt / isLE
                        : rt * Math.pow(2, 1 - eBias)) *
                      isLE && (e++, (isLE /= 2)),
                  eMax <= e + eBias
                    ? ((m = 0), (e = eMax))
                    : 1 <= e + eBias
                    ? ((m = (value * isLE - 1) * Math.pow(2, mLen)),
                      (e += eBias))
                    : ((m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)),
                      (e = 0)));
            8 <= mLen;
            buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8
          );
          for (
            e = (e << mLen) | m, eLen += mLen;
            0 < eLen;
            buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8
          );
          buffer[offset + i - d] |= 128 * nBytes;
        });
    },
    4706: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      function ClientBrowser(callServer, options) {
        if (!(this instanceof ClientBrowser))
          return new ClientBrowser(callServer, options);
        (this.options = {
          reviver:
            void 0 !== (options = options || {}).reviver
              ? options.reviver
              : null,
          replacer: void 0 !== options.replacer ? options.replacer : null,
          generator:
            void 0 !== options.generator
              ? options.generator
              : function () {
                  return uuid();
                },
          version: void 0 !== options.version ? options.version : 2,
          notificationIdNull:
            "boolean" == typeof options.notificationIdNull &&
            options.notificationIdNull,
        }),
          (this.callServer = callServer);
      }
      const uuid = __webpack_require__(2793).v4,
        generateRequest = __webpack_require__(9133);
      ((module.exports = ClientBrowser).prototype.request = function (
        method,
        params,
        id,
        callback
      ) {
        const self = this;
        let request = null;
        var isBatch = Array.isArray(method) && "function" == typeof params;
        if (1 === this.options.version && isBatch)
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (
          isBatch ||
          (!isBatch &&
            method &&
            "object" == typeof method &&
            "function" == typeof params)
        )
          (callback = params), (request = method);
        else {
          "function" == typeof id && ((callback = id), (id = void 0));
          isBatch = "function" == typeof callback;
          try {
            request = generateRequest(method, params, id, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull,
            });
          } catch (err) {
            if (isBatch) return callback(err);
            throw err;
          }
          if (!isBatch) return request;
        }
        let message;
        try {
          message = JSON.stringify(request, this.options.replacer);
        } catch (err) {
          return callback(err);
        }
        return (
          this.callServer(message, function (err, response) {
            self._parseResponse(err, response, callback);
          }),
          request
        );
      }),
        (ClientBrowser.prototype._parseResponse = function (
          err,
          responseText,
          callback
        ) {
          if (err) callback(err);
          else {
            if (!responseText) return callback();
            let response;
            try {
              response = JSON.parse(responseText, this.options.reviver);
            } catch (err) {
              return callback(err);
            }
            if (3 === callback.length) {
              if (Array.isArray(response)) {
                const isError = function (res) {
                  return void 0 !== res.error;
                };
                return callback(
                  null,
                  response.filter(isError),
                  response.filter(function (res) {
                    return !isError(res);
                  })
                );
              }
              return callback(null, response.error, response.result);
            }
            callback(null, response);
          }
        });
    },
    9133: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const uuid = __webpack_require__(2793).v4;
      module.exports = function (method, params, id, options) {
        if ("string" != typeof method)
          throw new TypeError(method + " must be a string");
        var version =
          "number" == typeof (options = options || {}).version
            ? options.version
            : 2;
        if (1 !== version && 2 !== version)
          throw new TypeError(version + " must be 1 or 2");
        method = { method: method };
        if ((2 === version && (method.jsonrpc = "2.0"), params)) {
          if ("object" != typeof params && !Array.isArray(params))
            throw new TypeError(
              params + " must be an object, array or omitted"
            );
          method.params = params;
        }
        return (
          void 0 === id
            ? ((params =
                "function" == typeof options.generator
                  ? options.generator
                  : function () {
                      return uuid();
                    }),
              (method.id = params(method, options)))
            : 2 === version && null === id
            ? options.notificationIdNull && (method.id = null)
            : (method.id = id),
          method
        );
      };
    },
    1352: function (__unused_webpack_module, exports) {
      !(function (t) {
        "use strict";
        class e {
          constructor(t, e) {
            (this.state = {
              angle: 0,
              area: [],
              position: { x: 0, y: 0 },
              hardAngle: 0,
              hardDrawingAngle: 0,
            }),
              (this.createdDensity = e),
              (this.nowDrawingDensity = this.createdDensity),
              (this.render = t);
          }
          setDensity(t) {
            (this.createdDensity = t), (this.nowDrawingDensity = t);
          }
          setDrawingDensity(t) {
            this.nowDrawingDensity = t;
          }
          setPosition(t) {
            this.state.position = t;
          }
          setAngle(t) {
            this.state.angle = t;
          }
          setArea(t) {
            this.state.area = t;
          }
          setHardDrawingAngle(t) {
            this.state.hardDrawingAngle = t;
          }
          setHardAngle(t) {
            (this.state.hardAngle = t), (this.state.hardDrawingAngle = t);
          }
          setOrientation(t) {
            this.orientation = t;
          }
          getDrawingDensity() {
            return this.nowDrawingDensity;
          }
          getDensity() {
            return this.createdDensity;
          }
          getHardAngle() {
            return this.state.hardAngle;
          }
        }
        class i extends e {
          constructor(t, e, i) {
            super(t, i),
              (this.image = null),
              (this.isLoad = !1),
              (this.loadingAngle = 0),
              (this.image = new Image()),
              (this.image.src = e);
          }
          draw(t) {
            const e = this.render.getContext(),
              i = this.render.convertToGlobal(this.state.position),
              s = this.render.getRect().pageWidth,
              n = this.render.getRect().height;
            e.save(), e.translate(i.x, i.y), e.beginPath();
            for (let t of this.state.area)
              null !== t &&
                ((t = this.render.convertToGlobal(t)),
                e.lineTo(t.x - i.x, t.y - i.y));
            e.rotate(this.state.angle),
              e.clip(),
              this.isLoad
                ? e.drawImage(this.image, 0, 0, s, n)
                : this.drawLoader(e, { x: 0, y: 0 }, s, n),
              e.restore();
          }
          simpleDraw(t) {
            const e = this.render.getRect(),
              i = this.render.getContext(),
              s = e.pageWidth,
              n = e.height,
              h = 1 === t ? e.left + e.pageWidth : e.left,
              r = e.top;
            this.isLoad
              ? i.drawImage(this.image, h, r, s, n)
              : this.drawLoader(i, { x: h, y: r }, s, n);
          }
          drawLoader(t, e, i, s) {
            t.beginPath(),
              (t.strokeStyle = "rgb(200, 200, 200)"),
              (t.fillStyle = "rgb(255, 255, 255)"),
              (t.lineWidth = 1),
              t.rect(e.x + 1, e.y + 1, i - 1, s - 1),
              t.stroke(),
              t.fill();
            const n = { x: e.x + i / 2, y: e.y + s / 2 };
            t.beginPath(),
              (t.lineWidth = 10),
              t.arc(
                n.x,
                n.y,
                20,
                this.loadingAngle,
                (3 * Math.PI) / 2 + this.loadingAngle
              ),
              t.stroke(),
              t.closePath(),
              (this.loadingAngle += 0.07),
              this.loadingAngle >= 2 * Math.PI && (this.loadingAngle = 0);
          }
          load() {
            this.isLoad ||
              (this.image.onload = () => {
                this.isLoad = !0;
              });
          }
          newTemporaryCopy() {
            return this;
          }
          getTemporaryCopy() {
            return this;
          }
          hideTemporaryCopy() {}
        }
        class s {
          constructor(t, e) {
            (this.pages = []),
              (this.currentPageIndex = 0),
              (this.currentSpreadIndex = 0),
              (this.landscapeSpread = []),
              (this.portraitSpread = []),
              (this.render = e),
              (this.app = t),
              (this.currentPageIndex = 0),
              (this.isShowCover = this.app.getSettings().showCover);
          }
          destroy() {
            this.pages = [];
          }
          createSpread() {
            (this.landscapeSpread = []), (this.portraitSpread = []);
            for (let t = 0; t < this.pages.length; t++)
              this.portraitSpread.push([t]);
            let t = 0;
            this.isShowCover &&
              (this.pages[0].setDensity("hard"),
              this.landscapeSpread.push([t]),
              t++);
            for (let e = t; e < this.pages.length; e += 2)
              e < this.pages.length - 1
                ? this.landscapeSpread.push([e, e + 1])
                : (this.landscapeSpread.push([e]),
                  this.pages[e].setDensity("hard"));
          }
          getSpread() {
            return "landscape" === this.render.getOrientation()
              ? this.landscapeSpread
              : this.portraitSpread;
          }
          getSpreadIndexByPage(t) {
            const e = this.getSpread();
            for (let i = 0; i < e.length; i++)
              if (t === e[i][0] || t === e[i][1]) return i;
            return null;
          }
          getPageCount() {
            return this.pages.length;
          }
          getPages() {
            return this.pages;
          }
          getPage(t) {
            if (t >= 0 && t < this.pages.length) return this.pages[t];
            throw new Error("Invalid page number");
          }
          nextBy(t) {
            const e = this.pages.indexOf(t);
            return e < this.pages.length - 1 ? this.pages[e + 1] : null;
          }
          prevBy(t) {
            const e = this.pages.indexOf(t);
            return e > 0 ? this.pages[e - 1] : null;
          }
          getFlippingPage(t) {
            const e = this.currentSpreadIndex;
            if ("portrait" === this.render.getOrientation())
              return 0 === t
                ? this.pages[e].newTemporaryCopy()
                : this.pages[e - 1];
            {
              const i =
                0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];
              return 1 === i.length || 0 === t
                ? this.pages[i[0]]
                : this.pages[i[1]];
            }
          }
          getBottomPage(t) {
            const e = this.currentSpreadIndex;
            if ("portrait" === this.render.getOrientation())
              return 0 === t ? this.pages[e + 1] : this.pages[e - 1];
            {
              const i =
                0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];
              return 1 === i.length
                ? this.pages[i[0]]
                : 0 === t
                ? this.pages[i[1]]
                : this.pages[i[0]];
            }
          }
          showNext() {
            this.currentSpreadIndex < this.getSpread().length &&
              (this.currentSpreadIndex++, this.showSpread());
          }
          showPrev() {
            this.currentSpreadIndex > 0 &&
              (this.currentSpreadIndex--, this.showSpread());
          }
          getCurrentPageIndex() {
            return this.currentPageIndex;
          }
          show(t = null) {
            if (
              (null === t && (t = this.currentPageIndex),
              t < 0 || t >= this.pages.length)
            )
              return;
            const e = this.getSpreadIndexByPage(t);
            null !== e && ((this.currentSpreadIndex = e), this.showSpread());
          }
          getCurrentSpreadIndex() {
            return this.currentSpreadIndex;
          }
          setCurrentSpreadIndex(t) {
            if (!(t >= 0 && t < this.getSpread().length))
              throw new Error("Invalid page");
            this.currentSpreadIndex = t;
          }
          showSpread() {
            const t = this.getSpread()[this.currentSpreadIndex];
            2 === t.length
              ? (this.render.setLeftPage(this.pages[t[0]]),
                this.render.setRightPage(this.pages[t[1]]))
              : "landscape" === this.render.getOrientation() &&
                t[0] === this.pages.length - 1
              ? (this.render.setLeftPage(this.pages[t[0]]),
                this.render.setRightPage(null))
              : (this.render.setLeftPage(null),
                this.render.setRightPage(this.pages[t[0]])),
              (this.currentPageIndex = t[0]),
              this.app.updatePageIndex(this.currentPageIndex);
          }
        }
        class n extends s {
          constructor(t, e, i) {
            super(t, e), (this.imagesHref = i);
          }
          load() {
            for (const t of this.imagesHref) {
              const e = new i(this.render, t, "soft");
              e.load(), this.pages.push(e);
            }
            this.createSpread();
          }
        }
        class h {
          static GetDistanceBetweenTwoPoint(t, e) {
            return null === t || null === e
              ? 1 / 0
              : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
          }
          static GetSegmentLength(t) {
            return h.GetDistanceBetweenTwoPoint(t[0], t[1]);
          }
          static GetAngleBetweenTwoLine(t, e) {
            const i = t[0].y - t[1].y,
              s = e[0].y - e[1].y,
              n = t[1].x - t[0].x,
              h = e[1].x - e[0].x;
            return Math.acos(
              (i * s + n * h) /
                (Math.sqrt(i * i + n * n) * Math.sqrt(s * s + h * h))
            );
          }
          static PointInRect(t, e) {
            return null === e
              ? null
              : e.x >= t.left &&
                e.x <= t.width + t.left &&
                e.y >= t.top &&
                e.y <= t.top + t.height
              ? e
              : null;
          }
          static GetRotatedPoint(t, e, i) {
            return {
              x: t.x * Math.cos(i) + t.y * Math.sin(i) + e.x,
              y: t.y * Math.cos(i) - t.x * Math.sin(i) + e.y,
            };
          }
          static LimitPointToCircle(t, e, i) {
            if (h.GetDistanceBetweenTwoPoint(t, i) <= e) return i;
            const s = t.x,
              n = t.y,
              r = i.x,
              o = i.y;
            let a =
              Math.sqrt(
                (Math.pow(e, 2) * Math.pow(s - r, 2)) /
                  (Math.pow(s - r, 2) + Math.pow(n - o, 2))
              ) + s;
            i.x < 0 && (a *= -1);
            let g = ((a - s) * (n - o)) / (s - r) + n;
            return s - r + n === 0 && (g = e), { x: a, y: g };
          }
          static GetIntersectBetweenTwoSegment(t, e, i) {
            return h.PointInRect(t, h.GetIntersectBeetwenTwoLine(e, i));
          }
          static GetIntersectBeetwenTwoLine(t, e) {
            const i = t[0].y - t[1].y,
              s = e[0].y - e[1].y,
              n = t[1].x - t[0].x,
              h = e[1].x - e[0].x,
              r = t[0].x * t[1].y - t[1].x * t[0].y,
              o = e[0].x * e[1].y - e[1].x * e[0].y,
              a = i * o - s * r,
              g = n * o - h * r,
              l = -(r * h - o * n) / (i * h - s * n),
              d = -(i * o - s * r) / (i * h - s * n);
            if (isFinite(l) && isFinite(d)) return { x: l, y: d };
            if (Math.abs(a - g) < 0.1) throw new Error("Segment included");
            return null;
          }
          static GetCordsFromTwoPoint(t, e) {
            const i = Math.abs(t.x - e.x),
              s = Math.abs(t.y - e.y),
              n = Math.max(i, s),
              h = [t];
            function r(t, e, i, s, n) {
              return e > t ? t + n * (i / s) : e < t ? t - n * (i / s) : t;
            }
            for (let o = 1; o <= n; o += 1)
              h.push({ x: r(t.x, e.x, i, n, o), y: r(t.y, e.y, s, n, o) });
            return h;
          }
        }
        class r extends e {
          constructor(t, e, i) {
            super(t, i),
              (this.copiedElement = null),
              (this.temporaryCopy = null),
              (this.isLoad = !1),
              (this.element = e),
              this.element.classList.add("stf__item"),
              this.element.classList.add("--" + i);
          }
          newTemporaryCopy() {
            return "hard" === this.nowDrawingDensity
              ? this
              : (null === this.temporaryCopy &&
                  ((this.copiedElement = this.element.cloneNode(!0)),
                  this.element.parentElement.appendChild(this.copiedElement),
                  (this.temporaryCopy = new r(
                    this.render,
                    this.copiedElement,
                    this.nowDrawingDensity
                  ))),
                this.getTemporaryCopy());
          }
          getTemporaryCopy() {
            return this.temporaryCopy;
          }
          hideTemporaryCopy() {
            null !== this.temporaryCopy &&
              (this.copiedElement.remove(),
              (this.copiedElement = null),
              (this.temporaryCopy = null));
          }
          draw(t) {
            const e = t || this.nowDrawingDensity,
              i = this.render.convertToGlobal(this.state.position),
              s = this.render.getRect().pageWidth,
              n = this.render.getRect().height;
            this.element.classList.remove("--simple");
            const h = `\n            display: block;\n            z-index: ${this.element.style.zIndex};\n            left: 0;\n            top: 0;\n            width: ${s}px;\n            height: ${n}px;\n        `;
            "hard" === e ? this.drawHard(h) : this.drawSoft(i, h);
          }
          drawHard(t = "") {
            const e =
                this.render.getRect().left + this.render.getRect().width / 2,
              i = this.state.hardDrawingAngle,
              s =
                t +
                "\n                backface-visibility: hidden;\n                -webkit-backface-visibility: hidden;\n                clip-path: none;\n                -webkit-clip-path: none;\n            " +
                (0 === this.orientation
                  ? `transform-origin: ${
                      this.render.getRect().pageWidth
                    }px 0; \n                   transform: translate3d(0, 0, 0) rotateY(${i}deg);`
                  : `transform-origin: 0 0; \n                   transform: translate3d(${e}px, 0, 0) rotateY(${i}deg);`);
            this.element.style.cssText = s;
          }
          drawSoft(t, e = "") {
            let i = "polygon( ";
            for (const t of this.state.area)
              if (null !== t) {
                let e =
                  1 === this.render.getDirection()
                    ? {
                        x: -t.x + this.state.position.x,
                        y: t.y - this.state.position.y,
                      }
                    : {
                        x: t.x - this.state.position.x,
                        y: t.y - this.state.position.y,
                      };
                (e = h.GetRotatedPoint(e, { x: 0, y: 0 }, this.state.angle)),
                  (i += e.x + "px " + e.y + "px, ");
              }
            (i = i.slice(0, -2)), (i += ")");
            const s =
              e +
              `transform-origin: 0 0; clip-path: ${i}; -webkit-clip-path: ${i};` +
              (this.render.isSafari() && 0 === this.state.angle
                ? `transform: translate(${t.x}px, ${t.y}px);`
                : `transform: translate3d(${t.x}px, ${t.y}px, 0) rotate(${this.state.angle}rad);`);
            this.element.style.cssText = s;
          }
          simpleDraw(t) {
            const e = this.render.getRect(),
              i = e.pageWidth,
              s = e.height,
              n = 1 === t ? e.left + e.pageWidth : e.left,
              h = e.top;
            this.element.classList.add("--simple"),
              (this.element.style.cssText = `\n            position: absolute; \n            display: block; \n            height: ${s}px; \n            left: ${n}px; \n            top: ${h}px; \n            width: ${i}px; \n            z-index: ${
                this.render.getSettings().startZIndex + 1
              };`);
          }
          getElement() {
            return this.element;
          }
          load() {
            this.isLoad = !0;
          }
          setOrientation(t) {
            super.setOrientation(t),
              this.element.classList.remove("--left", "--right"),
              this.element.classList.add(1 === t ? "--right" : "--left");
          }
          setDrawingDensity(t) {
            this.element.classList.remove("--soft", "--hard"),
              this.element.classList.add("--" + t),
              super.setDrawingDensity(t);
          }
        }
        class o extends s {
          constructor(t, e, i, s) {
            super(t, e), (this.element = i), (this.pagesElement = s);
          }
          load() {
            for (const t of this.pagesElement) {
              const e = new r(
                this.render,
                t,
                "hard" === t.dataset.density ? "hard" : "soft"
              );
              e.load(), this.pages.push(e);
            }
            this.createSpread();
          }
        }
        class a {
          constructor(t, e, i, s) {
            (this.direction = t),
              (this.corner = e),
              (this.topIntersectPoint = null),
              (this.sideIntersectPoint = null),
              (this.bottomIntersectPoint = null),
              (this.pageWidth = parseInt(i, 10)),
              (this.pageHeight = parseInt(s, 10));
          }
          calc(t) {
            try {
              return (
                (this.position = this.calcAngleAndPosition(t)),
                this.calculateIntersectPoint(this.position),
                !0
              );
            } catch (t) {
              return !1;
            }
          }
          getFlippingClipArea() {
            const t = [];
            let e = !1;
            return (
              t.push(this.rect.topLeft),
              t.push(this.topIntersectPoint),
              null === this.sideIntersectPoint
                ? (e = !0)
                : (t.push(this.sideIntersectPoint),
                  null === this.bottomIntersectPoint && (e = !1)),
              t.push(this.bottomIntersectPoint),
              (e || "bottom" === this.corner) && t.push(this.rect.bottomLeft),
              t
            );
          }
          getBottomClipArea() {
            const t = [];
            return (
              t.push(this.topIntersectPoint),
              "top" === this.corner
                ? t.push({ x: this.pageWidth, y: 0 })
                : (null !== this.topIntersectPoint &&
                    t.push({ x: this.pageWidth, y: 0 }),
                  t.push({ x: this.pageWidth, y: this.pageHeight })),
              null !== this.sideIntersectPoint
                ? h.GetDistanceBetweenTwoPoint(
                    this.sideIntersectPoint,
                    this.topIntersectPoint
                  ) >= 10 && t.push(this.sideIntersectPoint)
                : "top" === this.corner &&
                  t.push({ x: this.pageWidth, y: this.pageHeight }),
              t.push(this.bottomIntersectPoint),
              t.push(this.topIntersectPoint),
              t
            );
          }
          getAngle() {
            return 0 === this.direction ? -this.angle : this.angle;
          }
          getRect() {
            return this.rect;
          }
          getPosition() {
            return this.position;
          }
          getActiveCorner() {
            return 0 === this.direction
              ? this.rect.topLeft
              : this.rect.topRight;
          }
          getDirection() {
            return this.direction;
          }
          getFlippingProgress() {
            return Math.abs(
              ((this.position.x - this.pageWidth) / (2 * this.pageWidth)) * 100
            );
          }
          getCorner() {
            return this.corner;
          }
          getBottomPagePosition() {
            return 1 === this.direction
              ? { x: this.pageWidth, y: 0 }
              : { x: 0, y: 0 };
          }
          getShadowStartPoint() {
            return "top" === this.corner
              ? this.topIntersectPoint
              : null !== this.sideIntersectPoint
              ? this.sideIntersectPoint
              : this.topIntersectPoint;
          }
          getShadowAngle() {
            const t = h.GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [
              { x: 0, y: 0 },
              { x: this.pageWidth, y: 0 },
            ]);
            return 0 === this.direction ? t : Math.PI - t;
          }
          calcAngleAndPosition(t) {
            let e = t;
            if (
              (this.updateAngleAndGeometry(e),
              (e =
                "top" === this.corner
                  ? this.checkPositionAtCenterLine(
                      e,
                      { x: 0, y: 0 },
                      { x: 0, y: this.pageHeight }
                    )
                  : this.checkPositionAtCenterLine(
                      e,
                      { x: 0, y: this.pageHeight },
                      { x: 0, y: 0 }
                    )),
              Math.abs(e.x - this.pageWidth) < 1 && Math.abs(e.y) < 1)
            )
              throw new Error("Point is too small");
            return e;
          }
          updateAngleAndGeometry(t) {
            (this.angle = this.calculateAngle(t)),
              (this.rect = this.getPageRect(t));
          }
          calculateAngle(t) {
            const e = this.pageWidth - t.x + 1,
              i = "bottom" === this.corner ? this.pageHeight - t.y : t.y;
            let s = 2 * Math.acos(e / Math.sqrt(i * i + e * e));
            i < 0 && (s = -s);
            const n = Math.PI - s;
            if (!isFinite(s) || (n >= 0 && n < 0.003))
              throw new Error("The G point is too small");
            return "bottom" === this.corner && (s = -s), s;
          }
          getPageRect(t) {
            return "top" === this.corner
              ? this.getRectFromBasePoint(
                  [
                    { x: 0, y: 0 },
                    { x: this.pageWidth, y: 0 },
                    { x: 0, y: this.pageHeight },
                    { x: this.pageWidth, y: this.pageHeight },
                  ],
                  t
                )
              : this.getRectFromBasePoint(
                  [
                    { x: 0, y: -this.pageHeight },
                    { x: this.pageWidth, y: -this.pageHeight },
                    { x: 0, y: 0 },
                    { x: this.pageWidth, y: 0 },
                  ],
                  t
                );
          }
          getRectFromBasePoint(t, e) {
            return {
              topLeft: this.getRotatedPoint(t[0], e),
              topRight: this.getRotatedPoint(t[1], e),
              bottomLeft: this.getRotatedPoint(t[2], e),
              bottomRight: this.getRotatedPoint(t[3], e),
            };
          }
          getRotatedPoint(t, e) {
            return {
              x: t.x * Math.cos(this.angle) + t.y * Math.sin(this.angle) + e.x,
              y: t.y * Math.cos(this.angle) - t.x * Math.sin(this.angle) + e.y,
            };
          }
          calculateIntersectPoint(t) {
            const e = {
              left: -1,
              top: -1,
              width: this.pageWidth + 2,
              height: this.pageHeight + 2,
            };
            "top" === this.corner
              ? ((this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [t, this.rect.topRight],
                  [
                    { x: 0, y: 0 },
                    { x: this.pageWidth, y: 0 },
                  ]
                )),
                (this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [t, this.rect.bottomLeft],
                  [
                    { x: this.pageWidth, y: 0 },
                    { x: this.pageWidth, y: this.pageHeight },
                  ]
                )),
                (this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [this.rect.bottomLeft, this.rect.bottomRight],
                  [
                    { x: 0, y: this.pageHeight },
                    { x: this.pageWidth, y: this.pageHeight },
                  ]
                )))
              : ((this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [this.rect.topLeft, this.rect.topRight],
                  [
                    { x: 0, y: 0 },
                    { x: this.pageWidth, y: 0 },
                  ]
                )),
                (this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [t, this.rect.topLeft],
                  [
                    { x: this.pageWidth, y: 0 },
                    { x: this.pageWidth, y: this.pageHeight },
                  ]
                )),
                (this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(
                  e,
                  [this.rect.bottomLeft, this.rect.bottomRight],
                  [
                    { x: 0, y: this.pageHeight },
                    { x: this.pageWidth, y: this.pageHeight },
                  ]
                )));
          }
          checkPositionAtCenterLine(t, e, i) {
            let s = t;
            const n = h.LimitPointToCircle(e, this.pageWidth, s);
            s !== n && ((s = n), this.updateAngleAndGeometry(s));
            const r = Math.sqrt(
              Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2)
            );
            let o = this.rect.bottomRight,
              a = this.rect.topLeft;
            if (
              ("bottom" === this.corner &&
                ((o = this.rect.topRight), (a = this.rect.bottomLeft)),
              o.x <= 0)
            ) {
              const t = h.LimitPointToCircle(i, r, a);
              t !== s && ((s = t), this.updateAngleAndGeometry(s));
            }
            return s;
          }
          getSegmentToShadowLine() {
            const t = this.getShadowStartPoint();
            return [
              t,
              t !== this.sideIntersectPoint && null !== this.sideIntersectPoint
                ? this.sideIntersectPoint
                : this.bottomIntersectPoint,
            ];
          }
        }
        class g {
          constructor(t, e) {
            (this.flippingPage = null),
              (this.bottomPage = null),
              (this.calc = null),
              (this.state = "read"),
              (this.render = t),
              (this.app = e);
          }
          fold(t) {
            this.setState("user_fold"),
              null === this.calc && this.start(t),
              this.do(this.render.convertToPage(t));
          }
          flip(t) {
            if (
              this.app.getSettings().disableFlipByClick &&
              !this.isPointOnCorners(t)
            )
              return;
            if (
              (null !== this.calc && this.render.finishAnimation(),
              !this.start(t))
            )
              return;
            const e = this.getBoundsRect();
            this.setState("flipping");
            const i = e.height / 10,
              s = "bottom" === this.calc.getCorner() ? e.height - i : i,
              n = "bottom" === this.calc.getCorner() ? e.height : 0;
            this.calc.calc({ x: e.pageWidth - i, y: s }),
              this.animateFlippingTo(
                { x: e.pageWidth - i, y: s },
                { x: -e.pageWidth, y: n },
                !0
              );
          }
          start(t) {
            this.reset();
            const e = this.render.convertToBook(t),
              i = this.getBoundsRect(),
              s = this.getDirectionByPoint(e),
              n = e.y >= i.height / 2 ? "bottom" : "top";
            if (!this.checkDirection(s)) return !1;
            try {
              if (
                ((this.flippingPage = this.app
                  .getPageCollection()
                  .getFlippingPage(s)),
                (this.bottomPage = this.app
                  .getPageCollection()
                  .getBottomPage(s)),
                "landscape" === this.render.getOrientation())
              )
                if (1 === s) {
                  const t = this.app
                    .getPageCollection()
                    .nextBy(this.flippingPage);
                  null !== t &&
                    this.flippingPage.getDensity() !== t.getDensity() &&
                    (this.flippingPage.setDrawingDensity("hard"),
                    t.setDrawingDensity("hard"));
                } else {
                  const t = this.app
                    .getPageCollection()
                    .prevBy(this.flippingPage);
                  null !== t &&
                    this.flippingPage.getDensity() !== t.getDensity() &&
                    (this.flippingPage.setDrawingDensity("hard"),
                    t.setDrawingDensity("hard"));
                }
              return (
                this.render.setDirection(s),
                (this.calc = new a(
                  s,
                  n,
                  i.pageWidth.toString(10),
                  i.height.toString(10)
                )),
                !0
              );
            } catch (t) {
              return !1;
            }
          }
          do(t) {
            if (null !== this.calc && this.calc.calc(t)) {
              const t = this.calc.getFlippingProgress();
              this.bottomPage.setArea(this.calc.getBottomClipArea()),
                this.bottomPage.setPosition(this.calc.getBottomPagePosition()),
                this.bottomPage.setAngle(0),
                this.bottomPage.setHardAngle(0),
                this.flippingPage.setArea(this.calc.getFlippingClipArea()),
                this.flippingPage.setPosition(this.calc.getActiveCorner()),
                this.flippingPage.setAngle(this.calc.getAngle()),
                0 === this.calc.getDirection()
                  ? this.flippingPage.setHardAngle((90 * (200 - 2 * t)) / 100)
                  : this.flippingPage.setHardAngle((-90 * (200 - 2 * t)) / 100),
                this.render.setPageRect(this.calc.getRect()),
                this.render.setBottomPage(this.bottomPage),
                this.render.setFlippingPage(this.flippingPage),
                this.render.setShadowData(
                  this.calc.getShadowStartPoint(),
                  this.calc.getShadowAngle(),
                  t,
                  this.calc.getDirection()
                );
            }
          }
          flipToPage(t, e) {
            const i = this.app.getPageCollection().getCurrentSpreadIndex(),
              s = this.app.getPageCollection().getSpreadIndexByPage(t);
            try {
              s > i &&
                (this.app.getPageCollection().setCurrentSpreadIndex(s - 1),
                this.flipNext(e)),
                s < i &&
                  (this.app.getPageCollection().setCurrentSpreadIndex(s + 1),
                  this.flipPrev(e));
            } catch (t) {}
          }
          flipNext(t) {
            this.flip({
              x:
                this.render.getRect().left +
                2 * this.render.getRect().pageWidth -
                10,
              y: "top" === t ? 1 : this.render.getRect().height - 2,
            });
          }
          flipPrev(t) {
            this.flip({
              x: 10,
              y: "top" === t ? 1 : this.render.getRect().height - 2,
            });
          }
          stopMove() {
            if (null === this.calc) return;
            const t = this.calc.getPosition(),
              e = this.getBoundsRect(),
              i = "bottom" === this.calc.getCorner() ? e.height : 0;
            t.x <= 0
              ? this.animateFlippingTo(t, { x: -e.pageWidth, y: i }, !0)
              : this.animateFlippingTo(t, { x: e.pageWidth, y: i }, !1);
          }
          showCorner(t) {
            if (!this.checkState("read", "fold_corner")) return;
            const e = this.getBoundsRect(),
              i = e.pageWidth;
            if (this.isPointOnCorners(t))
              if (null === this.calc) {
                if (!this.start(t)) return;
                this.setState("fold_corner"),
                  this.calc.calc({ x: i - 1, y: 1 });
                const s = 50,
                  n = "bottom" === this.calc.getCorner() ? e.height - 1 : 1,
                  h = "bottom" === this.calc.getCorner() ? e.height - s : s;
                this.animateFlippingTo(
                  { x: i - 1, y: n },
                  { x: i - s, y: h },
                  !1,
                  !1
                );
              } else this.do(this.render.convertToPage(t));
            else
              this.setState("read"),
                this.render.finishAnimation(),
                this.stopMove();
          }
          animateFlippingTo(t, e, i, s = !0) {
            const n = h.GetCordsFromTwoPoint(t, e),
              r = [];
            for (const t of n) r.push(() => this.do(t));
            const o = this.getAnimationDuration(n.length);
            this.render.startAnimation(r, o, () => {
              this.calc &&
                (i &&
                  (1 === this.calc.getDirection()
                    ? this.app.turnToPrevPage()
                    : this.app.turnToNextPage()),
                s &&
                  (this.render.setBottomPage(null),
                  this.render.setFlippingPage(null),
                  this.render.clearShadow(),
                  this.setState("read"),
                  this.reset()));
            });
          }
          getCalculation() {
            return this.calc;
          }
          getState() {
            return this.state;
          }
          setState(t) {
            this.state !== t && (this.app.updateState(t), (this.state = t));
          }
          getDirectionByPoint(t) {
            const e = this.getBoundsRect();
            if ("portrait" === this.render.getOrientation()) {
              if (t.x - e.pageWidth <= e.width / 5) return 1;
            } else if (t.x < e.width / 2) return 1;
            return 0;
          }
          getAnimationDuration(t) {
            const e = this.app.getSettings().flippingTime;
            return t >= 1e3 ? e : (t / 1e3) * e;
          }
          checkDirection(t) {
            return 0 === t
              ? this.app.getCurrentPageIndex() < this.app.getPageCount() - 1
              : this.app.getCurrentPageIndex() >= 1;
          }
          reset() {
            (this.calc = null),
              (this.flippingPage = null),
              (this.bottomPage = null);
          }
          getBoundsRect() {
            return this.render.getRect();
          }
          checkState(...t) {
            for (const e of t) if (this.state === e) return !0;
            return !1;
          }
          isPointOnCorners(t) {
            const e = this.getBoundsRect(),
              i = e.pageWidth,
              s = Math.sqrt(Math.pow(i, 2) + Math.pow(e.height, 2)) / 5,
              n = this.render.convertToBook(t);
            return (
              n.x > 0 &&
              n.y > 0 &&
              n.x < e.width &&
              n.y < e.height &&
              (n.x < s || n.x > e.width - s) &&
              (n.y < s || n.y > e.height - s)
            );
          }
        }
        class l {
          constructor(t, e) {
            (this.leftPage = null),
              (this.rightPage = null),
              (this.flippingPage = null),
              (this.bottomPage = null),
              (this.direction = null),
              (this.orientation = null),
              (this.shadow = null),
              (this.animation = null),
              (this.pageRect = null),
              (this.boundsRect = null),
              (this.timer = 0),
              (this.safari = !1),
              (this.setting = e),
              (this.app = t);
            const i = new RegExp("Version\\/[\\d\\.]+.*Safari/");
            this.safari = null !== i.exec(window.navigator.userAgent);
          }
          render(t) {
            if (null !== this.animation) {
              const e = Math.round(
                (t - this.animation.startedAt) / this.animation.durationFrame
              );
              e < this.animation.frames.length
                ? this.animation.frames[e]()
                : (this.animation.onAnimateEnd(), (this.animation = null));
            }
            (this.timer = t), this.drawFrame();
          }
          start() {
            this.update();
            const t = (e) => {
              this.render(e), requestAnimationFrame(t);
            };
            requestAnimationFrame(t);
          }
          startAnimation(t, e, i) {
            this.finishAnimation(),
              (this.animation = {
                frames: t,
                duration: e,
                durationFrame: e / t.length,
                onAnimateEnd: i,
                startedAt: this.timer,
              });
          }
          finishAnimation() {
            null !== this.animation &&
              (this.animation.frames[this.animation.frames.length - 1](),
              null !== this.animation.onAnimateEnd &&
                this.animation.onAnimateEnd()),
              (this.animation = null);
          }
          update() {
            this.boundsRect = null;
            const t = this.calculateBoundsRect();
            this.orientation !== t &&
              ((this.orientation = t), this.app.updateOrientation(t));
          }
          calculateBoundsRect() {
            let t = "landscape";
            const e = this.getBlockWidth(),
              i = e / 2,
              s = this.getBlockHeight() / 2,
              n = this.setting.width / this.setting.height;
            let h = this.setting.width,
              r = this.setting.height,
              o = i - h;
            return (
              "stretch" === this.setting.size
                ? (e < 2 * this.setting.minWidth &&
                    this.app.getSettings().usePortrait &&
                    (t = "portrait"),
                  (h =
                    "portrait" === t
                      ? this.getBlockWidth()
                      : this.getBlockWidth() / 2),
                  h > this.setting.maxWidth && (h = this.setting.maxWidth),
                  (r = h / n),
                  r > this.getBlockHeight() &&
                    ((r = this.getBlockHeight()), (h = r * n)),
                  (o = "portrait" === t ? i - h / 2 - h : i - h))
                : e < 2 * h &&
                  this.app.getSettings().usePortrait &&
                  ((t = "portrait"), (o = i - h / 2 - h)),
              (this.boundsRect = {
                left: o,
                top: s - r / 2,
                width: 2 * h,
                height: r,
                pageWidth: h,
              }),
              t
            );
          }
          setShadowData(t, e, i, s) {
            if (!this.app.getSettings().drawShadow) return;
            const n = 100 * this.getSettings().maxShadowOpacity;
            this.shadow = {
              pos: t,
              angle: e,
              width: (((3 * this.getRect().pageWidth) / 4) * i) / 100,
              opacity: ((100 - i) * n) / 100 / 100,
              direction: s,
              progress: 2 * i,
            };
          }
          clearShadow() {
            this.shadow = null;
          }
          getBlockWidth() {
            return this.app.getUI().getDistElement().offsetWidth;
          }
          getBlockHeight() {
            return this.app.getUI().getDistElement().offsetHeight;
          }
          getDirection() {
            return this.direction;
          }
          getRect() {
            return (
              null === this.boundsRect && this.calculateBoundsRect(),
              this.boundsRect
            );
          }
          getSettings() {
            return this.app.getSettings();
          }
          getOrientation() {
            return this.orientation;
          }
          setPageRect(t) {
            this.pageRect = t;
          }
          setDirection(t) {
            this.direction = t;
          }
          setRightPage(t) {
            null !== t && t.setOrientation(1), (this.rightPage = t);
          }
          setLeftPage(t) {
            null !== t && t.setOrientation(0), (this.leftPage = t);
          }
          setBottomPage(t) {
            null !== t && t.setOrientation(1 === this.direction ? 0 : 1),
              (this.bottomPage = t);
          }
          setFlippingPage(t) {
            null !== t &&
              t.setOrientation(
                0 === this.direction && "portrait" !== this.orientation ? 0 : 1
              ),
              (this.flippingPage = t);
          }
          convertToBook(t) {
            const e = this.getRect();
            return { x: t.x - e.left, y: t.y - e.top };
          }
          isSafari() {
            return this.safari;
          }
          convertToPage(t, e) {
            e || (e = this.direction);
            const i = this.getRect();
            return {
              x:
                0 === e
                  ? t.x - i.left - i.width / 2
                  : i.width / 2 - t.x + i.left,
              y: t.y - i.top,
            };
          }
          convertToGlobal(t, e) {
            if ((e || (e = this.direction), null == t)) return null;
            const i = this.getRect();
            return {
              x:
                0 === e
                  ? t.x + i.left + i.width / 2
                  : i.width / 2 - t.x + i.left,
              y: t.y + i.top,
            };
          }
          convertRectToGlobal(t, e) {
            return (
              e || (e = this.direction),
              {
                topLeft: this.convertToGlobal(t.topLeft, e),
                topRight: this.convertToGlobal(t.topRight, e),
                bottomLeft: this.convertToGlobal(t.bottomLeft, e),
                bottomRight: this.convertToGlobal(t.bottomRight, e),
              }
            );
          }
        }
        class d extends l {
          constructor(t, e, i) {
            super(t, e), (this.canvas = i), (this.ctx = i.getContext("2d"));
          }
          getContext() {
            return this.ctx;
          }
          reload() {}
          drawFrame() {
            this.clear(),
              "portrait" !== this.orientation &&
                null != this.leftPage &&
                this.leftPage.simpleDraw(0),
              null != this.rightPage && this.rightPage.simpleDraw(1),
              null != this.bottomPage && this.bottomPage.draw(),
              this.drawBookShadow(),
              null != this.flippingPage && this.flippingPage.draw(),
              null != this.shadow &&
                (this.drawOuterShadow(), this.drawInnerShadow());
            const t = this.getRect();
            "portrait" === this.orientation &&
              (this.ctx.beginPath(),
              this.ctx.rect(t.left + t.pageWidth, t.top, t.width, t.height),
              this.ctx.clip());
          }
          drawBookShadow() {
            const t = this.getRect();
            this.ctx.save(), this.ctx.beginPath();
            const e = t.width / 20;
            this.ctx.rect(t.left, t.top, t.width, t.height);
            const i = { x: t.left + t.width / 2 - e / 2, y: 0 };
            this.ctx.translate(i.x, i.y);
            const s = this.ctx.createLinearGradient(0, 0, e, 0);
            s.addColorStop(0, "rgba(0, 0, 0, 0)"),
              s.addColorStop(0.4, "rgba(0, 0, 0, 0.2)"),
              s.addColorStop(0.49, "rgba(0, 0, 0, 0.1)"),
              s.addColorStop(0.5, "rgba(0, 0, 0, 0.5)"),
              s.addColorStop(0.51, "rgba(0, 0, 0, 0.4)"),
              s.addColorStop(1, "rgba(0, 0, 0, 0)"),
              this.ctx.clip(),
              (this.ctx.fillStyle = s),
              this.ctx.fillRect(0, 0, e, 2 * t.height),
              this.ctx.restore();
          }
          drawOuterShadow() {
            const t = this.getRect();
            this.ctx.save(),
              this.ctx.beginPath(),
              this.ctx.rect(t.left, t.top, t.width, t.height);
            const e = this.convertToGlobal({
              x: this.shadow.pos.x,
              y: this.shadow.pos.y,
            });
            this.ctx.translate(e.x, e.y),
              this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);
            const i = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);
            0 === this.shadow.direction
              ? (this.ctx.translate(0, -100),
                i.addColorStop(0, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                i.addColorStop(1, "rgba(0, 0, 0, 0)"))
              : (this.ctx.translate(-this.shadow.width, -100),
                i.addColorStop(0, "rgba(0, 0, 0, 0)"),
                i.addColorStop(
                  1,
                  "rgba(0, 0, 0, " + this.shadow.opacity + ")"
                )),
              this.ctx.clip(),
              (this.ctx.fillStyle = i),
              this.ctx.fillRect(0, 0, this.shadow.width, 2 * t.height),
              this.ctx.restore();
          }
          drawInnerShadow() {
            const t = this.getRect();
            this.ctx.save(), this.ctx.beginPath();
            const e = this.convertToGlobal({
                x: this.shadow.pos.x,
                y: this.shadow.pos.y,
              }),
              i = this.convertRectToGlobal(this.pageRect);
            this.ctx.moveTo(i.topLeft.x, i.topLeft.y),
              this.ctx.lineTo(i.topRight.x, i.topRight.y),
              this.ctx.lineTo(i.bottomRight.x, i.bottomRight.y),
              this.ctx.lineTo(i.bottomLeft.x, i.bottomLeft.y),
              this.ctx.translate(e.x, e.y),
              this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);
            const s = (3 * this.shadow.width) / 4,
              n = this.ctx.createLinearGradient(0, 0, s, 0);
            0 === this.shadow.direction
              ? (this.ctx.translate(-s, -100),
                n.addColorStop(1, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                n.addColorStop(0.9, "rgba(0, 0, 0, 0.05)"),
                n.addColorStop(
                  0.7,
                  "rgba(0, 0, 0, " + this.shadow.opacity + ")"
                ),
                n.addColorStop(0, "rgba(0, 0, 0, 0)"))
              : (this.ctx.translate(0, -100),
                n.addColorStop(0, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                n.addColorStop(0.1, "rgba(0, 0, 0, 0.05)"),
                n.addColorStop(
                  0.3,
                  "rgba(0, 0, 0, " + this.shadow.opacity + ")"
                ),
                n.addColorStop(1, "rgba(0, 0, 0, 0)")),
              this.ctx.clip(),
              (this.ctx.fillStyle = n),
              this.ctx.fillRect(0, 0, s, 2 * t.height),
              this.ctx.restore();
          }
          clear() {
            (this.ctx.fillStyle = "white"),
              this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          }
        }
        class p {
          constructor(t, e, i) {
            (this.touchPoint = null),
              (this.swipeTimeout = 250),
              (this.onResize = () => {
                this.update();
              }),
              (this.onMouseDown = (t) => {
                if (this.checkTarget(t.target)) {
                  const e = this.getMousePos(t.clientX, t.clientY);
                  this.app.startUserTouch(e), t.preventDefault();
                }
              }),
              (this.onTouchStart = (t) => {
                if (this.checkTarget(t.target) && t.changedTouches.length > 0) {
                  const e = t.changedTouches[0],
                    i = this.getMousePos(e.clientX, e.clientY);
                  (this.touchPoint = { point: i, time: Date.now() }),
                    setTimeout(() => {
                      null !== this.touchPoint && this.app.startUserTouch(i);
                    }, this.swipeTimeout),
                    this.app.getSettings().mobileScrollSupport ||
                      t.preventDefault();
                }
              }),
              (this.onMouseUp = (t) => {
                const e = this.getMousePos(t.clientX, t.clientY);
                this.app.userStop(e);
              }),
              (this.onMouseMove = (t) => {
                const e = this.getMousePos(t.clientX, t.clientY);
                this.app.userMove(e, !1);
              }),
              (this.onTouchMove = (t) => {
                if (t.changedTouches.length > 0) {
                  const e = t.changedTouches[0],
                    i = this.getMousePos(e.clientX, e.clientY);
                  this.app.getSettings().mobileScrollSupport
                    ? (null !== this.touchPoint &&
                        (Math.abs(this.touchPoint.point.x - i.x) > 10 ||
                          "read" !== this.app.getState()) &&
                        t.cancelable &&
                        this.app.userMove(i, !0),
                      "read" !== this.app.getState() && t.preventDefault())
                    : this.app.userMove(i, !0);
                }
              }),
              (this.onTouchEnd = (t) => {
                if (t.changedTouches.length > 0) {
                  const e = t.changedTouches[0],
                    i = this.getMousePos(e.clientX, e.clientY);
                  let s = !1;
                  if (null !== this.touchPoint) {
                    const t = i.x - this.touchPoint.point.x,
                      e = Math.abs(i.y - this.touchPoint.point.y);
                    Math.abs(t) > this.swipeDistance &&
                      e < 2 * this.swipeDistance &&
                      Date.now() - this.touchPoint.time < this.swipeTimeout &&
                      (t > 0
                        ? this.app.flipPrev(
                            this.touchPoint.point.y <
                              this.app.getRender().getRect().height / 2
                              ? "top"
                              : "bottom"
                          )
                        : this.app.flipNext(
                            this.touchPoint.point.y <
                              this.app.getRender().getRect().height / 2
                              ? "top"
                              : "bottom"
                          ),
                      (s = !0)),
                      (this.touchPoint = null);
                  }
                  this.app.userStop(i, s);
                }
              }),
              (this.parentElement = t),
              t.classList.add("stf__parent"),
              t.insertAdjacentHTML(
                "afterbegin",
                '<div class="stf__wrapper"></div>'
              ),
              (this.wrapper = t.querySelector(".stf__wrapper")),
              (this.app = e);
            const s = this.app.getSettings().usePortrait ? 1 : 2;
            (t.style.minWidth = i.minWidth * s + "px"),
              (t.style.minHeight = i.minHeight + "px"),
              "fixed" === i.size &&
                ((t.style.minWidth = i.width * s + "px"),
                (t.style.minHeight = i.height + "px")),
              i.autoSize &&
                ((t.style.width = "100%"),
                (t.style.maxWidth = 2 * i.maxWidth + "px")),
              (t.style.display = "block"),
              window.addEventListener("resize", this.onResize, !1),
              (this.swipeDistance = i.swipeDistance);
          }
          destroy() {
            this.app.getSettings().useMouseEvents && this.removeHandlers(),
              this.distElement.remove(),
              this.wrapper.remove();
          }
          getDistElement() {
            return this.distElement;
          }
          getWrapper() {
            return this.wrapper;
          }
          setOrientationStyle(t) {
            this.wrapper.classList.remove("--portrait", "--landscape"),
              "portrait" === t
                ? (this.app.getSettings().autoSize &&
                    (this.wrapper.style.paddingBottom =
                      (this.app.getSettings().height /
                        this.app.getSettings().width) *
                        100 +
                      "%"),
                  this.wrapper.classList.add("--portrait"))
                : (this.app.getSettings().autoSize &&
                    (this.wrapper.style.paddingBottom =
                      (this.app.getSettings().height /
                        (2 * this.app.getSettings().width)) *
                        100 +
                      "%"),
                  this.wrapper.classList.add("--landscape")),
              this.update();
          }
          removeHandlers() {
            window.removeEventListener("resize", this.onResize),
              this.distElement.removeEventListener(
                "mousedown",
                this.onMouseDown
              ),
              this.distElement.removeEventListener(
                "touchstart",
                this.onTouchStart
              ),
              window.removeEventListener("mousemove", this.onMouseMove),
              window.removeEventListener("touchmove", this.onTouchMove),
              window.removeEventListener("mouseup", this.onMouseUp),
              window.removeEventListener("touchend", this.onTouchEnd);
          }
          setHandlers() {
            window.addEventListener("resize", this.onResize, !1),
              this.app.getSettings().useMouseEvents &&
                (this.distElement.addEventListener(
                  "mousedown",
                  this.onMouseDown
                ),
                this.distElement.addEventListener(
                  "touchstart",
                  this.onTouchStart
                ),
                window.addEventListener("mousemove", this.onMouseMove),
                window.addEventListener("touchmove", this.onTouchMove, {
                  passive: !this.app.getSettings().mobileScrollSupport,
                }),
                window.addEventListener("mouseup", this.onMouseUp),
                window.addEventListener("touchend", this.onTouchEnd));
          }
          getMousePos(t, e) {
            const i = this.distElement.getBoundingClientRect();
            return { x: t - i.left, y: e - i.top };
          }
          checkTarget(t) {
            return (
              !this.app.getSettings().clickEventForward ||
              !["a", "button"].includes(t.tagName.toLowerCase())
            );
          }
        }
        class c extends p {
          constructor(t, e, i, s) {
            super(t, e, i),
              this.wrapper.insertAdjacentHTML(
                "afterbegin",
                '<div class="stf__block"></div>'
              ),
              (this.distElement = t.querySelector(".stf__block")),
              (this.items = s);
            for (const t of s) this.distElement.appendChild(t);
            this.setHandlers();
          }
          clear() {
            for (const t of this.items) this.parentElement.appendChild(t);
          }
          updateItems(t) {
            this.removeHandlers(), (this.distElement.innerHTML = "");
            for (const e of t) this.distElement.appendChild(e);
            (this.items = t), this.setHandlers();
          }
          update() {
            this.app.getRender().update();
          }
        }
        class u extends p {
          constructor(t, e, i) {
            super(t, e, i),
              (this.wrapper.innerHTML =
                '<canvas class="stf__canvas"></canvas>'),
              (this.canvas = t.querySelectorAll("canvas")[0]),
              (this.distElement = this.canvas),
              this.resizeCanvas(),
              this.setHandlers();
          }
          resizeCanvas() {
            const t = getComputedStyle(this.canvas),
              e = parseInt(t.getPropertyValue("width"), 10),
              i = parseInt(t.getPropertyValue("height"), 10);
            (this.canvas.width = e), (this.canvas.height = i);
          }
          getCanvas() {
            return this.canvas;
          }
          update() {
            this.resizeCanvas(), this.app.getRender().update();
          }
        }
        class w extends l {
          constructor(t, e, i) {
            super(t, e),
              (this.outerShadow = null),
              (this.innerShadow = null),
              (this.hardShadow = null),
              (this.hardInnerShadow = null),
              (this.element = i),
              this.createShadows();
          }
          createShadows() {
            this.element.insertAdjacentHTML(
              "beforeend",
              '<div class="stf__outerShadow"></div>\n             <div class="stf__innerShadow"></div>\n             <div class="stf__hardShadow"></div>\n             <div class="stf__hardInnerShadow"></div>'
            ),
              (this.outerShadow =
                this.element.querySelector(".stf__outerShadow")),
              (this.innerShadow =
                this.element.querySelector(".stf__innerShadow")),
              (this.hardShadow =
                this.element.querySelector(".stf__hardShadow")),
              (this.hardInnerShadow = this.element.querySelector(
                ".stf__hardInnerShadow"
              ));
          }
          clearShadow() {
            super.clearShadow(),
              (this.outerShadow.style.cssText = "display: none"),
              (this.innerShadow.style.cssText = "display: none"),
              (this.hardShadow.style.cssText = "display: none"),
              (this.hardInnerShadow.style.cssText = "display: none");
          }
          reload() {
            this.element.querySelector(".stf__outerShadow") ||
              this.createShadows();
          }
          drawHardInnerShadow() {
            const t = this.getRect(),
              e =
                this.shadow.progress > 100
                  ? 200 - this.shadow.progress
                  : this.shadow.progress;
            let i = ((100 - e) * (2.5 * t.pageWidth)) / 100 + 20;
            i > t.pageWidth && (i = t.pageWidth);
            let s = `\n            display: block;\n            z-index: ${(
              this.getSettings().startZIndex + 5
            ).toString(10)};\n            width: ${i}px;\n            height: ${
              t.height
            }px;\n            background: linear-gradient(to right,\n                rgba(0, 0, 0, ${
              (this.shadow.opacity * e) / 100
            }) 5%,\n                rgba(0, 0, 0, 0) 100%);\n            left: ${
              t.left + t.width / 2
            }px;\n            transform-origin: 0 0;\n        `;
            (s +=
              (0 === this.getDirection() && this.shadow.progress > 100) ||
              (1 === this.getDirection() && this.shadow.progress <= 100)
                ? "transform: translate3d(0, 0, 0);"
                : "transform: translate3d(0, 0, 0) rotateY(180deg);"),
              (this.hardInnerShadow.style.cssText = s);
          }
          drawHardOuterShadow() {
            const t = this.getRect();
            let e =
              ((100 -
                (this.shadow.progress > 100
                  ? 200 - this.shadow.progress
                  : this.shadow.progress)) *
                (2.5 * t.pageWidth)) /
                100 +
              20;
            e > t.pageWidth && (e = t.pageWidth);
            let i = `\n            display: block;\n            z-index: ${(
              this.getSettings().startZIndex + 4
            ).toString(10)};\n            width: ${e}px;\n            height: ${
              t.height
            }px;\n            background: linear-gradient(to left, rgba(0, 0, 0, ${
              this.shadow.opacity
            }) 5%, rgba(0, 0, 0, 0) 100%);\n            left: ${
              t.left + t.width / 2
            }px;\n            transform-origin: 0 0;\n        `;
            (i +=
              (0 === this.getDirection() && this.shadow.progress > 100) ||
              (1 === this.getDirection() && this.shadow.progress <= 100)
                ? "transform: translate3d(0, 0, 0) rotateY(180deg);"
                : "transform: translate3d(0, 0, 0);"),
              (this.hardShadow.style.cssText = i);
          }
          drawInnerShadow() {
            const t = this.getRect(),
              e = (3 * this.shadow.width) / 4,
              i = 0 === this.getDirection() ? e : 0,
              s = 0 === this.getDirection() ? "to left" : "to right",
              n = this.convertToGlobal(this.shadow.pos),
              r = this.shadow.angle + (3 * Math.PI) / 2,
              o = [
                this.pageRect.topLeft,
                this.pageRect.topRight,
                this.pageRect.bottomRight,
                this.pageRect.bottomLeft,
              ];
            let a = "polygon( ";
            for (const t of o) {
              let e =
                1 === this.getDirection()
                  ? { x: -t.x + this.shadow.pos.x, y: t.y - this.shadow.pos.y }
                  : { x: t.x - this.shadow.pos.x, y: t.y - this.shadow.pos.y };
              (e = h.GetRotatedPoint(e, { x: i, y: 100 }, r)),
                (a += e.x + "px " + e.y + "px, ");
            }
            (a = a.slice(0, -2)), (a += ")");
            const g = `\n            display: block;\n            z-index: ${(
              this.getSettings().startZIndex + 10
            ).toString(10)};\n            width: ${e}px;\n            height: ${
              2 * t.height
            }px;\n            background: linear-gradient(${s},\n                rgba(0, 0, 0, ${
              this.shadow.opacity
            }) 5%,\n                rgba(0, 0, 0, 0.05) 15%,\n                rgba(0, 0, 0, ${
              this.shadow.opacity
            }) 35%,\n                rgba(0, 0, 0, 0) 100%);\n            transform-origin: ${i}px 100px;\n            transform: translate3d(${
              n.x - i
            }px, ${
              n.y - 100
            }px, 0) rotate(${r}rad);\n            clip-path: ${a};\n            -webkit-clip-path: ${a};\n        `;
            this.innerShadow.style.cssText = g;
          }
          drawOuterShadow() {
            const t = this.getRect(),
              e = this.convertToGlobal({
                x: this.shadow.pos.x,
                y: this.shadow.pos.y,
              }),
              i = this.shadow.angle + (3 * Math.PI) / 2,
              s = 1 === this.getDirection() ? this.shadow.width : 0,
              n = 0 === this.getDirection() ? "to right" : "to left",
              r = [
                { x: 0, y: 0 },
                { x: t.pageWidth, y: 0 },
                { x: t.pageWidth, y: t.height },
                { x: 0, y: t.height },
              ];
            let o = "polygon( ";
            for (const t of r)
              if (null !== t) {
                let e =
                  1 === this.getDirection()
                    ? {
                        x: -t.x + this.shadow.pos.x,
                        y: t.y - this.shadow.pos.y,
                      }
                    : {
                        x: t.x - this.shadow.pos.x,
                        y: t.y - this.shadow.pos.y,
                      };
                (e = h.GetRotatedPoint(e, { x: s, y: 100 }, i)),
                  (o += e.x + "px " + e.y + "px, ");
              }
            (o = o.slice(0, -2)), (o += ")");
            const a = `\n            display: block;\n            z-index: ${(
              this.getSettings().startZIndex + 10
            ).toString(10)};\n            width: ${
              this.shadow.width
            }px;\n            height: ${
              2 * t.height
            }px;\n            background: linear-gradient(${n}, rgba(0, 0, 0, ${
              this.shadow.opacity
            }), rgba(0, 0, 0, 0));\n            transform-origin: ${s}px 100px;\n            transform: translate3d(${
              e.x - s
            }px, ${
              e.y - 100
            }px, 0) rotate(${i}rad);\n            clip-path: ${o};\n            -webkit-clip-path: ${o};\n        `;
            this.outerShadow.style.cssText = a;
          }
          drawLeftPage() {
            "portrait" !== this.orientation &&
              null !== this.leftPage &&
              (1 === this.direction &&
              null !== this.flippingPage &&
              "hard" === this.flippingPage.getDrawingDensity()
                ? ((this.leftPage.getElement().style.zIndex = (
                    this.getSettings().startZIndex + 5
                  ).toString(10)),
                  this.leftPage.setHardDrawingAngle(
                    180 + this.flippingPage.getHardAngle()
                  ),
                  this.leftPage.draw(this.flippingPage.getDrawingDensity()))
                : this.leftPage.simpleDraw(0));
          }
          drawRightPage() {
            null !== this.rightPage &&
              (0 === this.direction &&
              null !== this.flippingPage &&
              "hard" === this.flippingPage.getDrawingDensity()
                ? ((this.rightPage.getElement().style.zIndex = (
                    this.getSettings().startZIndex + 5
                  ).toString(10)),
                  this.rightPage.setHardDrawingAngle(
                    180 + this.flippingPage.getHardAngle()
                  ),
                  this.rightPage.draw(this.flippingPage.getDrawingDensity()))
                : this.rightPage.simpleDraw(1));
          }
          drawBottomPage() {
            if (null === this.bottomPage) return;
            const t =
              null != this.flippingPage
                ? this.flippingPage.getDrawingDensity()
                : null;
            ("portrait" === this.orientation && 1 === this.direction) ||
              ((this.bottomPage.getElement().style.zIndex = (
                this.getSettings().startZIndex + 3
              ).toString(10)),
              this.bottomPage.draw(t));
          }
          drawFrame() {
            this.clear(),
              this.drawLeftPage(),
              this.drawRightPage(),
              this.drawBottomPage(),
              null != this.flippingPage &&
                ((this.flippingPage.getElement().style.zIndex = (
                  this.getSettings().startZIndex + 5
                ).toString(10)),
                this.flippingPage.draw()),
              null != this.shadow &&
                null !== this.flippingPage &&
                ("soft" === this.flippingPage.getDrawingDensity()
                  ? (this.drawOuterShadow(), this.drawInnerShadow())
                  : (this.drawHardOuterShadow(), this.drawHardInnerShadow()));
          }
          clear() {
            for (const t of this.app.getPageCollection().getPages())
              t !== this.leftPage &&
                t !== this.rightPage &&
                t !== this.flippingPage &&
                t !== this.bottomPage &&
                (t.getElement().style.cssText = "display: none"),
                t.getTemporaryCopy() !== this.flippingPage &&
                  t.hideTemporaryCopy();
          }
          update() {
            super.update(),
              null !== this.rightPage && this.rightPage.setOrientation(1),
              null !== this.leftPage && this.leftPage.setOrientation(0);
          }
        }
        class x {
          constructor() {
            this._default = {
              startPage: 0,
              size: "fixed",
              width: 0,
              height: 0,
              minWidth: 0,
              maxWidth: 0,
              minHeight: 0,
              maxHeight: 0,
              drawShadow: !0,
              flippingTime: 1e3,
              usePortrait: !0,
              startZIndex: 0,
              autoSize: !0,
              maxShadowOpacity: 1,
              showCover: !1,
              mobileScrollSupport: !0,
              swipeDistance: 30,
              clickEventForward: !0,
              useMouseEvents: !0,
              showPageCorners: !0,
              disableFlipByClick: !1,
            };
          }
          getSettings(t) {
            const e = this._default;
            if (
              (Object.assign(e, t), "stretch" !== e.size && "fixed" !== e.size)
            )
              throw new Error(
                'Invalid size type. Available only "fixed" and "stretch" value'
              );
            if (e.width <= 0 || e.height <= 0)
              throw new Error("Invalid width or height");
            if (e.flippingTime <= 0) throw new Error("Invalid flipping time");
            return (
              "stretch" === e.size
                ? (e.minWidth <= 0 && (e.minWidth = 100),
                  e.maxWidth < e.minWidth && (e.maxWidth = 2e3),
                  e.minHeight <= 0 && (e.minHeight = 100),
                  e.maxHeight < e.minHeight && (e.maxHeight = 2e3))
                : ((e.minWidth = e.width),
                  (e.maxWidth = e.width),
                  (e.minHeight = e.height),
                  (e.maxHeight = e.height)),
              e
            );
          }
        }
        !(function (t, e) {
          void 0 === e && (e = {});
          var i = e.insertAt;
          if (t && "undefined" != typeof document) {
            var s = document.head || document.getElementsByTagName("head")[0],
              n = document.createElement("style");
            (n.type = "text/css"),
              "top" === i && s.firstChild
                ? s.insertBefore(n, s.firstChild)
                : s.appendChild(n),
              n.styleSheet
                ? (n.styleSheet.cssText = t)
                : n.appendChild(document.createTextNode(t));
          }
        })(
          ".stf__parent {\n  position: relative;\n  display: block;\n  box-sizing: border-box;\n  transform: translateZ(0);\n\n  -ms-touch-action: pan-y;\n  touch-action: pan-y;\n}\n\n.sft__wrapper {\n  position: relative;\n  width: 100%;\n  box-sizing: border-box;\n}\n\n.stf__parent canvas {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n\n.stf__block {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  perspective: 2000px;\n}\n\n.stf__item {\n  display: none;\n  position: absolute;\n  transform-style: preserve-3d;\n}\n\n.stf__outerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__innerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__hardShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__hardInnerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}"
        ),
          (t.PageFlip = class extends (
            class {
              constructor() {
                this.events = new Map();
              }
              on(t, e) {
                return (
                  this.events.has(t)
                    ? this.events.get(t).push(e)
                    : this.events.set(t, [e]),
                  this
                );
              }
              off(t) {
                this.events.delete(t);
              }
              trigger(t, e, i = null) {
                if (this.events.has(t))
                  for (const s of this.events.get(t)) s({ data: i, object: e });
              }
            }
          ) {
            constructor(t, e) {
              super(),
                (this.isUserTouch = !1),
                (this.isUserMove = !1),
                (this.setting = null),
                (this.pages = null),
                (this.setting = new x().getSettings(e)),
                (this.block = t);
            }
            destroy() {
              this.ui.destroy(), this.block.remove();
            }
            update() {
              this.render.update(), this.pages.show();
            }
            loadFromImages(t) {
              this.ui = new u(this.block, this, this.setting);
              const e = this.ui.getCanvas();
              (this.render = new d(this, this.setting, e)),
                (this.flipController = new g(this.render, this)),
                (this.pages = new n(this, this.render, t)),
                this.pages.load(),
                this.render.start(),
                this.pages.show(this.setting.startPage),
                setTimeout(() => {
                  this.ui.update(),
                    this.trigger("init", this, {
                      page: this.setting.startPage,
                      mode: this.render.getOrientation(),
                    });
                }, 1);
            }
            loadFromHTML(t) {
              (this.ui = new c(this.block, this, this.setting, t)),
                (this.render = new w(
                  this,
                  this.setting,
                  this.ui.getDistElement()
                )),
                (this.flipController = new g(this.render, this)),
                (this.pages = new o(
                  this,
                  this.render,
                  this.ui.getDistElement(),
                  t
                )),
                this.pages.load(),
                this.render.start(),
                this.pages.show(this.setting.startPage),
                setTimeout(() => {
                  this.ui.update(),
                    this.trigger("init", this, {
                      page: this.setting.startPage,
                      mode: this.render.getOrientation(),
                    });
                }, 1);
            }
            updateFromImages(t) {
              const e = this.pages.getCurrentPageIndex();
              this.pages.destroy(),
                (this.pages = new n(this, this.render, t)),
                this.pages.load(),
                this.pages.show(e),
                this.trigger("update", this, {
                  page: e,
                  mode: this.render.getOrientation(),
                });
            }
            updateFromHtml(t) {
              const e = this.pages.getCurrentPageIndex();
              this.pages.destroy(),
                (this.pages = new o(
                  this,
                  this.render,
                  this.ui.getDistElement(),
                  t
                )),
                this.pages.load(),
                this.ui.updateItems(t),
                this.render.reload(),
                this.pages.show(e),
                this.trigger("update", this, {
                  page: e,
                  mode: this.render.getOrientation(),
                });
            }
            clear() {
              this.pages.destroy(), this.ui.clear();
            }
            turnToPrevPage() {
              this.pages.showPrev();
            }
            turnToNextPage() {
              this.pages.showNext();
            }
            turnToPage(t) {
              this.pages.show(t);
            }
            flipNext(t = "top") {
              this.flipController.flipNext(t);
            }
            flipPrev(t = "top") {
              this.flipController.flipPrev(t);
            }
            flip(t, e = "top") {
              this.flipController.flipToPage(t, e);
            }
            updateState(t) {
              this.trigger("changeState", this, t);
            }
            updatePageIndex(t) {
              this.trigger("flip", this, t);
            }
            updateOrientation(t) {
              this.ui.setOrientationStyle(t),
                this.update(),
                this.trigger("changeOrientation", this, t);
            }
            getPageCount() {
              return this.pages.getPageCount();
            }
            getCurrentPageIndex() {
              return this.pages.getCurrentPageIndex();
            }
            getPage(t) {
              return this.pages.getPage(t);
            }
            getRender() {
              return this.render;
            }
            getFlipController() {
              return this.flipController;
            }
            getOrientation() {
              return this.render.getOrientation();
            }
            getBoundsRect() {
              return this.render.getRect();
            }
            getSettings() {
              return this.setting;
            }
            getUI() {
              return this.ui;
            }
            getState() {
              return this.flipController.getState();
            }
            getPageCollection() {
              return this.pages;
            }
            startUserTouch(t) {
              (this.mousePosition = t),
                (this.isUserTouch = !0),
                (this.isUserMove = !1);
            }
            userMove(t, e) {
              this.isUserTouch || e || !this.setting.showPageCorners
                ? this.isUserTouch &&
                  h.GetDistanceBetweenTwoPoint(this.mousePosition, t) > 5 &&
                  ((this.isUserMove = !0), this.flipController.fold(t))
                : this.flipController.showCorner(t);
            }
            userStop(t, e = !1) {
              this.isUserTouch &&
                ((this.isUserTouch = !1),
                e ||
                  (this.isUserMove
                    ? this.flipController.stopMove()
                    : this.flipController.flip(t)));
            }
          }),
          Object.defineProperty(t, "__esModule", { value: !0 });
      })(exports);
    },
    362: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var ReactPropTypesSecret = __webpack_require__(6441);
      function emptyFunction() {}
      function emptyFunctionWithReset() {}
      (emptyFunctionWithReset.resetWarningCache = emptyFunction),
        (module.exports = function () {
          function shim(
            props,
            propName,
            componentName,
            location,
            propFullName,
            secret
          ) {
            if (secret !== ReactPropTypesSecret)
              throw (
                (((secret = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
                )).name = "Invariant Violation"),
                secret)
              );
          }
          function getShim() {
            return shim;
          }
          var ReactPropTypes = {
            array: (shim.isRequired = shim),
            bigint: shim,
            bool: shim,
            func: shim,
            number: shim,
            object: shim,
            string: shim,
            symbol: shim,
            any: shim,
            arrayOf: getShim,
            element: shim,
            elementType: shim,
            instanceOf: getShim,
            node: shim,
            objectOf: getShim,
            oneOf: getShim,
            oneOfType: getShim,
            shape: getShim,
            exact: getShim,
            checkPropTypes: emptyFunctionWithReset,
            resetWarningCache: emptyFunction,
          };
          return (ReactPropTypes.PropTypes = ReactPropTypes);
        });
    },
    2688: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(362)();
    },
    6441: (module) => {
      "use strict";
      module.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    },
    6067: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var aa = __webpack_require__(3696),
        ca = __webpack_require__(1434);
      function p(a) {
        for (
          var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a,
            c = 1;
          c < arguments.length;
          c++
        )
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return (
          "Minified React error #" +
          a +
          "; visit " +
          b +
          " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
        );
      }
      var da = new Set(),
        ea = {};
      function fa(a, b) {
        ha(a, b), ha(a + "Capture", b);
      }
      function ha(a, b) {
        for (ea[a] = b, a = 0; a < b.length; a++) da.add(b[a]);
      }
      var __webpack_require__ = !(
          "undefined" == typeof window ||
          void 0 === window.document ||
          void 0 === window.document.createElement
        ),
        ja = Object.prototype.hasOwnProperty,
        ka =
          /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        la = {},
        ma = {};
      function v(a, b, c, d, e, f, g) {
        (this.acceptsBooleans = 2 === b || 3 === b || 4 === b),
          (this.attributeName = d),
          (this.attributeNamespace = e),
          (this.mustUseProperty = c),
          (this.propertyName = a),
          (this.type = b),
          (this.sanitizeURL = f),
          (this.removeEmptyString = g);
      }
      var z = {},
        ra =
          ("children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
            .split(" ")
            .forEach(function (a) {
              z[a] = new v(a, 0, !1, a, null, !1, !1);
            }),
          [
            ["acceptCharset", "accept-charset"],
            ["className", "class"],
            ["htmlFor", "for"],
            ["httpEquiv", "http-equiv"],
          ].forEach(function (a) {
            var b = a[0];
            z[b] = new v(b, 1, !1, a[1], null, !1, !1);
          }),
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(
            function (a) {
              z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
            }
          ),
          [
            "autoReverse",
            "externalResourcesRequired",
            "focusable",
            "preserveAlpha",
          ].forEach(function (a) {
            z[a] = new v(a, 2, !1, a, null, !1, !1);
          }),
          "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
            .split(" ")
            .forEach(function (a) {
              z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
            }),
          ["checked", "multiple", "muted", "selected"].forEach(function (a) {
            z[a] = new v(a, 3, !0, a, null, !1, !1);
          }),
          ["capture", "download"].forEach(function (a) {
            z[a] = new v(a, 4, !1, a, null, !1, !1);
          }),
          ["cols", "rows", "size", "span"].forEach(function (a) {
            z[a] = new v(a, 6, !1, a, null, !1, !1);
          }),
          ["rowSpan", "start"].forEach(function (a) {
            z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
          }),
          /[\-:]([a-z])/g);
      function sa(a) {
        return a[1].toUpperCase();
      }
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        (null !== e
          ? 0 !== e.type
          : d ||
            !(2 < b.length) ||
            ("o" !== b[0] && "O" !== b[0]) ||
            ("n" !== b[1] && "N" !== b[1])) &&
          (!(function qa(a, b, c, d) {
            if (
              null == b ||
              (function pa(a, b, c, d) {
                if (null === c || 0 !== c.type)
                  switch (typeof b) {
                    case "function":
                    case "symbol":
                      return 1;
                    case "boolean":
                      return d
                        ? void 0
                        : null !== c
                        ? !c.acceptsBooleans
                        : "data-" !== (a = a.toLowerCase().slice(0, 5)) &&
                          "aria-" !== a;
                    default:
                      return;
                  }
              })(a, b, c, d)
            )
              return 1;
            if (!d && null !== c)
              switch (c.type) {
                case 3:
                  return !b;
                case 4:
                  return !1 === b;
                case 5:
                  return isNaN(b);
                case 6:
                  return isNaN(b) || b < 1;
              }
          })(b, c, e, d) || (c = null),
          d || null === e
            ? (function oa(a) {
                return (
                  ja.call(ma, a) ||
                  (!ja.call(la, a) &&
                    (ka.test(a) ? (ma[a] = !0) : void (la[a] = !0)))
                );
              })(b) &&
              (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c))
            : e.mustUseProperty
            ? (a[e.propertyName] = null === c ? 3 !== e.type && "" : c)
            : ((b = e.attributeName),
              (d = e.attributeNamespace),
              null === c
                ? a.removeAttribute(b)
                : ((c =
                    3 === (e = e.type) || (4 === e && !0 === c) ? "" : "" + c),
                  d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
        .split(" ")
        .forEach(function (a) {
          var b = a.replace(ra, sa);
          z[b] = new v(b, 1, !1, a, null, !1, !1);
        }),
        "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
          .split(" ")
          .forEach(function (a) {
            var b = a.replace(ra, sa);
            z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
          }),
        ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
          var b = a.replace(ra, sa);
          z[b] = new v(
            b,
            1,
            !1,
            a,
            "http://www.w3.org/XML/1998/namespace",
            !1,
            !1
          );
        }),
        ["tabIndex", "crossOrigin"].forEach(function (a) {
          z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
        }),
        (z.xlinkHref = new v(
          "xlinkHref",
          1,
          !1,
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          !0,
          !1
        )),
        ["src", "href", "action", "formAction"].forEach(function (a) {
          z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
        });
      var aa = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        va = Symbol.for("react.element"),
        wa = Symbol.for("react.portal"),
        ya = Symbol.for("react.fragment"),
        za = Symbol.for("react.strict_mode"),
        Aa = Symbol.for("react.profiler"),
        Ba = Symbol.for("react.provider"),
        Ca = Symbol.for("react.context"),
        Da = Symbol.for("react.forward_ref"),
        Ea = Symbol.for("react.suspense"),
        Fa = Symbol.for("react.suspense_list"),
        Ga = Symbol.for("react.memo"),
        Ha = Symbol.for("react.lazy"),
        Ia =
          (Symbol.for("react.scope"),
          Symbol.for("react.debug_trace_mode"),
          Symbol.for("react.offscreen")),
        Ja =
          (Symbol.for("react.legacy_hidden"),
          Symbol.for("react.cache"),
          Symbol.for("react.tracing_marker"),
          Symbol.iterator);
      function Ka(a) {
        return null !== a &&
          "object" == typeof a &&
          "function" == typeof (a = (Ja && a[Ja]) || a["@@iterator"])
          ? a
          : null;
      }
      var La,
        A = Object.assign;
      function Ma(a) {
        if (void 0 === La)
          try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            La = (b && b[1]) || "";
          }
        return "\n" + La + a;
      }
      var Na = !1;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = !0;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b)
            if (
              ((b = function () {
                throw Error();
              }),
              Object.defineProperty(b.prototype, "props", {
                set: function () {
                  throw Error();
                },
              }),
              "object" == typeof Reflect && Reflect.construct)
            ) {
              try {
                Reflect.construct(b, []);
              } catch (l) {
                var d = l;
              }
              Reflect.construct(a, [], b);
            } else {
              try {
                b.call();
              } catch (l) {
                d = l;
              }
              a.call(b.prototype);
            }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" == typeof l.stack) {
            for (
              var k,
                e = l.stack.split("\n"),
                f = d.stack.split("\n"),
                g = e.length - 1,
                h = f.length - 1;
              1 <= g && 0 <= h && e[g] !== f[h];

            )
              h--;
            for (; 1 <= g && 0 <= h; g--, h--)
              if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h)
                  do {
                    if ((g--, --h < 0 || e[g] !== f[h]))
                      return (
                        (k = "\n" + e[g].replace(" at new ", " at ")),
                        (k =
                          a.displayName && k.includes("<anonymous>")
                            ? k.replace("<anonymous>", a.displayName)
                            : k)
                      );
                  } while (1 <= g && 0 <= h);
                break;
              }
          }
        } finally {
          (Na = !1), (Error.prepareStackTrace = c);
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return (
              (a = (a = b.render).displayName || a.name || ""),
              b.displayName ||
                ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef")
            );
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return (function Qa(a) {
              if (null != a) {
                if ("function" == typeof a)
                  return a.displayName || a.name || null;
                if ("string" == typeof a) return a;
                switch (a) {
                  case ya:
                    return "Fragment";
                  case wa:
                    return "Portal";
                  case Aa:
                    return "Profiler";
                  case za:
                    return "StrictMode";
                  case Ea:
                    return "Suspense";
                  case Fa:
                    return "SuspenseList";
                }
                if ("object" == typeof a)
                  switch (a.$$typeof) {
                    case Ca:
                      return (a.displayName || "Context") + ".Consumer";
                    case Ba:
                      return (
                        (a._context.displayName || "Context") + ".Provider"
                      );
                    case Da:
                      var b = a.render;
                      return (a =
                        (a = a.displayName) ||
                        ("" !== (a = b.displayName || b.name || "")
                          ? "ForwardRef(" + a + ")"
                          : "ForwardRef"));
                    case Ga:
                      return null !== (b = a.displayName || null)
                        ? b
                        : Qa(a.type) || "Memo";
                    case Ha:
                      (b = a._payload), (a = a._init);
                      try {
                        return Qa(a(b));
                      } catch (c) {}
                  }
              }
              return null;
            })(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" == typeof b) return b.displayName || b.name || null;
            if ("string" == typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (
          (a = a.nodeName) &&
          "input" === a.toLowerCase() &&
          ("checkbox" === b || "radio" === b)
        );
      }
      function Va(a) {
        a._valueTracker ||
          (a._valueTracker = (function Ua(a) {
            var e,
              f,
              b = Ta(a) ? "checked" : "value",
              c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
              d = "" + a[b];
            if (
              !a.hasOwnProperty(b) &&
              void 0 !== c &&
              "function" == typeof c.get &&
              "function" == typeof c.set
            )
              return (
                (e = c.get),
                (f = c.set),
                Object.defineProperty(a, b, {
                  configurable: !0,
                  get: function () {
                    return e.call(this);
                  },
                  set: function (a) {
                    (d = "" + a), f.call(this, a);
                  },
                }),
                Object.defineProperty(a, b, { enumerable: c.enumerable }),
                {
                  getValue: function () {
                    return d;
                  },
                  setValue: function (a) {
                    d = "" + a;
                  },
                  stopTracking: function () {
                    (a._valueTracker = null), delete a[b];
                  },
                }
              );
          })(a));
      }
      function Wa(a) {
        var b, c, d;
        if (a)
          return (b = a._valueTracker)
            ? ((c = b.getValue()),
              (d = ""),
              (a = d =
                a ? (Ta(a) ? (a.checked ? "true" : "false") : a.value) : d) !==
                c && (b.setValue(a), 1))
            : 1;
      }
      function Xa(a) {
        if (
          void 0 ===
          (a = a || ("undefined" != typeof document ? document : void 0))
        )
          return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: null != c ? c : a._wrapperState.initialChecked,
        });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue,
          d = null != b.checked ? b.checked : b.defaultChecked,
          c = Sa(null != b.value ? b.value : c);
        a._wrapperState = {
          initialChecked: d,
          initialValue: c,
          controlled:
            "checkbox" === b.type || "radio" === b.type
              ? null != b.checked
              : null != b.value,
        };
      }
      function ab(a, b) {
        null != (b = b.checked) && ta(a, "checked", b, !1);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value),
          d = b.type;
        if (null != c)
          "number" === d
            ? ((0 === c && "" === a.value) || a.value != c) &&
              (a.value = "" + c)
            : a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d)
          return void a.removeAttribute("value");
        b.hasOwnProperty("value")
          ? cb(a, b.type, c)
          : b.hasOwnProperty("defaultValue") &&
            cb(a, b.type, Sa(b.defaultValue)),
          null == b.checked &&
            null != b.defaultChecked &&
            (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (
            !(
              ("submit" !== d && "reset" !== d) ||
              (void 0 !== b.value && null !== b.value)
            )
          )
            return;
          (b = "" + a._wrapperState.initialValue),
            c || b === a.value || (a.value = b),
            (a.defaultValue = b);
        }
        "" !== (c = a.name) && (a.name = ""),
          (a.defaultChecked = !!a._wrapperState.initialChecked),
          "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        ("number" === b && Xa(a.ownerDocument) === a) ||
          (null == c
            ? (a.defaultValue = "" + a._wrapperState.initialValue)
            : a.defaultValue !== "" + c && (a.defaultValue = "" + c));
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        if (((a = a.options), b)) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
          for (c = 0; c < a.length; c++)
            (e = b.hasOwnProperty("$" + a[c].value)),
              a[c].selected !== e && (a[c].selected = e),
              e && d && (a[c].defaultSelected = !0);
        } else {
          for (c = "" + Sa(c), b = null, e = 0; e < a.length; e++) {
            if (a[e].value === c)
              return (
                (a[e].selected = !0), void (d && (a[e].defaultSelected = !0))
              );
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = !0);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, {
          value: void 0,
          defaultValue: void 0,
          children: "" + a._wrapperState.initialValue,
        });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          if (((c = b.children), (b = b.defaultValue), null != c)) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          c = b = null == b ? "" : b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value),
          d = Sa(b.defaultValue);
        null != c &&
          ((c = "" + c) !== a.value && (a.value = c), null == b.defaultValue) &&
          a.defaultValue !== c &&
          (a.defaultValue = c),
          null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue &&
          "" !== b &&
          null !== b &&
          (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a
          ? kb(b)
          : "http://www.w3.org/2000/svg" === a && "foreignObject" === b
          ? "http://www.w3.org/1999/xhtml"
          : a;
      }
      a = function (a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
          a.innerHTML = b;
        else {
          for (
            (mb = mb || document.createElement("div")).innerHTML =
              "<svg>" + b.valueOf().toString() + "</svg>",
              b = mb.firstChild;
            a.firstChild;

          )
            a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      };
      var mb,
        a,
        nb =
          "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction
            ? function (b, c, d, e) {
                MSApp.execUnsafeLocalFunction(function () {
                  return a(b, c);
                });
              }
            : a;
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType)
            return void (c.nodeValue = b);
        }
        a.textContent = b;
      }
      var pb = {
          animationIterationCount: !0,
          aspectRatio: !0,
          borderImageOutset: !0,
          borderImageSlice: !0,
          borderImageWidth: !0,
          boxFlex: !0,
          boxFlexGroup: !0,
          boxOrdinalGroup: !0,
          columnCount: !0,
          columns: !0,
          flex: !0,
          flexGrow: !0,
          flexPositive: !0,
          flexShrink: !0,
          flexNegative: !0,
          flexOrder: !0,
          gridArea: !0,
          gridRow: !0,
          gridRowEnd: !0,
          gridRowSpan: !0,
          gridRowStart: !0,
          gridColumn: !0,
          gridColumnEnd: !0,
          gridColumnSpan: !0,
          gridColumnStart: !0,
          fontWeight: !0,
          lineClamp: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          tabSize: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0,
          fillOpacity: !0,
          floodOpacity: !0,
          stopOpacity: !0,
          strokeDasharray: !0,
          strokeDashoffset: !0,
          strokeMiterlimit: !0,
          strokeOpacity: !0,
          strokeWidth: !0,
        },
        qb = ["Webkit", "ms", "Moz", "O"];
      function rb(a, b, c) {
        return null == b || "boolean" == typeof b || "" === b
          ? ""
          : c ||
            "number" != typeof b ||
            0 === b ||
            (pb.hasOwnProperty(a) && pb[a])
          ? ("" + b).trim()
          : b + "px";
      }
      function sb(a, b) {
        for (var c in ((a = a.style), b)) {
          var d, e;
          b.hasOwnProperty(c) &&
            ((d = 0 === c.indexOf("--")),
            (e = rb(c, b[c], d)),
            "float" === c && (c = "cssFloat"),
            d ? a.setProperty(c, e) : (a[c] = e));
        }
      }
      Object.keys(pb).forEach(function (a) {
        qb.forEach(function (b) {
          (b = b + a.charAt(0).toUpperCase() + a.substring(1)), (pb[b] = pb[a]);
        });
      });
      var tb = A(
        { menuitem: !0 },
        {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          embed: !0,
          hr: !0,
          img: !0,
          input: !0,
          keygen: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0,
        }
      );
      function ub(a, b) {
        if (b) {
          if (
            tb[a] &&
            (null != b.children || null != b.dangerouslySetInnerHTML)
          )
            throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if (
              "object" != typeof b.dangerouslySetInnerHTML ||
              !("__html" in b.dangerouslySetInnerHTML)
            )
              throw Error(p(61));
          }
          if (null != b.style && "object" != typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" == typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var wb = null;
      function xb(a) {
        return 3 ===
          (a = (a = a.target || a.srcElement || window).correspondingUseElement
            ? a.correspondingUseElement
            : a).nodeType
          ? a.parentNode
          : a;
      }
      var yb = null,
        zb = null,
        Ab = null;
      function Bb(a) {
        if ((a = Cb(a))) {
          if ("function" != typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && ((b = Db(b)), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? (Ab ? Ab.push(a) : (Ab = [a])) : (zb = a);
      }
      function Fb() {
        if (zb) {
          var a = zb,
            b = Ab;
          if (((Ab = zb = null), Bb(a), b))
            for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {}
      var Ib = !1;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = !0;
        try {
          Gb(a, b, c);
        } finally {
          (Ib = !1), (null === zb && null === Ab) || (Hb(), Fb());
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        switch (((c = d[b]), b)) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            a = !(d = (d = !d.disabled)
              ? d
              : !(
                  "button" === (a = a.type) ||
                  "input" === a ||
                  "select" === a ||
                  "textarea" === a
                ));
            break;
          default:
            a = !1;
        }
        if (a) return null;
        if (c && "function" != typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = !1;
      if (__webpack_require__)
        try {
          var Mb = {};
          Object.defineProperty(Mb, "passive", {
            get: function () {
              Lb = !0;
            },
          }),
            window.addEventListener("test", Mb, Mb),
            window.removeEventListener("test", Mb, Mb);
        } catch (a) {
          Lb = !1;
        }
      var Ob = !1,
        Pb = null,
        Qb = !1,
        Rb = null,
        Sb = {
          onError: function (a) {
            (Ob = !0), (Pb = a);
          },
        };
      function Tb(a, b, c, d, e, f, g, h, k) {
        (Ob = !1),
          (Pb = null),
          function Nb(a, b, c, d, e, f, g, h, k) {
            var l = Array.prototype.slice.call(arguments, 3);
            try {
              b.apply(c, l);
            } catch (m) {
              this.onError(m);
            }
          }.apply(Sb, arguments);
      }
      function Vb(a) {
        var b = a,
          c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else
          for (
            a = b;
            0 != (4098 & (b = a).flags) && (c = b.return), (a = b.return);

          );
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          if (
            null !==
            (b = null === b && null !== (a = a.alternate) ? a.memoizedState : b)
          )
            return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Zb(a) {
        return null !==
          (a = (function Yb(a) {
            var b = a.alternate;
            if (!b) {
              if (null === (b = Vb(a))) throw Error(p(188));
              return b !== a ? null : a;
            }
            for (var c = a, d = b; ; ) {
              var e = c.return;
              if (null === e) break;
              var f = e.alternate;
              if (null === f) {
                if (null === (d = e.return)) break;
                c = d;
              } else {
                if (e.child === f.child) {
                  for (f = e.child; f; ) {
                    if (f === c) return Xb(e), a;
                    if (f === d) return Xb(e), b;
                    f = f.sibling;
                  }
                  throw Error(p(188));
                }
                if (c.return !== d.return) (c = e), (d = f);
                else {
                  for (var g = !1, h = e.child; h; ) {
                    if (h === c) {
                      (g = !0), (c = e), (d = f);
                      break;
                    }
                    if (h === d) {
                      (g = !0), (d = e), (c = f);
                      break;
                    }
                    h = h.sibling;
                  }
                  if (!g) {
                    for (h = f.child; h; ) {
                      if (h === c) {
                        (g = !0), (c = f), (d = e);
                        break;
                      }
                      if (h === d) {
                        (g = !0), (d = f), (c = e);
                        break;
                      }
                      h = h.sibling;
                    }
                    if (!g) throw Error(p(189));
                  }
                }
                if (c.alternate !== d) throw Error(p(190));
              }
            }
            if (3 !== c.tag) throw Error(p(188));
            return c.stateNode.current === c ? a : b;
          })(a))
          ? (function $b(a) {
              if (5 === a.tag || 6 === a.tag) return a;
              for (a = a.child; null !== a; ) {
                var b = $b(a);
                if (null !== b) return b;
                a = a.sibling;
              }
              return null;
            })(a)
          : null;
      }
      var ac = ca.unstable_scheduleCallback,
        bc = ca.unstable_cancelCallback,
        cc = ca.unstable_shouldYield,
        dc = ca.unstable_requestPaint,
        B = ca.unstable_now,
        ec = ca.unstable_getCurrentPriorityLevel,
        fc = ca.unstable_ImmediatePriority,
        gc = ca.unstable_UserBlockingPriority,
        hc = ca.unstable_NormalPriority,
        ic = ca.unstable_LowPriority,
        jc = ca.unstable_IdlePriority,
        kc = null,
        lc = null;
      var oc =
          Math.clz32 ||
          function nc(a) {
            return 0 == (a >>>= 0) ? 32 : (31 - ((pc(a) / qc) | 0)) | 0;
          },
        pc = Math.log,
        qc = Math.LN2;
      var rc = 64,
        sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return 4194240 & a;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return 130023424 & a;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var h,
          d = 0,
          e = a.suspendedLanes,
          f = a.pingedLanes,
          g = 268435455 & c;
        if (
          (0 != g
            ? 0 != (h = g & ~e)
              ? (d = tc(h))
              : 0 !== (f &= g) && (d = tc(f))
            : 0 != (g = c & ~e)
            ? (d = tc(g))
            : 0 !== f && (d = tc(f)),
          0 === d)
        )
          return 0;
        if (
          0 !== b &&
          b !== d &&
          0 == (b & e) &&
          ((f = b & -b) <= (e = d & -d) || (16 === e && 0 != (4194240 & f)))
        )
          return b;
        if ((0 != (4 & d) && (d |= 16 & c), 0 !== (b = a.entangledLanes)))
          for (a = a.entanglements, b &= d; 0 < b; )
            (d |= a[(c = 31 - oc(b))]), (b &= ~(e = 1 << c));
        return d;
      }
      function xc(a) {
        return 0 !== (a = -1073741825 & a.pendingLanes)
          ? a
          : 1073741824 & a
          ? 1073741824
          : 0;
      }
      function yc() {
        var a = rc;
        return 0 == (4194240 & (rc <<= 1)) && (rc = 64), a;
      }
      function zc(a) {
        for (var b = [], c = 0; c < 31; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        (a.pendingLanes |= b),
          536870912 !== b && ((a.suspendedLanes = 0), (a.pingedLanes = 0)),
          ((a = a.eventTimes)[(b = 31 - oc(b))] = c);
      }
      function Cc(a, b) {
        var c = (a.entangledLanes |= b);
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c),
            e = 1 << d;
          (e & b) | (a[d] & b) && (a[d] |= b), (c &= ~e);
        }
      }
      var C = 0;
      function Dc(a) {
        return 1 < (a &= -a)
          ? 4 < a
            ? 0 != (268435455 & a)
              ? 16
              : 536870912
            : 4
          : 1;
      }
      var Ec,
        Fc,
        Gc,
        Hc,
        Ic,
        Jc = !1,
        Kc = [],
        Lc = null,
        Mc = null,
        Nc = null,
        Oc = new Map(),
        Pc = new Map(),
        Qc = [],
        Rc =
          "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
            " "
          );
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        return (
          null === a || a.nativeEvent !== f
            ? ((a = {
                blockedOn: b,
                domEventName: c,
                eventSystemFlags: d,
                nativeEvent: f,
                targetContainers: [e],
              }),
              null !== b && null !== (b = Cb(b)) && Fc(b))
            : ((a.eventSystemFlags |= d),
              (b = a.targetContainers),
              null !== e && -1 === b.indexOf(e) && b.push(e)),
          a
        );
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c)
            if (13 === (b = c.tag)) {
              if (null !== (b = Wb(c)))
                return (
                  (a.blockedOn = b),
                  void Ic(a.priority, function () {
                    Gc(c);
                  })
                );
            } else if (
              3 === b &&
              c.stateNode.current.memoizedState.isDehydrated
            )
              return void (a.blockedOn =
                3 === c.tag ? c.stateNode.containerInfo : null);
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null === a.blockedOn) {
          for (var b = a.targetContainers; 0 < b.length; ) {
            var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null !== c)
              return null !== (b = Cb(c)) && Fc(b), (a.blockedOn = c), 0;
            var d = new (c = a.nativeEvent).constructor(c.type, c);
            (wb = d), c.target.dispatchEvent(d), (wb = null), b.shift();
          }
          return 1;
        }
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        (Jc = !1),
          null !== Lc && Xc(Lc) && (Lc = null),
          null !== Mc && Xc(Mc) && (Mc = null),
          null !== Nc && Xc(Nc) && (Nc = null),
          Oc.forEach(Zc),
          Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b &&
          ((a.blockedOn = null),
          Jc ||
            ((Jc = !0),
            ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b) {
          return ad(b, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        for (
          null !== Lc && ad(Lc, a),
            null !== Mc && ad(Mc, a),
            null !== Nc && ad(Nc, a),
            Oc.forEach(b),
            Pc.forEach(b),
            c = 0;
          c < Qc.length;
          c++
        )
          (d = Qc[c]).blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && null === (c = Qc[0]).blockedOn; )
          Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = aa.ReactCurrentBatchConfig,
        dd = !0;
      function ed(a, b, c, d) {
        var e = C,
          f = cd.transition;
        cd.transition = null;
        try {
          (C = 1), fd(a, b, c, d);
        } finally {
          (C = e), (cd.transition = f);
        }
      }
      function gd(a, b, c, d) {
        var e = C,
          f = cd.transition;
        cd.transition = null;
        try {
          (C = 4), fd(a, b, c, d);
        } finally {
          (C = e), (cd.transition = f);
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, 0, 0, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (
            (function Uc(a, b, c, d, e) {
              switch (b) {
                case "focusin":
                  return (Lc = Tc(Lc, a, b, c, d, e)), 1;
                case "dragenter":
                  return (Mc = Tc(Mc, a, b, c, d, e)), 1;
                case "mouseover":
                  return (Nc = Tc(Nc, a, b, c, d, e)), 1;
                case "pointerover":
                  var f = e.pointerId;
                  return Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e)), 1;
                case "gotpointercapture":
                  return (
                    (f = e.pointerId),
                    Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)),
                    1
                  );
              }
            })(e, a, b, c, d)
          )
            d.stopPropagation();
          else if ((Sc(a, d), 4 & b && -1 < Rc.indexOf(a))) {
            for (; null !== e; ) {
              var f = Cb(e);
              if (
                (null !== f && Ec(f),
                null === (f = Yc(a, 0, 0, d)) && hd(a, b, d, id, c),
                f === e)
              )
                break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        if ((id = null) !== (a = Wc((a = xb(d)))))
          if (null === (b = Vb(a))) a = null;
          else if (13 === (c = b.tag)) {
            if (null !== (a = Wb(b))) return a;
            a = null;
          } else if (3 === c) {
            if (b.stateNode.current.memoizedState.isDehydrated)
              return 3 === b.tag ? b.stateNode.containerInfo : null;
            a = null;
          } else b !== a && (a = null);
        return (id = a), null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null,
        ld = null,
        md = null;
      function nd() {
        if (md) return md;
        for (
          var b = ld,
            c = b.length,
            e = ("value" in kd) ? kd.value : kd.textContent,
            f = e.length,
            a = 0;
          a < c && b[a] === e[a];
          a++
        );
        for (var g = c - a, d = 1; d <= g && b[c - d] === e[f - d]; d++);
        return (md = e.slice(a, 1 < d ? 1 - d : void 0));
      }
      function od(a) {
        var b = a.keyCode;
        return (
          "charCode" in a
            ? 0 === (a = a.charCode) && 13 === b && (a = 13)
            : (a = b),
          32 <= (a = 10 === a ? 13 : a) || 13 === a ? a : 0
        );
      }
      function pd() {
        return !0;
      }
      function qd() {
        return !1;
      }
      function rd(a) {
        function b(b, d, e, f, g) {
          for (var c in ((this._reactName = b),
          (this._targetInst = e),
          (this.type = d),
          (this.nativeEvent = f),
          (this.target = g),
          (this.currentTarget = null),
          a))
            a.hasOwnProperty(c) && ((b = a[c]), (this[c] = b ? b(f) : f[c]));
          return (
            (this.isDefaultPrevented = (
              null != f.defaultPrevented
                ? f.defaultPrevented
                : !1 === f.returnValue
            )
              ? pd
              : qd),
            (this.isPropagationStopped = qd),
            this
          );
        }
        return (
          A(b.prototype, {
            preventDefault: function () {
              this.defaultPrevented = !0;
              var a = this.nativeEvent;
              a &&
                (a.preventDefault
                  ? a.preventDefault()
                  : "unknown" != typeof a.returnValue && (a.returnValue = !1),
                (this.isDefaultPrevented = pd));
            },
            stopPropagation: function () {
              var a = this.nativeEvent;
              a &&
                (a.stopPropagation
                  ? a.stopPropagation()
                  : "unknown" != typeof a.cancelBubble && (a.cancelBubble = !0),
                (this.isPropagationStopped = pd));
            },
            persist: function () {},
            isPersistent: pd,
          }),
          b
        );
      }
      var wd,
        xd,
        yd,
        Mb = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function (a) {
            return a.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0,
        },
        td = rd(Mb),
        ud = A({}, Mb, { view: 0, detail: 0 }),
        vd = rd(ud),
        Ad = A({}, ud, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: zd,
          button: 0,
          buttons: 0,
          relatedTarget: function (a) {
            return void 0 === a.relatedTarget
              ? a.fromElement === a.srcElement
                ? a.toElement
                : a.fromElement
              : a.relatedTarget;
          },
          movementX: function (a) {
            return "movementX" in a
              ? a.movementX
              : (a !== yd &&
                  ((xd =
                    yd && "mousemove" === a.type
                      ? ((wd = a.screenX - yd.screenX), a.screenY - yd.screenY)
                      : (wd = 0)),
                  (yd = a)),
                wd);
          },
          movementY: function (a) {
            return "movementY" in a ? a.movementY : xd;
          },
        }),
        Bd = rd(Ad),
        Dd = rd(A({}, Ad, { dataTransfer: 0 })),
        Fd = rd(A({}, ud, { relatedTarget: 0 })),
        Hd = rd(
          A({}, Mb, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })
        ),
        Jd = rd(
          A({}, Mb, {
            clipboardData: function (a) {
              return ("clipboardData" in a ? a : window).clipboardData;
            },
          })
        ),
        Ld = rd(A({}, Mb, { data: 0 })),
        Md = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified",
        },
        Nd = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta",
        },
        Od = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey",
        };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState
          ? b.getModifierState(a)
          : !!(a = Od[a]) && !!b[a];
      }
      function zd() {
        return Pd;
      }
      var Rd = rd(
          A({}, ud, {
            key: function (a) {
              if (a.key) {
                var b = Md[a.key] || a.key;
                if ("Unidentified" !== b) return b;
              }
              return "keypress" === a.type
                ? 13 === (a = od(a))
                  ? "Enter"
                  : String.fromCharCode(a)
                : "keydown" === a.type || "keyup" === a.type
                ? Nd[a.keyCode] || "Unidentified"
                : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: zd,
            charCode: function (a) {
              return "keypress" === a.type ? od(a) : 0;
            },
            keyCode: function (a) {
              return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            },
            which: function (a) {
              return "keypress" === a.type
                ? od(a)
                : "keydown" === a.type || "keyup" === a.type
                ? a.keyCode
                : 0;
            },
          })
        ),
        Td = rd(
          A({}, Ad, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0,
          })
        ),
        Vd = rd(
          A({}, ud, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: zd,
          })
        ),
        Xd = rd(
          A({}, Mb, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })
        ),
        Zd = rd(
          A({}, Ad, {
            deltaX: function (a) {
              return "deltaX" in a
                ? a.deltaX
                : "wheelDeltaX" in a
                ? -a.wheelDeltaX
                : 0;
            },
            deltaY: function (a) {
              return "deltaY" in a
                ? a.deltaY
                : "wheelDeltaY" in a
                ? -a.wheelDeltaY
                : "wheelDelta" in a
                ? -a.wheelDelta
                : 0;
            },
            deltaZ: 0,
            deltaMode: 0,
          })
        ),
        $d = [9, 13, 27, 32],
        ae = __webpack_require__ && "CompositionEvent" in window,
        ud = null,
        ce =
          (__webpack_require__ &&
            "documentMode" in document &&
            (ud = document.documentMode),
          __webpack_require__ && "TextEvent" in window && !ud),
        de = __webpack_require__ && (!ae || (ud && 8 < ud && ud <= 11)),
        ee = String.fromCharCode(32),
        fe = !1;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return 1;
          default:
            return;
        }
      }
      function he(a) {
        return "object" == typeof (a = a.detail) && "data" in a ? a.data : null;
      }
      var ie = !1;
      var le = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0,
      };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? le[a.type] : "textarea" === b;
      }
      function ne(a, b, c, d) {
        Eb(d),
          0 < (b = oe(b, "onChange")).length &&
            ((c = new td("onChange", "change", null, c, d)),
            a.push({ event: c, listeners: b }));
      }
      var pe = null,
        qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        if (Wa(ue(a))) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = !1;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), (qe = pe = null));
      }
      function Be(a) {
        var b;
        "value" === a.propertyName &&
          te(qe) &&
          (ne((b = []), qe, a, xb(a)), Jb(re, b));
      }
      function Ce(a, b, c) {
        "focusin" === a
          ? (Ae(), (qe = c), (pe = b).attachEvent("onpropertychange", Be))
          : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a)
          return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      __webpack_require__ &&
        ((ud =
          __webpack_require__ &&
          ((Mb = "oninput" in document) ||
            ((Ad = document.createElement("div")).setAttribute(
              "oninput",
              "return;"
            ),
            (Mb = "function" == typeof Ad.oninput)),
          Mb)),
        (we = ud && (!document.documentMode || 9 < document.documentMode)));
      var He =
        "function" == typeof Object.is
          ? Object.is
          : function Ge(a, b) {
              return (
                (a === b && (0 !== a || 1 / a == 1 / b)) || (a != a && b != b)
              );
            };
      function Ie(a, b) {
        if (!He(a, b)) {
          if (
            "object" != typeof a ||
            null === a ||
            "object" != typeof b ||
            null === b
          )
            return !1;
          var c = Object.keys(a),
            d = Object.keys(b);
          if (c.length !== d.length) return !1;
          for (d = 0; d < c.length; d++) {
            var e = c[d];
            if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
          }
        }
        return !0;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var d,
          c = Je(a);
        for (a = 0; c; ) {
          if (3 === c.nodeType) {
            if (((d = a + c.textContent.length), a <= b && b <= d))
              return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" == typeof b.contentWindow.location.href;
          } catch (d) {
            c = !1;
          }
          if (!c) break;
          b = Xa((a = b.contentWindow).document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return (
          b &&
          (("input" === b &&
            ("text" === a.type ||
              "search" === a.type ||
              "tel" === a.type ||
              "url" === a.type ||
              "password" === a.type)) ||
            "textarea" === b ||
            "true" === a.contentEditable)
        );
      }
      function Oe(a) {
        var f,
          e,
          g,
          b = Me(),
          c = a.focusedElem,
          d = a.selectionRange;
        if (
          b !== c &&
          c &&
          c.ownerDocument &&
          (function Le(a, b) {
            return (
              !(!a || !b) &&
              (a === b ||
                ((!a || 3 !== a.nodeType) &&
                  (b && 3 === b.nodeType
                    ? Le(a, b.parentNode)
                    : "contains" in a
                    ? a.contains(b)
                    : !!a.compareDocumentPosition &&
                      !!(16 & a.compareDocumentPosition(b)))))
            );
          })(c.ownerDocument.documentElement, c)
        ) {
          null !== d &&
            Ne(c) &&
            ((b = d.start),
            void 0 === (a = d.end) && (a = b),
            "selectionStart" in c
              ? ((c.selectionStart = b),
                (c.selectionEnd = Math.min(a, c.value.length)))
              : (a =
                  ((b = c.ownerDocument || document) && b.defaultView) ||
                  window).getSelection &&
                ((a = a.getSelection()),
                (e = c.textContent.length),
                (f = Math.min(d.start, e)),
                (d = void 0 === d.end ? f : Math.min(d.end, e)),
                !a.extend && d < f && ((e = d), (d = f), (f = e)),
                (e = Ke(c, f)),
                (g = Ke(c, d)),
                e) &&
                g &&
                (1 !== a.rangeCount ||
                  a.anchorNode !== e.node ||
                  a.anchorOffset !== e.offset ||
                  a.focusNode !== g.node ||
                  a.focusOffset !== g.offset) &&
                ((b = b.createRange()).setStart(e.node, e.offset),
                a.removeAllRanges(),
                d < f
                  ? (a.addRange(b), a.extend(g.node, g.offset))
                  : (b.setEnd(g.node, g.offset), a.addRange(b)))),
            (b = []);
          for (a = c; (a = a.parentNode); )
            1 === a.nodeType &&
              b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          for (
            "function" == typeof c.focus && c.focus(), c = 0;
            c < b.length;
            c++
          )
            ((a = b[c]).element.scrollLeft = a.left),
              (a.element.scrollTop = a.top);
        }
      }
      var Pe =
          __webpack_require__ &&
          "documentMode" in document &&
          document.documentMode <= 11,
        Qe = null,
        Re = null,
        Se = null,
        Te = !1;
      function Ue(a, b, c) {
        var d =
          c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te ||
          null == Qe ||
          Qe !== Xa(d) ||
          ((d =
            "selectionStart" in (d = Qe) && Ne(d)
              ? { start: d.selectionStart, end: d.selectionEnd }
              : {
                  anchorNode: (d = (
                    (d.ownerDocument && d.ownerDocument.defaultView) ||
                    window
                  ).getSelection()).anchorNode,
                  anchorOffset: d.anchorOffset,
                  focusNode: d.focusNode,
                  focusOffset: d.focusOffset,
                }),
          Se && Ie(Se, d)) ||
          ((Se = d),
          0 < (d = oe(Re, "onSelect")).length &&
            ((b = new td("onSelect", "select", null, b, c)),
            a.push({ event: b, listeners: d }),
            (b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        return (
          (c[a.toLowerCase()] = b.toLowerCase()),
          (c["Webkit" + a] = "webkit" + b),
          (c["Moz" + a] = "moz" + b),
          c
        );
      }
      var We = {
          animationend: Ve("Animation", "AnimationEnd"),
          animationiteration: Ve("Animation", "AnimationIteration"),
          animationstart: Ve("Animation", "AnimationStart"),
          transitionend: Ve("Transition", "TransitionEnd"),
        },
        Xe = {},
        Ye = {};
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (We[a]) {
          var c,
            b = We[a];
          for (c in b)
            if (b.hasOwnProperty(c) && c in Ye) return (Xe[a] = b[c]);
        }
        return a;
      }
      __webpack_require__ &&
        ((Ye = document.createElement("div").style),
        "AnimationEvent" in window ||
          (delete We.animationend.animation,
          delete We.animationiteration.animation,
          delete We.animationstart.animation),
        "TransitionEvent" in window || delete We.transitionend.transition);
      var $e = Ze("animationend"),
        af = Ze("animationiteration"),
        bf = Ze("animationstart"),
        cf = Ze("transitionend"),
        df = new Map(),
        ef =
          "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
            " "
          );
      function ff(a, b) {
        df.set(a, b), fa(b, [a]);
      }
      for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf];
        ff(hf.toLowerCase(), "on" + (hf[0].toUpperCase() + hf.slice(1)));
      }
      ff($e, "onAnimationEnd"),
        ff(af, "onAnimationIteration"),
        ff(bf, "onAnimationStart"),
        ff("dblclick", "onDoubleClick"),
        ff("focusin", "onFocus"),
        ff("focusout", "onBlur"),
        ff(cf, "onTransitionEnd"),
        ha("onMouseEnter", ["mouseout", "mouseover"]),
        ha("onMouseLeave", ["mouseout", "mouseover"]),
        ha("onPointerEnter", ["pointerout", "pointerover"]),
        ha("onPointerLeave", ["pointerout", "pointerover"]),
        fa(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        ),
        fa(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        ),
        fa("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste",
        ]),
        fa(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        ),
        fa(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(
            " "
          )
        ),
        fa(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(
            " "
          )
        );
      var lf =
          "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
            " "
          ),
        mf = new Set(
          "cancel close invalid load scroll toggle".split(" ").concat(lf)
        );
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        (a.currentTarget = c),
          (function Ub() {
            var l;
            Tb.apply(this, arguments),
              Ob &&
                ((l = Pb), (Ob = !1), (Pb = null), Qb || ((Qb = !0), (Rb = l)));
          })(d, b, void 0, a),
          (a.currentTarget = null);
      }
      function se(a, b) {
        b = 0 != (4 & b);
        for (var c = 0; c < a.length; c++) {
          var e = (d = a[c]).event,
            d = d.listeners;
          a: {
            var f = void 0;
            if (b)
              for (var g = d.length - 1; 0 <= g; g--) {
                var k = (h = d[g]).instance,
                  l = h.currentTarget,
                  h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l), (f = k);
              }
            else
              for (g = 0; g < d.length; g++) {
                if (
                  ((k = (h = d[g]).instance),
                  (l = h.currentTarget),
                  (h = h.listener),
                  k !== f && e.isPropagationStopped())
                )
                  break a;
                nf(e, h, l), (f = k);
              }
          }
        }
        if (Qb) throw ((a = Rb), (Qb = !1), (Rb = null), a);
      }
      function D(a, b) {
        var c = b[of],
          d = a + "__bubble";
        (c = void 0 === c ? (b[of] = new Set()) : c).has(d) ||
          (pf(b, a, 2, !1), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4), pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        var b;
        a[rf] ||
          ((a[rf] = !0),
          da.forEach(function (b) {
            "selectionchange" !== b &&
              (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
          }),
          null === (b = 9 === a.nodeType ? a : a.ownerDocument)) ||
          b[rf] ||
          qf("selectionchange", !(b[rf] = !0), b);
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        (c = e.bind(null, b, c, a)),
          (e =
            !Lb || ("touchstart" !== b && "touchmove" !== b && "wheel" !== b)
              ? void 0
              : !0),
          d
            ? void 0 !== e
              ? a.addEventListener(b, c, { capture: !0, passive: e })
              : a.addEventListener(b, c, !0)
            : void 0 !== e
            ? a.addEventListener(b, c, { passive: e })
            : a.addEventListener(b, c, !1);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 == (1 & b) && 0 == (2 & b) && null !== d)
          a: for (;;) {
            if (null === d) return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || (8 === h.nodeType && h.parentNode === e)) break;
              if (4 === g)
                for (g = d.return; null !== g; ) {
                  var k = g.tag;
                  if (
                    (3 === k || 4 === k) &&
                    ((k = g.stateNode.containerInfo) === e ||
                      (8 === k.nodeType && k.parentNode === e))
                  )
                    return;
                  g = g.return;
                }
              for (; null !== h; ) {
                if (null === (g = Wc(h))) return;
                if (5 === (k = g.tag) || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
        Jb(function () {
          var na,
            xa,
            $a,
            d = f,
            e = xb(c),
            g = [];
          a: {
            var h = df.get(a);
            if (void 0 !== h) {
              var k = td,
                n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k = Rd;
                  break;
                case "focusin":
                  (n = "focus"), (k = Fd);
                  break;
                case "focusout":
                  (n = "blur"), (k = Fd);
                  break;
                case "beforeblur":
                case "afterblur":
                  k = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k = Hd;
                  break;
                case cf:
                  k = Xd;
                  break;
                case "scroll":
                  k = vd;
                  break;
                case "wheel":
                  k = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k = Td;
              }
              for (
                var J = !(t = 0 != (4 & b)) && "scroll" === a,
                  x = t ? (null !== h ? h + "Capture" : null) : h,
                  t = [],
                  w = d;
                null !== w;

              ) {
                var u,
                  F = (u = w).stateNode;
                if (
                  (5 === u.tag &&
                    null !== F &&
                    ((u = F), null !== x) &&
                    null != (F = Kb(w, x)) &&
                    t.push(tf(w, F, u)),
                  J)
                )
                  break;
                w = w.return;
              }
              0 < t.length &&
                ((h = new k(h, n, null, c, e)),
                g.push({ event: h, listeners: t }));
            }
          }
          if (0 == (7 & b)) {
            if (
              ((k = "mouseout" === a || "pointerout" === a),
              (!(h = "mouseover" === a || "pointerover" === a) ||
                c === wb ||
                !(n = c.relatedTarget || c.fromElement) ||
                (!Wc(n) && !n[uf])) &&
                (k || h) &&
                ((h =
                  e.window === e
                    ? e
                    : (h = e.ownerDocument)
                    ? h.defaultView || h.parentWindow
                    : window),
                k
                  ? ((k = d),
                    null !==
                      (n = (n = c.relatedTarget || c.toElement)
                        ? Wc(n)
                        : null) &&
                      (n !== (J = Vb(n)) || (5 !== n.tag && 6 !== n.tag)) &&
                      (n = null))
                  : ((k = null), (n = d)),
                k !== n))
            ) {
              if (
                ((t = Bd),
                (F = "onMouseLeave"),
                (x = "onMouseEnter"),
                (w = "mouse"),
                ("pointerout" !== a && "pointerover" !== a) ||
                  ((t = Td),
                  (F = "onPointerLeave"),
                  (x = "onPointerEnter"),
                  (w = "pointer")),
                (J = null == k ? h : ue(k)),
                (u = null == n ? h : ue(n)),
                ((h = new t(F, w + "leave", k, c, e)).target = J),
                (h.relatedTarget = u),
                (F = null),
                Wc(e) === d &&
                  (((t = new t(x, w + "enter", n, c, e)).target = u),
                  (t.relatedTarget = J),
                  (F = t)),
                (J = F),
                k && n)
              )
                b: {
                  for (x = n, w = 0, u = t = k; u; u = vf(u)) w++;
                  for (u = 0, F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) (t = vf(t)), w--;
                  for (; 0 < u - w; ) (x = vf(x)), u--;
                  for (; w--; ) {
                    if (t === x || (null !== x && t === x.alternate)) break b;
                    (t = vf(t)), (x = vf(x));
                  }
                  t = null;
                }
              else t = null;
              null !== k && wf(g, h, k, t, !1),
                null !== n && null !== J && wf(g, J, n, t, !0);
            }
            switch (
              ("select" ===
                (k =
                  (h = d ? ue(d) : window).nodeName &&
                  h.nodeName.toLowerCase()) ||
              ("input" === k && "file" === h.type)
                ? (na = ve)
                : me(h)
                ? we
                  ? (na = Fe)
                  : ((na = De), (xa = Ce))
                : !(k = h.nodeName) ||
                  "input" !== k.toLowerCase() ||
                  ("checkbox" !== h.type && "radio" !== h.type) ||
                  (na = Ee),
              (na = na && na(a, d))
                ? ne(g, na, c, e)
                : (xa && xa(a, h, d),
                  "focusout" === a &&
                    (xa = h._wrapperState) &&
                    xa.controlled &&
                    "number" === h.type &&
                    cb(h, "number", h.value)),
              (xa = d ? ue(d) : window),
              a)
            ) {
              case "focusin":
                (!me(xa) && "true" !== xa.contentEditable) ||
                  ((Qe = xa), (Re = d), (Se = null));
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = !0;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                (Te = !1), Ue(g, c, e);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g, c, e);
            }
            if (ae)
              b: {
                switch (a) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              }
            else
              ie
                ? ge(a, c) && (ba = "onCompositionEnd")
                : "keydown" === a &&
                  229 === c.keyCode &&
                  (ba = "onCompositionStart");
            ba &&
              (de &&
                "ko" !== c.locale &&
                (ie || "onCompositionStart" !== ba
                  ? "onCompositionEnd" === ba && ie && ($a = nd())
                  : ((ld = "value" in (kd = e) ? kd.value : kd.textContent),
                    (ie = !0))),
              0 < (xa = oe(d, ba)).length) &&
              ((ba = new Ld(ba, a, null, c, e)),
              g.push({ event: ba, listeners: xa }),
              $a || null !== ($a = he(c))) &&
              (ba.data = $a),
              ($a = (
                ce
                  ? function je(a, b) {
                      switch (a) {
                        case "compositionend":
                          return he(b);
                        case "keypress":
                          return 32 !== b.which ? null : ((fe = !0), ee);
                        case "textInput":
                          return (a = b.data) === ee && fe ? null : a;
                        default:
                          return null;
                      }
                    }
                  : function ke(a, b) {
                      if (ie)
                        return "compositionend" === a || (!ae && ge(a, b))
                          ? ((a = nd()), (md = ld = kd = null), (ie = !1), a)
                          : null;
                      switch (a) {
                        case "paste":
                          return null;
                        case "keypress":
                          if (
                            !(b.ctrlKey || b.altKey || b.metaKey) ||
                            (b.ctrlKey && b.altKey)
                          ) {
                            if (b.char && 1 < b.char.length) return b.char;
                            if (b.which) return String.fromCharCode(b.which);
                          }
                          return null;
                        case "compositionend":
                          return de && "ko" !== b.locale ? null : b.data;
                        default:
                          return null;
                      }
                    }
              )(a, c)) &&
                0 < (d = oe(d, "onBeforeInput")).length &&
                ((e = new Ld("onBeforeInput", "beforeinput", null, c, e)),
                g.push({ event: e, listeners: d }),
                (e.data = $a));
          }
          se(g, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a,
            f = e.stateNode;
          5 === e.tag &&
            null !== f &&
            ((e = f),
            null != (f = Kb(a, c)) && d.unshift(tf(a, f, e)),
            null != (f = Kb(a, b))) &&
            d.push(tf(a, f, e)),
            (a = a.return);
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        for (; (a = a.return) && 5 !== a.tag; );
        return a || null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c,
            k = h.alternate,
            l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag &&
            null !== l &&
            ((h = l),
            e
              ? null != (k = Kb(c, f)) && g.unshift(tf(c, k, h))
              : null != (k = Kb(c, f)) && g.push(tf(c, k, h))),
            (c = c.return);
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g,
        yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" == typeof a ? a : "" + a)
          .replace(xf, "\n")
          .replace(yf, "");
      }
      function Af(a, b, c) {
        if (((b = zf(b)), zf(a) !== b && c)) throw Error(p(425));
      }
      function Bf() {}
      var Cf = null,
        Df = null;
      function Ef(a, b) {
        return (
          "textarea" === a ||
          "noscript" === a ||
          "string" == typeof b.children ||
          "number" == typeof b.children ||
          ("object" == typeof b.dangerouslySetInnerHTML &&
            null !== b.dangerouslySetInnerHTML &&
            null != b.dangerouslySetInnerHTML.__html)
        );
      }
      var Ff = "function" == typeof setTimeout ? setTimeout : void 0,
        Gf = "function" == typeof clearTimeout ? clearTimeout : void 0,
        Hf = "function" == typeof Promise ? Promise : void 0,
        Jf =
          "function" == typeof queueMicrotask
            ? queueMicrotask
            : void 0 !== Hf
            ? function (a) {
                return Hf.resolve(null).then(a).catch(If);
              }
            : Ff;
      function If(a) {
        setTimeout(function () {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b,
          d = 0;
        do {
          var e = c.nextSibling;
          if ((a.removeChild(c), e && 8 === e.nodeType))
            if ("/$" === (c = e.data)) {
              if (0 === d) return a.removeChild(e), void bd(b);
              d--;
            } else ("$" !== c && "$?" !== c && "$!" !== c) || d++;
        } while ((c = e));
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            if ("$" === (b = a.data) || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Ad = Math.random().toString(36).slice(2),
        Of = "__reactFiber$" + Ad,
        Pf = "__reactProps$" + Ad,
        uf = "__reactContainer$" + Ad,
        of = "__reactEvents$" + Ad,
        Qf = "__reactListeners$" + Ad,
        Rf = "__reactHandles$" + Ad;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if ((b = c[uf] || c[Of])) {
            if (
              ((c = b.alternate),
              null !== b.child || (null !== c && null !== c.child))
            )
              for (a = Mf(a); null !== a; ) {
                if ((c = a[Of])) return c;
                a = Mf(a);
              }
            return b;
          }
          c = (a = c).parentNode;
        }
        return null;
      }
      function Cb(a) {
        return !(a = a[Of] || a[uf]) ||
          (5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag)
          ? null
          : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [],
        Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        Tf < 0 || ((a.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
      }
      function G(a, b) {
        (Sf[++Tf] = a.current), (a.current = b);
      }
      var Vf = {},
        H = Uf(Vf),
        Wf = Uf(!1),
        Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
          return d.__reactInternalMemoizedMaskedChildContext;
        var f,
          e = {};
        for (f in c) e[f] = b[f];
        return (
          d &&
            (((a = a.stateNode).__reactInternalMemoizedUnmaskedChildContext =
              b),
            (a.__reactInternalMemoizedMaskedChildContext = e)),
          e
        );
      }
      function Zf(a) {
        return null != (a = a.childContextTypes);
      }
      function $f() {
        E(Wf), E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b), G(Wf, c);
      }
      function bg(a, b, c) {
        var e,
          d = a.stateNode;
        if (((b = b.childContextTypes), "function" != typeof d.getChildContext))
          return c;
        for (e in (d = d.getChildContext()))
          if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        (a =
          ((a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext) ||
          Vf),
          (Xf = H.current),
          G(H, a),
          G(Wf, Wf.current);
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c
          ? ((a = bg(a, b, Xf)),
            (d.__reactInternalMemoizedMergedChildContext = a),
            E(Wf),
            E(H),
            G(H, a))
          : E(Wf),
          G(Wf, c);
      }
      var eg = null,
        fg = !1,
        gg = !1;
      function hg(a) {
        null === eg ? (eg = [a]) : eg.push(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = !0;
          var a = 0,
            b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++)
              for (var d = c[a]; null !== (d = d(!0)); );
            (eg = null), (fg = !1);
          } catch (e) {
            throw (null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e);
          } finally {
            (C = b), (gg = !1);
          }
        }
        return null;
      }
      var kg = [],
        lg = 0,
        mg = null,
        ng = 0,
        og = [],
        pg = 0,
        qg = null,
        rg = 1,
        sg = "";
      function tg(a, b) {
        (kg[lg++] = ng), (kg[lg++] = mg), (mg = a), (ng = b);
      }
      function ug(a, b, c) {
        (og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (qg = a);
        var g,
          d = rg,
          e = ((a = sg), 32 - oc(d) - 1),
          f = ((d &= ~(1 << e)), (c += 1), 32 - oc(b) + e);
        sg =
          30 < f
            ? ((f = (d & ((1 << (g = e - (e % 5))) - 1)).toString(32)),
              (d >>= g),
              (e -= g),
              (rg = (1 << (32 - oc(b) + e)) | (c << e) | d),
              f + a)
            : ((rg = (1 << f) | (c << e) | d), a);
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; )
          (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null);
        for (; a === qg; )
          (qg = og[--pg]),
            (og[pg] = null),
            (sg = og[--pg]),
            (og[pg] = null),
            (rg = og[--pg]),
            (og[pg] = null);
      }
      var xg = null,
        yg = null,
        I = !1,
        zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        (c.elementType = "DELETED"),
          (c.stateNode = b),
          null === (b = (c.return = a).deletions)
            ? ((a.deletions = [c]), (a.flags |= 16))
            : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            return (
              null !==
                (b =
                  1 !== b.nodeType ||
                  c.toLowerCase() !== b.nodeName.toLowerCase()
                    ? null
                    : b) &&
              ((a.stateNode = b), (xg = a), (yg = Lf(b.firstChild)), 1)
            );
          case 6:
            return (
              null !==
                (b = "" === a.pendingProps || 3 !== b.nodeType ? null : b) &&
              ((a.stateNode = b), (xg = a), (yg = null), 1)
            );
          case 13:
            return (
              null !== (b = 8 !== b.nodeType ? null : b) &&
              ((c = null !== qg ? { id: rg, overflow: sg } : null),
              (a.memoizedState = {
                dehydrated: b,
                treeContext: c,
                retryLane: 1073741824,
              }),
              ((c = Bg(18, null, null, 0)).stateNode = b),
              ((c.return = a).child = c),
              (xg = a),
              (yg = null),
              1)
            );
          default:
            return;
        }
      }
      function Dg(a) {
        return 0 != (1 & a.mode) && 0 == (128 & a.flags);
      }
      function Eg(a) {
        if (I)
          if (yg) {
            var c = yg;
            if (!Cg(a, yg)) {
              if (Dg(a)) throw Error(p(418));
              var b = Lf(c.nextSibling),
                d = xg;
              b && Cg(a, b)
                ? Ag(d, c)
                : ((a.flags = (-4097 & a.flags) | 2), (I = !1), (xg = a));
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            (a.flags = (-4097 & a.flags) | 2), (I = !1), (xg = a);
          }
      }
      function Fg(a) {
        for (
          a = a.return;
          null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;

        )
          a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return !1;
        if (!I) return Fg(a), !(I = !0);
        var b;
        if (
          (b =
            (b =
              (b = 3 !== a.tag) && !(b = 5 !== a.tag)
                ? "head" !== (b = a.type) &&
                  "body" !== b &&
                  !Ef(a.type, a.memoizedProps)
                : b) && yg)
        ) {
          if (Dg(a)) throw (Hg(), Error(p(418)));
          for (; b; ) Ag(a, b), (b = Lf(b.nextSibling));
        }
        if ((Fg(a), 13 === a.tag)) {
          if (!(a = null !== (a = a.memoizedState) ? a.dehydrated : null))
            throw Error(p(317));
          a: {
            for (a = a.nextSibling, b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else ("$" !== c && "$!" !== c && "$?" !== c) || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return !0;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        (yg = xg = null), (I = !1);
      }
      function Jg(a) {
        null === zg ? (zg = [a]) : zg.push(a);
      }
      var Kg = aa.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        if (
          null !== (a = c.ref) &&
          "function" != typeof a &&
          "object" != typeof a
        ) {
          if (c._owner) {
            if ((c = c._owner)) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            var e, f;
            if (d)
              return (
                (e = d),
                (f = "" + a),
                null !== b &&
                null !== b.ref &&
                "function" == typeof b.ref &&
                b.ref._stringRef === f
                  ? b.ref
                  : (((b = function (a) {
                      var b = e.refs;
                      null === a ? delete b[f] : (b[f] = a);
                    })._stringRef = f),
                    b)
              );
            throw Error(p(147, a));
          }
          if ("string" != typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        throw (
          ((a = Object.prototype.toString.call(b)),
          Error(
            p(
              31,
              "[object Object]" === a
                ? "object with keys {" + Object.keys(b).join(", ") + "}"
                : a
            )
          ))
        );
      }
      function Ng(a) {
        return (0, a._init)(a._payload);
      }
      function Og(a) {
        function b(b, c) {
          var d;
          a &&
            (null === (d = b.deletions)
              ? ((b.deletions = [c]), (b.flags |= 16))
              : d.push(c));
        }
        function c(c, d) {
          if (a) for (; null !== d; ) b(c, d), (d = d.sibling);
          return null;
        }
        function d(a, b) {
          for (a = new Map(); null !== b; )
            null !== b.key ? a.set(b.key, b) : a.set(b.index, b),
              (b = b.sibling);
          return a;
        }
        function e(a, b) {
          return ((a = Pg(a, b)).index = 0), (a.sibling = null), a;
        }
        function f(b, c, d) {
          if (((b.index = d), a)) {
            if (null !== (d = b.alternate))
              return (d = d.index) < c ? ((b.flags |= 2), c) : d;
            b.flags |= 2;
          } else b.flags |= 1048576;
          return c;
        }
        function g(b) {
          return a && null === b.alternate && (b.flags |= 2), b;
        }
        function h(a, b, c, d) {
          return (
            null === b || 6 !== b.tag
              ? ((b = Qg(c, a.mode, d)).return = a)
              : ((b = e(b, c)).return = a),
            b
          );
        }
        function k(a, b, c, d) {
          var f = c.type;
          return f === ya
            ? m(a, b, c.props.children, d, c.key)
            : (null !== b &&
              (b.elementType === f ||
                ("object" == typeof f &&
                  null !== f &&
                  f.$$typeof === Ha &&
                  Ng(f) === b.type))
                ? ((d = e(b, c.props)).ref = Lg(0, b, c))
                : ((d = Rg(c.type, c.key, c.props, null, a.mode, d)).ref = Lg(
                    0,
                    b,
                    c
                  )),
              (d.return = a),
              d);
        }
        function l(a, b, c, d) {
          return (
            null === b ||
            4 !== b.tag ||
            b.stateNode.containerInfo !== c.containerInfo ||
            b.stateNode.implementation !== c.implementation
              ? ((b = Sg(c, a.mode, d)).return = a)
              : ((b = e(b, c.children || [])).return = a),
            b
          );
        }
        function m(a, b, c, d, f) {
          return (
            null === b || 7 !== b.tag
              ? ((b = Tg(c, a.mode, d, f)).return = a)
              : ((b = e(b, c)).return = a),
            b
          );
        }
        function q(a, b, c) {
          if (("string" == typeof b && "" !== b) || "number" == typeof b)
            return ((b = Qg("" + b, a.mode, c)).return = a), b;
          if ("object" == typeof b && null !== b) {
            switch (b.$$typeof) {
              case va:
                return (
                  ((c = Rg(b.type, b.key, b.props, null, a.mode, c)).ref = Lg(
                    0,
                    null,
                    b
                  )),
                  (c.return = a),
                  c
                );
              case wa:
                return ((b = Sg(b, a.mode, c)).return = a), b;
              case Ha:
                return q(a, (0, b._init)(b._payload), c);
            }
            if (eb(b) || Ka(b))
              return ((b = Tg(b, a.mode, c, null)).return = a), b;
            Mg(0, b);
          }
          return null;
        }
        function r(a, b, c, d) {
          var e = null !== b ? b.key : null;
          if (("string" == typeof c && "" !== c) || "number" == typeof c)
            return null !== e ? null : h(a, b, "" + c, d);
          if ("object" == typeof c && null !== c) {
            switch (c.$$typeof) {
              case va:
                return c.key === e ? k(a, b, c, d) : null;
              case wa:
                return c.key === e ? l(a, b, c, d) : null;
              case Ha:
                return r(a, b, (e = c._init)(c._payload), d);
            }
            if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
            Mg(0, c);
          }
          return null;
        }
        function y(a, b, c, d, e) {
          if (("string" == typeof d && "" !== d) || "number" == typeof d)
            return h(b, (a = a.get(c) || null), "" + d, e);
          if ("object" == typeof d && null !== d) {
            switch (d.$$typeof) {
              case va:
                return k(
                  b,
                  (a = a.get(null === d.key ? c : d.key) || null),
                  d,
                  e
                );
              case wa:
                return l(
                  b,
                  (a = a.get(null === d.key ? c : d.key) || null),
                  d,
                  e
                );
              case Ha:
                return y(a, b, c, (0, d._init)(d._payload), e);
            }
            if (eb(d) || Ka(d)) return m(b, (a = a.get(c) || null), d, e, null);
            Mg(0, d);
          }
          return null;
        }
        function n(e, g, h, k) {
          for (
            var l = null, m = null, u = g, w = (g = 0), x = null;
            null !== u && w < h.length;
            w++
          ) {
            u.index > w ? ((x = u), (u = null)) : (x = u.sibling);
            var n = r(e, u, h[w], k);
            if (null === n) {
              null === u && (u = x);
              break;
            }
            a && u && null === n.alternate && b(e, u),
              (g = f(n, g, w)),
              null === m ? (l = n) : (m.sibling = n),
              (m = n),
              (u = x);
          }
          if (w === h.length) c(e, u);
          else if (null === u)
            for (; w < h.length; w++)
              null !== (u = q(e, h[w], k)) &&
                ((g = f(u, g, w)),
                null === m ? (l = u) : (m.sibling = u),
                (m = u));
          else {
            for (u = d(e, u); w < h.length; w++)
              null !== (x = y(u, e, w, h[w], k)) &&
                (a &&
                  null !== x.alternate &&
                  u.delete(null === x.key ? w : x.key),
                (g = f(x, g, w)),
                null === m ? (l = x) : (m.sibling = x),
                (m = x));
            a &&
              u.forEach(function (a) {
                return b(e, a);
              });
          }
          return I && tg(e, w), l;
        }
        function t(e, g, h, k) {
          var l = Ka(h);
          if ("function" != typeof l) throw Error(p(150));
          if (null == (h = l.call(h))) throw Error(p(151));
          for (
            var u = (l = null), m = g, w = (g = 0), x = null, n = h.next();
            null !== m && !n.done;
            w++, n = h.next()
          ) {
            m.index > w ? ((x = m), (m = null)) : (x = m.sibling);
            var t = r(e, m, n.value, k);
            if (null === t) {
              null === m && (m = x);
              break;
            }
            a && m && null === t.alternate && b(e, m),
              (g = f(t, g, w)),
              null === u ? (l = t) : (u.sibling = t),
              (u = t),
              (m = x);
          }
          if (n.done) c(e, m);
          else if (null === m)
            for (; !n.done; w++, n = h.next())
              null !== (n = q(e, n.value, k)) &&
                ((g = f(n, g, w)),
                null === u ? (l = n) : (u.sibling = n),
                (u = n));
          else {
            for (m = d(e, m); !n.done; w++, n = h.next())
              null !== (n = y(m, e, w, n.value, k)) &&
                (a &&
                  null !== n.alternate &&
                  m.delete(null === n.key ? w : n.key),
                (g = f(n, g, w)),
                null === u ? (l = n) : (u.sibling = n),
                (u = n));
            a &&
              m.forEach(function (a) {
                return b(e, a);
              });
          }
          return I && tg(e, w), l;
        }
        return function J(a, d, f, h) {
          if (
            "object" ==
              typeof (f =
                "object" == typeof f &&
                null !== f &&
                f.type === ya &&
                null === f.key
                  ? f.props.children
                  : f) &&
            null !== f
          ) {
            switch (f.$$typeof) {
              case va:
                a: {
                  for (var k = f.key, l = d; null !== l; ) {
                    if (l.key === k) {
                      if ((k = f.type) === ya) {
                        if (7 === l.tag) {
                          c(a, l.sibling),
                            ((d = e(l, f.props.children)).return = a),
                            (a = d);
                          break a;
                        }
                      } else if (
                        l.elementType === k ||
                        ("object" == typeof k &&
                          null !== k &&
                          k.$$typeof === Ha &&
                          Ng(k) === l.type)
                      ) {
                        c(a, l.sibling),
                          ((d = e(l, f.props)).ref = Lg(0, l, f)),
                          (d.return = a),
                          (a = d);
                        break a;
                      }
                      c(a, l);
                      break;
                    }
                    b(a, l), (l = l.sibling);
                  }
                  a =
                    f.type === ya
                      ? (((d = Tg(f.props.children, a.mode, h, f.key)).return =
                          a),
                        d)
                      : (((h = Rg(
                          f.type,
                          f.key,
                          f.props,
                          null,
                          a.mode,
                          h
                        )).ref = Lg(0, d, f)),
                        (h.return = a),
                        h);
                }
                return g(a);
              case wa:
                a: {
                  for (l = f.key; null !== d; ) {
                    if (d.key === l) {
                      if (
                        4 === d.tag &&
                        d.stateNode.containerInfo === f.containerInfo &&
                        d.stateNode.implementation === f.implementation
                      ) {
                        c(a, d.sibling),
                          ((d = e(d, f.children || [])).return = a),
                          (a = d);
                        break a;
                      }
                      c(a, d);
                      break;
                    }
                    b(a, d), (d = d.sibling);
                  }
                  ((d = Sg(f, a.mode, h)).return = a), (a = d);
                }
                return g(a);
              case Ha:
                return J(a, d, (l = f._init)(f._payload), h);
            }
            if (eb(f)) return n(a, d, f, h);
            if (Ka(f)) return t(a, d, f, h);
            Mg(0, f);
          }
          return ("string" == typeof f && "" !== f) || "number" == typeof f
            ? ((f = "" + f),
              ((d =
                null !== d && 6 === d.tag
                  ? (c(a, d.sibling), e(d, f))
                  : (c(a, d), Qg(f, a.mode, h))).return = a),
              g((a = d)))
            : c(a, d);
        };
      }
      var Ug = Og(!0),
        Vg = Og(!1),
        Wg = Uf(null),
        Xg = null,
        Yg = null,
        Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg), (a._currentValue = b);
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          if (
            ((a.childLanes & b) !== b
              ? ((a.childLanes |= b), null !== d && (d.childLanes |= b))
              : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b),
            a === c)
          )
            break;
          a = a.return;
        }
      }
      function ch(a, b) {
        (Zg = Yg = null) !== (a = (Xg = a).dependencies) &&
          null !== a.firstContext &&
          (0 != (a.lanes & b) && (dh = !0), (a.firstContext = null));
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a)
          if (
            ((a = { context: a, memoizedValue: b, next: null }), null === Yg)
          ) {
            if (null === Xg) throw Error(p(308));
            (Yg = a), (Xg.dependencies = { lanes: 0, firstContext: a });
          } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? (fh = [a]) : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        return (
          null === e
            ? ((c.next = c), gh(b))
            : ((c.next = e.next), (e.next = c)),
          (b.interleaved = c),
          ih(a, d)
        );
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        for (null !== c && (c.lanes |= b), a = (c = a).return; null !== a; )
          (a.childLanes |= b),
            null !== (c = a.alternate) && (c.childLanes |= b),
            (a = (c = a).return);
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = !1;
      function kh(a) {
        a.updateQueue = {
          baseState: a.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, interleaved: null, lanes: 0 },
          effects: null,
        };
      }
      function lh(a, b) {
        (a = a.updateQueue),
          b.updateQueue === a &&
            (b.updateQueue = {
              baseState: a.baseState,
              firstBaseUpdate: a.firstBaseUpdate,
              lastBaseUpdate: a.lastBaseUpdate,
              shared: a.shared,
              effects: a.effects,
            });
      }
      function mh(a, b) {
        return {
          eventTime: a,
          lane: b,
          tag: 0,
          payload: null,
          callback: null,
          next: null,
        };
      }
      function nh(a, b, c) {
        var e,
          d = a.updateQueue;
        return null === d
          ? null
          : ((d = d.shared),
            0 != (2 & K)
              ? (null === (e = d.pending)
                  ? (b.next = b)
                  : ((b.next = e.next), (e.next = b)),
                (d.pending = b))
              : (null === (e = d.interleaved)
                  ? ((b.next = b), gh(d))
                  : ((b.next = e.next), (e.next = b)),
                (d.interleaved = b)),
            ih(a, c));
      }
      function oh(a, b, c) {
        var d;
        null !== (b = b.updateQueue) &&
          ((b = b.shared), 0 != (4194240 & c)) &&
          ((d = b.lanes), (d &= a.pendingLanes), Cc(a, (b.lanes = c |= d)));
      }
      function ph(a, b) {
        var c = a.updateQueue,
          d = a.alternate;
        if (null !== d && c === (d = d.updateQueue)) {
          var e = null,
            f = null;
          if (null !== (c = c.firstBaseUpdate)) {
            do {
              var g = {
                eventTime: c.eventTime,
                lane: c.lane,
                tag: c.tag,
                payload: c.payload,
                callback: c.callback,
                next: null,
              };
            } while (
              (null === f ? (e = f = g) : (f = f.next = g),
              null !== (c = c.next))
            );
            null === f ? (e = f = b) : (f = f.next = b);
          } else e = f = b;
          (c = {
            baseState: d.baseState,
            firstBaseUpdate: e,
            lastBaseUpdate: f,
            shared: d.shared,
            effects: d.effects,
          }),
            (a.updateQueue = c);
        } else
          null === (a = c.lastBaseUpdate)
            ? (c.firstBaseUpdate = b)
            : (a.next = b),
            (c.lastBaseUpdate = b);
      }
      function qh(a, b, c, d) {
        var k,
          l,
          e = a.updateQueue,
          f = ((jh = !1), e.firstBaseUpdate),
          g = e.lastBaseUpdate;
        if (
          (null !== (h = e.shared.pending) &&
            ((e.shared.pending = null),
            (l = (k = h).next),
            (k.next = null) === g ? (f = l) : (g.next = l),
            (g = k),
            null !== (m = a.alternate)) &&
            (h = (m = m.updateQueue).lastBaseUpdate) !== g &&
            (null === h ? (m.firstBaseUpdate = l) : (h.next = l),
            (m.lastBaseUpdate = k)),
          null !== f)
        ) {
          for (var q = e.baseState, g = 0, m = (l = k = null), h = f; ; ) {
            var r = h.lane,
              y = h.eventTime;
            if ((d & r) === r) {
              null !== m &&
                (m = m.next =
                  {
                    eventTime: y,
                    lane: 0,
                    tag: h.tag,
                    payload: h.payload,
                    callback: h.callback,
                    next: null,
                  });
              a: {
                var n = a,
                  t = h,
                  r = b,
                  y = c;
                switch (t.tag) {
                  case 1:
                    if ("function" == typeof (n = t.payload)) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = (-65537 & n.flags) | 128;
                  case 0:
                    if (
                      null ==
                      (r =
                        "function" == typeof (n = t.payload)
                          ? n.call(y, q, r)
                          : n)
                    )
                      break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = !0;
                }
              }
              null !== h.callback &&
                0 !== h.lane &&
                ((a.flags |= 64),
                null === (r = e.effects) ? (e.effects = [h]) : r.push(h));
            } else
              (y = {
                eventTime: y,
                lane: r,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null,
              }),
                null === m ? ((l = m = y), (k = q)) : (m = m.next = y),
                (g |= r);
            if (null === (h = h.next)) {
              if (null === (h = e.shared.pending)) break;
              (h = (r = h).next),
                (r.next = null),
                (e.lastBaseUpdate = r),
                (e.shared.pending = null);
            }
          }
          if (
            (null === m && (k = q),
            (e.baseState = k),
            (e.firstBaseUpdate = l),
            (e.lastBaseUpdate = m),
            null !== (b = e.shared.interleaved))
          )
            for (e = b; (g |= e.lane), (e = e.next) !== b; );
          else null === f && (e.shared.lanes = 0);
          (rh |= g), (a.lanes = g), (a.memoizedState = q);
        }
      }
      function sh(a, b, c) {
        if (((a = b.effects), (b.effects = null) !== a))
          for (b = 0; b < a.length; b++) {
            var d = a[b],
              e = d.callback;
            if (null !== e) {
              if (((d.callback = null), (d = c), "function" != typeof e))
                throw Error(p(191, e));
              e.call(d);
            }
          }
      }
      var th = {},
        uh = Uf(th),
        vh = Uf(th),
        wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        switch ((G(wh, b), G(vh, a), G(uh, th), (a = b.nodeType))) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            b = lb(
              (b = (a = 8 === a ? b.parentNode : b).namespaceURI || null),
              (a = a.tagName)
            );
        }
        E(uh), G(uh, b);
      }
      function zh() {
        E(uh), E(vh), E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current),
          c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (
              null !== c &&
              (null === (c = c.dehydrated) ||
                "$?" === c.data ||
                "$!" === c.data)
            )
              return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 != (128 & b.flags)) return b;
          } else if (null !== b.child) {
            b = (b.child.return = b).child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          (b.sibling.return = b.return), (b = b.sibling);
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++)
          Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = aa.ReactCurrentDispatcher,
        Gh = aa.ReactCurrentBatchConfig,
        Hh = 0,
        M = null,
        N = null,
        O = null,
        Ih = !1,
        Jh = !1,
        Kh = 0,
        Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null !== b) {
          for (var c = 0; c < b.length && c < a.length; c++)
            if (!He(a[c], b[c])) return;
          return 1;
        }
      }
      function Nh(a, b, c, d, e, f) {
        if (
          ((Hh = f),
          ((M = b).memoizedState = null),
          (b.updateQueue = null),
          (b.lanes = 0),
          (Fh.current = null === a || null === a.memoizedState ? Oh : Ph),
          (a = c(d, e)),
          Jh)
        ) {
          f = 0;
          do {
            if (((Jh = !1), (Kh = 0), 25 <= f)) throw Error(p(301));
          } while (
            ((f += 1),
            (O = N = null),
            (b.updateQueue = null),
            (Fh.current = Qh),
            (a = c(d, e)),
            Jh)
          );
        }
        if (
          ((Fh.current = Rh),
          (b = null !== N && null !== N.next),
          (Hh = 0),
          (O = N = M = null),
          (Ih = !1),
          b)
        )
          throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        return (Kh = 0), a;
      }
      function Th() {
        var a = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null,
        };
        return null === O ? (M.memoizedState = O = a) : (O = O.next = a), O;
      }
      function Uh() {
        a =
          null === N
            ? null !== (a = M.alternate)
              ? a.memoizedState
              : null
            : N.next;
        var a,
          b = null === O ? M.memoizedState : O.next;
        if (null !== b) (O = b), (N = a);
        else {
          if (null === a) throw Error(p(310));
          (a = {
            memoizedState: (N = a).memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null,
          }),
            null === O ? (M.memoizedState = O = a) : (O = O.next = a);
        }
        return O;
      }
      function Vh(a, b) {
        return "function" == typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(),
          c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var g,
          e = (d = N).baseQueue;
        if (
          (null !== (f = c.pending) &&
            (null !== e && ((g = e.next), (e.next = f.next), (f.next = g)),
            (d.baseQueue = e = f),
            (c.pending = null)),
          null !== e)
        ) {
          var f = e.next,
            d = d.baseState,
            h = (g = null),
            k = null,
            l = f;
          do {
            var q,
              m = l.lane;
          } while (
            ((Hh & m) === m
              ? (null !== k &&
                  (k = k.next =
                    {
                      lane: 0,
                      action: l.action,
                      hasEagerState: l.hasEagerState,
                      eagerState: l.eagerState,
                      next: null,
                    }),
                (d = l.hasEagerState ? l.eagerState : a(d, l.action)))
              : ((q = {
                  lane: m,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null,
                }),
                null === k ? ((h = k = q), (g = d)) : (k = k.next = q),
                (M.lanes |= m),
                (rh |= m)),
            null !== (l = l.next) && l !== f)
          );
          null === k ? (g = d) : (k.next = h),
            He(d, b.memoizedState) || (dh = !0),
            (b.memoizedState = d),
            (b.baseState = g),
            (b.baseQueue = k),
            (c.lastRenderedState = d);
        }
        if (null !== (a = c.interleaved))
          for (
            e = a;
            (f = e.lane), (M.lanes |= f), (rh |= f), (e = e.next) !== a;

          );
        else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(),
          c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch,
          e = c.pending,
          f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          for (
            var g = (e = e.next);
            (f = a(f, g.action)), (g = g.next) !== e;

          );
          He(f, b.memoizedState) || (dh = !0),
            (b.memoizedState = f),
            null === b.baseQueue && (b.baseState = f),
            (c.lastRenderedState = f);
        }
        return [f, d];
      }
      function Yh() {}
      function Zh(a, b) {
        var c = M,
          d = Uh(),
          e = b(),
          f = !He(d.memoizedState, e);
        if (
          (f && ((d.memoizedState = e), (dh = !0)),
          (d = d.queue),
          $h(ai.bind(null, c, d, a), [a]),
          d.getSnapshot !== b || f || (null !== O && 1 & O.memoizedState.tag))
        ) {
          if (
            ((c.flags |= 2048),
            bi(9, ci.bind(null, c, d, e, b), void 0, null),
            null === Q)
          )
            throw Error(p(349));
          0 == (30 & Hh) && di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        (a.flags |= 16384),
          (a = { getSnapshot: b, value: c }),
          null === (b = M.updateQueue)
            ? ((M.updateQueue = b = { lastEffect: null, stores: null }).stores =
                [a])
            : null === (c = b.stores)
            ? (b.stores = [a])
            : c.push(a);
      }
      function ci(a, b, c, d) {
        (b.value = c), (b.getSnapshot = d), ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function () {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return 1;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        return (
          "function" == typeof a && (a = a()),
          (b.memoizedState = b.baseState = a),
          (a = (b.queue = a =
            {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Vh,
              lastRenderedState: a,
            }).dispatch =
            function ii(a, b, c) {
              var d = yi(a),
                e = {
                  lane: d,
                  action: c,
                  hasEagerState: !1,
                  eagerState: null,
                  next: null,
                };
              if (zi(a)) Ai(b, e);
              else {
                var f = a.alternate;
                if (
                  0 === a.lanes &&
                  (null === f || 0 === f.lanes) &&
                  null !== (f = b.lastRenderedReducer)
                )
                  try {
                    var k,
                      g = b.lastRenderedState,
                      h = f(g, c);
                    if (((e.hasEagerState = !0), (e.eagerState = h), He(h, g)))
                      return (
                        null === (k = b.interleaved)
                          ? ((e.next = e), gh(b))
                          : ((e.next = k.next), (k.next = e)),
                        void (b.interleaved = e)
                      );
                  } catch (l) {}
                null !== (c = hh(a, b, e, d)) &&
                  ((e = R()), gi(c, a, d, e), Bi(c, b, d));
              }
            }.bind(null, M, a)),
          [b.memoizedState, a]
        );
      }
      function bi(a, b, c, d) {
        return (
          (a = { tag: a, create: b, destroy: c, deps: d, next: null }),
          null === (b = M.updateQueue)
            ? ((M.updateQueue = b =
                { lastEffect: null, stores: null }).lastEffect = a.next =
                a)
            : null === (c = b.lastEffect)
            ? (b.lastEffect = a.next = a)
            : ((d = c.next), ((c.next = a).next = d), (b.lastEffect = a)),
          a
        );
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        (M.flags |= a),
          (e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d));
      }
      function li(a, b, c, d) {
        var e = Uh(),
          f = ((d = void 0 === d ? null : d), void 0);
        if (null !== N) {
          var g = N.memoizedState,
            f = g.destroy;
          if (null !== d && Mh(d, g.deps))
            return void (e.memoizedState = bi(b, c, f, d));
        }
        (M.flags |= a), (e.memoizedState = bi(1 | b, c, f, d));
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        return "function" == typeof b
          ? ((a = a()),
            b(a),
            function () {
              b(null);
            })
          : null != b
          ? ((a = a()),
            (b.current = a),
            function () {
              b.current = null;
            })
          : void 0;
      }
      function qi(a, b, c) {
        return (
          (c = null != c ? c.concat([a]) : null),
          li(4, 4, pi.bind(null, b, a), c)
        );
      }
      function ri() {}
      function si(a, b) {
        var c = Uh(),
          d = ((b = void 0 === b ? null : b), c.memoizedState);
        return null !== d && null !== b && Mh(b, d[1])
          ? d[0]
          : ((c.memoizedState = [a, b]), a);
      }
      function ti(a, b) {
        var c = Uh(),
          d = ((b = void 0 === b ? null : b), c.memoizedState);
        return null !== d && null !== b && Mh(b, d[1])
          ? d[0]
          : ((a = a()), (c.memoizedState = [a, b]), a);
      }
      function ui(a, b, c) {
        return 0 == (21 & Hh)
          ? (a.baseState && ((a.baseState = !1), (dh = !0)),
            (a.memoizedState = c))
          : (He(c, b) ||
              ((c = yc()), (M.lanes |= c), (rh |= c), (a.baseState = !0)),
            b);
      }
      function wi() {
        return Uh().memoizedState;
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || (null !== b && b === M);
      }
      function Ai(a, b) {
        Jh = Ih = !0;
        var c = a.pending;
        null === c ? (b.next = b) : ((b.next = c.next), (c.next = b)),
          (a.pending = b);
      }
      function Bi(a, b, c) {
        var d;
        0 != (4194240 & c) &&
          ((d = b.lanes), (d &= a.pendingLanes), Cc(a, (b.lanes = c |= d)));
      }
      var Rh = {
          readContext: eh,
          useCallback: P,
          useContext: P,
          useEffect: P,
          useImperativeHandle: P,
          useInsertionEffect: P,
          useLayoutEffect: P,
          useMemo: P,
          useReducer: P,
          useRef: P,
          useState: P,
          useDebugValue: P,
          useDeferredValue: P,
          useTransition: P,
          useMutableSource: P,
          useSyncExternalStore: P,
          useId: P,
          unstable_isNewReconciler: !1,
        },
        Oh = {
          readContext: eh,
          useCallback: function (a, b) {
            return (Th().memoizedState = [a, void 0 === b ? null : b]), a;
          },
          useContext: eh,
          useEffect: mi,
          useImperativeHandle: function (a, b, c) {
            return (
              (c = null != c ? c.concat([a]) : null),
              ki(4194308, 4, pi.bind(null, b, a), c)
            );
          },
          useLayoutEffect: function (a, b) {
            return ki(4194308, 4, a, b);
          },
          useInsertionEffect: function (a, b) {
            return ki(4, 2, a, b);
          },
          useMemo: function (a, b) {
            var c = Th();
            return (
              (b = void 0 === b ? null : b),
              (a = a()),
              (c.memoizedState = [a, b]),
              a
            );
          },
          useReducer: function (a, b, c) {
            var d = Th();
            return (
              (b = void 0 !== c ? c(b) : b),
              (d.memoizedState = d.baseState = b),
              (a = (d.queue = a =
                {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: a,
                  lastRenderedState: b,
                }).dispatch =
                function xi(a, b, c) {
                  var d = yi(a);
                  (c = {
                    lane: d,
                    action: c,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null,
                  }),
                    zi(a)
                      ? Ai(b, c)
                      : null !== (c = hh(a, b, c, d)) &&
                        (gi(c, a, d, R()), Bi(c, b, d));
                }.bind(null, M, a)),
              [d.memoizedState, a]
            );
          },
          useRef: function (a) {
            return (Th().memoizedState = a = { current: a });
          },
          useState: hi,
          useDebugValue: ri,
          useDeferredValue: function (a) {
            return (Th().memoizedState = a);
          },
          useTransition: function () {
            var b = (a = hi(!1))[0],
              a = function vi(a, b) {
                var c = C,
                  d = ((C = 0 !== c && c < 4 ? c : 4), a(!0), Gh.transition);
                Gh.transition = {};
                try {
                  a(!1), b();
                } finally {
                  (C = c), (Gh.transition = d);
                }
              }.bind(null, a[1]);
            return [b, (Th().memoizedState = a)];
          },
          useMutableSource: function () {},
          useSyncExternalStore: function (a, b, c) {
            var d = M,
              e = Th();
            if (I) {
              if (void 0 === c) throw Error(p(407));
              c = c();
            } else {
              if (((c = b()), null === Q)) throw Error(p(349));
              0 == (30 & Hh) && di(d, b, c);
            }
            var f = { value: (e.memoizedState = c), getSnapshot: b };
            return (
              (e.queue = f),
              mi(ai.bind(null, d, f, a), [a]),
              (d.flags |= 2048),
              bi(9, ci.bind(null, d, f, c, b), void 0, null),
              c
            );
          },
          useId: function () {
            var c,
              a = Th(),
              b = Q.identifierPrefix;
            return (
              I
                ? ((c = sg),
                  (b =
                    ":" +
                    b +
                    "R" +
                    (c = (rg & ~(1 << (32 - oc(rg) - 1))).toString(32) + c)),
                  0 < (c = Kh++) && (b += "H" + c.toString(32)),
                  (b += ":"))
                : (b = ":" + b + "r" + (c = Lh++).toString(32) + ":"),
              (a.memoizedState = b)
            );
          },
          unstable_isNewReconciler: !1,
        },
        Ph = {
          readContext: eh,
          useCallback: si,
          useContext: eh,
          useEffect: $h,
          useImperativeHandle: qi,
          useInsertionEffect: ni,
          useLayoutEffect: oi,
          useMemo: ti,
          useReducer: Wh,
          useRef: ji,
          useState: function () {
            return Wh(Vh);
          },
          useDebugValue: ri,
          useDeferredValue: function (a) {
            return ui(Uh(), N.memoizedState, a);
          },
          useTransition: function () {
            return [Wh(Vh)[0], Uh().memoizedState];
          },
          useMutableSource: Yh,
          useSyncExternalStore: Zh,
          useId: wi,
          unstable_isNewReconciler: !1,
        },
        Qh = {
          readContext: eh,
          useCallback: si,
          useContext: eh,
          useEffect: $h,
          useImperativeHandle: qi,
          useInsertionEffect: ni,
          useLayoutEffect: oi,
          useMemo: ti,
          useReducer: Xh,
          useRef: ji,
          useState: function () {
            return Xh(Vh);
          },
          useDebugValue: ri,
          useDeferredValue: function (a) {
            var b = Uh();
            return null === N
              ? (b.memoizedState = a)
              : ui(b, N.memoizedState, a);
          },
          useTransition: function () {
            return [Xh(Vh)[0], Uh().memoizedState];
          },
          useMutableSource: Yh,
          useSyncExternalStore: Zh,
          useId: wi,
          unstable_isNewReconciler: !1,
        };
      function Ci(a, b) {
        if (a && a.defaultProps)
          for (var c in ((b = A({}, b)), (a = a.defaultProps)))
            void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      function Di(a, b, c, d) {
        (c = null == (c = c(d, (b = a.memoizedState))) ? b : A({}, b, c)),
          (a.memoizedState = c),
          0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = {
        isMounted: function (a) {
          return !!(a = a._reactInternals) && Vb(a) === a;
        },
        enqueueSetState: function (a, b, c) {
          a = a._reactInternals;
          var d = R(),
            e = yi(a),
            f = mh(d, e);
          (f.payload = b),
            null != c && (f.callback = c),
            null !== (b = nh(a, f, e)) && (gi(b, a, e, d), oh(b, a, e));
        },
        enqueueReplaceState: function (a, b, c) {
          a = a._reactInternals;
          var d = R(),
            e = yi(a),
            f = mh(d, e);
          (f.tag = 1),
            (f.payload = b),
            null != c && (f.callback = c),
            null !== (b = nh(a, f, e)) && (gi(b, a, e, d), oh(b, a, e));
        },
        enqueueForceUpdate: function (a, b) {
          a = a._reactInternals;
          var c = R(),
            d = yi(a),
            e = mh(c, d);
          (e.tag = 2),
            null != b && (e.callback = b),
            null !== (b = nh(a, e, d)) && (gi(b, a, d, c), oh(b, a, d));
        },
      };
      function Fi(a, b, c, d, e, f, g) {
        return "function" == typeof (a = a.stateNode).shouldComponentUpdate
          ? a.shouldComponentUpdate(d, f, g)
          : !(
              b.prototype &&
              b.prototype.isPureReactComponent &&
              Ie(c, d) &&
              Ie(e, f)
            );
      }
      function Gi(a, b, c) {
        var d = !1,
          e = Vf,
          f = b.contextType;
        (b = new b(
          c,
          (f =
            "object" == typeof f && null !== f
              ? eh(f)
              : ((e = Zf(b) ? Xf : H.current),
                (d = null != (d = b.contextTypes)) ? Yf(a, e) : Vf))
        )),
          (a.memoizedState =
            null !== b.state && void 0 !== b.state ? b.state : null),
          (b.updater = Ei),
          ((a.stateNode = b)._reactInternals = a),
          d &&
            (((a = a.stateNode).__reactInternalMemoizedUnmaskedChildContext =
              e),
            (a.__reactInternalMemoizedMaskedChildContext = f));
      }
      function Hi(a, b, c, d) {
        (a = b.state),
          "function" == typeof b.componentWillReceiveProps &&
            b.componentWillReceiveProps(c, d),
          "function" == typeof b.UNSAFE_componentWillReceiveProps &&
            b.UNSAFE_componentWillReceiveProps(c, d),
          b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode,
          f =
            ((e.props = c),
            (e.state = a.memoizedState),
            (e.refs = {}),
            kh(a),
            b.contextType);
        "object" == typeof f && null !== f
          ? (e.context = eh(f))
          : ((f = Zf(b) ? Xf : H.current), (e.context = Yf(a, f))),
          (e.state = a.memoizedState),
          "function" == typeof (f = b.getDerivedStateFromProps) &&
            (Di(a, 0, f, c), (e.state = a.memoizedState)),
          "function" == typeof b.getDerivedStateFromProps ||
            "function" == typeof e.getSnapshotBeforeUpdate ||
            ("function" != typeof e.UNSAFE_componentWillMount &&
              "function" != typeof e.componentWillMount) ||
            ((b = e.state),
            "function" == typeof e.componentWillMount && e.componentWillMount(),
            "function" == typeof e.UNSAFE_componentWillMount &&
              e.UNSAFE_componentWillMount(),
            b !== e.state && Ei.enqueueReplaceState(e, e.state, null),
            qh(a, c, e, d),
            (e.state = a.memoizedState)),
          "function" == typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          for (
            var c = "", d = b;
            (c += (function Pa(a) {
              switch (a.tag) {
                case 5:
                  return Ma(a.type);
                case 16:
                  return Ma("Lazy");
                case 13:
                  return Ma("Suspense");
                case 19:
                  return Ma("SuspenseList");
                case 0:
                case 2:
                case 15:
                  return (a = Oa(a.type, !1));
                case 11:
                  return (a = Oa(a.type.render, !1));
                case 1:
                  return (a = Oa(a.type, !0));
                default:
                  return "";
              }
            })(d)),
              (d = d.return);

          );
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return {
          value: a,
          source: null,
          stack: null != c ? c : null,
          digest: null != b ? b : null,
        };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function () {
            throw c;
          });
        }
      }
      var Mi = "function" == typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        ((c = mh(-1, c)).tag = 3), (c.payload = { element: null });
        var d = b.value;
        return (
          (c.callback = function () {
            Oi || ((Oi = !0), (Pi = d)), Li(0, b);
          }),
          c
        );
      }
      function Qi(a, b, c) {
        (c = mh(-1, c)).tag = 3;
        var e,
          d = a.type.getDerivedStateFromError,
          a =
            ("function" == typeof d &&
              ((e = b.value),
              (c.payload = function () {
                return d(e);
              }),
              (c.callback = function () {
                Li(0, b);
              })),
            a.stateNode);
        return (
          null !== a &&
            "function" == typeof a.componentDidCatch &&
            (c.callback = function () {
              Li(0, b),
                "function" != typeof d &&
                  (null === Ri ? (Ri = new Set([this])) : Ri.add(this));
              var c = b.stack;
              this.componentDidCatch(b.value, {
                componentStack: null !== c ? c : "",
              });
            }),
          c
        );
      }
      function Si(a, b, c) {
        var e,
          d = a.pingCache;
        null === d
          ? ((d = a.pingCache = new Mi()), (e = new Set()), d.set(b, e))
          : void 0 === (e = d.get(b)) && ((e = new Set()), d.set(b, e)),
          e.has(c) ||
            (e.add(c),
            (a = function Ti(a, b, c) {
              var d = a.pingCache;
              null !== d && d.delete(b),
                (b = R()),
                (a.pingedLanes |= a.suspendedLanes & c),
                Q === a &&
                  (Z & c) === c &&
                  (4 === T ||
                  (3 === T && (130023424 & Z) === Z && B() - fk < 500)
                    ? Kk(a, 0)
                    : (rk |= c)),
                Dk(a, b);
            }.bind(null, a, b, c)),
            b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (
            (b = (b = 13 === a.tag)
              ? null === (b = a.memoizedState) || null !== b.dehydrated
              : b)
          )
            return a;
        } while (null !== (a = a.return));
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 == (1 & a.mode))
          return a === b
            ? (a.flags |= 65536)
            : ((a.flags |= 128),
              (c.flags |= 131072),
              (c.flags &= -52805),
              1 === c.tag &&
                (null === c.alternate
                  ? (c.tag = 17)
                  : (((b = mh(-1, 1)).tag = 2), nh(c, b, 1))),
              (c.lanes |= 1));
        (a.flags |= 65536), (a.lanes = e);
      }
      var Wi = aa.ReactCurrentOwner,
        dh = !1;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        return (
          ch(b, e),
          (d = Nh(a, b, c, d, f, e)),
          (c = Sh()),
          null === a || dh
            ? (I && c && vg(b), (b.flags |= 1), Xi(a, b, d, e), b.child)
            : ((b.updateQueue = a.updateQueue),
              (b.flags &= -2053),
              (a.lanes &= ~e),
              Zi(a, b, e))
        );
      }
      function $i(a, b, c, d, e) {
        var f;
        if (null === a)
          return "function" != typeof (f = c.type) ||
            aj(f) ||
            void 0 !== f.defaultProps ||
            null !== c.compare ||
            void 0 !== c.defaultProps
            ? (((a = Rg(c.type, null, d, b, b.mode, e)).ref = b.ref),
              ((a.return = b).child = a))
            : ((b.tag = 15), (b.type = f), bj(a, b, f, d, e));
        if (((f = a.child), 0 == (a.lanes & e))) {
          var g = f.memoizedProps;
          if ((c = null !== (c = c.compare) ? c : Ie)(g, d) && a.ref === b.ref)
            return Zi(a, b, e);
        }
        return (
          (b.flags |= 1),
          ((a = Pg(f, d)).ref = b.ref),
          ((a.return = b).child = a)
        );
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) {
            if (((dh = !1), (b.pendingProps = d = f), 0 == (a.lanes & e)))
              return (b.lanes = a.lanes), Zi(a, b, e);
            0 != (131072 & a.flags) && (dh = !0);
          }
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps,
          e = d.children,
          f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode)
          if (0 == (1 & b.mode))
            (b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null,
            }),
              G(ej, fj),
              (fj |= c);
          else {
            if (0 == (1073741824 & c))
              return (
                (a = null !== f ? f.baseLanes | c : c),
                (b.lanes = b.childLanes = 1073741824),
                (b.memoizedState = {
                  baseLanes: a,
                  cachePool: null,
                  transitions: null,
                }),
                (b.updateQueue = null),
                G(ej, fj),
                (fj |= a),
                null
              );
            (b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null,
            }),
              (d = null !== f ? f.baseLanes : c),
              G(ej, fj),
              (fj |= d);
          }
        else
          null !== f
            ? ((d = f.baseLanes | c), (b.memoizedState = null))
            : (d = c),
            G(ej, fj),
            (fj |= d);
        return Xi(a, b, e, c), b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        ((null === a && null !== c) || (null !== a && a.ref !== c)) &&
          ((b.flags |= 512), (b.flags |= 2097152));
      }
      function cj(a, b, c, d, e) {
        var f = Yf(b, Zf(c) ? Xf : H.current);
        return (
          ch(b, e),
          (c = Nh(a, b, c, d, f, e)),
          (d = Sh()),
          null === a || dh
            ? (I && d && vg(b), (b.flags |= 1), Xi(a, b, c, e), b.child)
            : ((b.updateQueue = a.updateQueue),
              (b.flags &= -2053),
              (a.lanes &= ~e),
              Zi(a, b, e))
        );
      }
      function hj(a, b, c, d, e) {
        var f, g, h, l, m, q, r, k, y, n;
        return (
          Zf(c) ? ((f = !0), cg(b)) : (f = !1),
          ch(b, e),
          (d =
            null === b.stateNode
              ? (ij(a, b), Gi(b, c, d), Ii(b, c, d, e), !0)
              : null === a
              ? ((g = b.stateNode),
                (h = b.memoizedProps),
                (g.props = h),
                (k = g.context),
                (l =
                  "object" == typeof (l = c.contextType) && null !== l
                    ? eh(l)
                    : Yf(b, (l = Zf(c) ? Xf : H.current))),
                (q =
                  "function" == typeof (m = c.getDerivedStateFromProps) ||
                  "function" == typeof g.getSnapshotBeforeUpdate) ||
                  ("function" != typeof g.UNSAFE_componentWillReceiveProps &&
                    "function" != typeof g.componentWillReceiveProps) ||
                  (h === d && k === l) ||
                  Hi(0, g, d, l),
                (jh = !1),
                (r = b.memoizedState),
                (g.state = r),
                qh(b, d, g, e),
                (k = b.memoizedState),
                h !== d || r !== k || Wf.current || jh
                  ? ("function" == typeof m &&
                      (Di(b, 0, m, d), (k = b.memoizedState)),
                    (h = jh || Fi(b, c, h, d, r, k, l))
                      ? (q ||
                          ("function" != typeof g.UNSAFE_componentWillMount &&
                            "function" != typeof g.componentWillMount) ||
                          ("function" == typeof g.componentWillMount &&
                            g.componentWillMount(),
                          "function" == typeof g.UNSAFE_componentWillMount &&
                            g.UNSAFE_componentWillMount()),
                        "function" == typeof g.componentDidMount &&
                          (b.flags |= 4194308))
                      : ("function" == typeof g.componentDidMount &&
                          (b.flags |= 4194308),
                        (b.memoizedProps = d),
                        (b.memoizedState = k)),
                    (g.props = d),
                    (g.state = k),
                    (g.context = l),
                    h)
                  : ("function" == typeof g.componentDidMount &&
                      (b.flags |= 4194308),
                    !1))
              : ((g = b.stateNode),
                lh(a, b),
                (h = b.memoizedProps),
                (l = b.type === b.elementType ? h : Ci(b.type, h)),
                (g.props = l),
                (q = b.pendingProps),
                (r = g.context),
                (k =
                  "object" == typeof (k = c.contextType) && null !== k
                    ? eh(k)
                    : Yf(b, (k = Zf(c) ? Xf : H.current))),
                (m =
                  "function" == typeof (y = c.getDerivedStateFromProps) ||
                  "function" == typeof g.getSnapshotBeforeUpdate) ||
                  ("function" != typeof g.UNSAFE_componentWillReceiveProps &&
                    "function" != typeof g.componentWillReceiveProps) ||
                  (h === q && r === k) ||
                  Hi(0, g, d, k),
                (jh = !1),
                (r = b.memoizedState),
                (g.state = r),
                qh(b, d, g, e),
                (n = b.memoizedState),
                h !== q || r !== n || Wf.current || jh
                  ? ("function" == typeof y &&
                      (Di(b, 0, y, d), (n = b.memoizedState)),
                    (l = jh || Fi(b, c, l, d, r, n, k) || !1)
                      ? (m ||
                          ("function" != typeof g.UNSAFE_componentWillUpdate &&
                            "function" != typeof g.componentWillUpdate) ||
                          ("function" == typeof g.componentWillUpdate &&
                            g.componentWillUpdate(d, n, k),
                          "function" == typeof g.UNSAFE_componentWillUpdate &&
                            g.UNSAFE_componentWillUpdate(d, n, k)),
                        "function" == typeof g.componentDidUpdate &&
                          (b.flags |= 4),
                        "function" == typeof g.getSnapshotBeforeUpdate &&
                          (b.flags |= 1024))
                      : ("function" != typeof g.componentDidUpdate ||
                          (h === a.memoizedProps && r === a.memoizedState) ||
                          (b.flags |= 4),
                        "function" != typeof g.getSnapshotBeforeUpdate ||
                          (h === a.memoizedProps && r === a.memoizedState) ||
                          (b.flags |= 1024),
                        (b.memoizedProps = d),
                        (b.memoizedState = n)),
                    (g.props = d),
                    (g.state = n),
                    (g.context = k),
                    l)
                  : ("function" != typeof g.componentDidUpdate ||
                      (h === a.memoizedProps && r === a.memoizedState) ||
                      (b.flags |= 4),
                    "function" != typeof g.getSnapshotBeforeUpdate ||
                      (h === a.memoizedProps && r === a.memoizedState) ||
                      (b.flags |= 1024),
                    !1))),
          jj(a, b, c, d, f, e)
        );
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 != (128 & b.flags);
        if (!d && !g) return e && dg(b, c, !1), Zi(a, b, f);
        (d = b.stateNode), (Wi.current = b);
        var h =
          g && "function" != typeof c.getDerivedStateFromError
            ? null
            : d.render();
        return (
          (b.flags |= 1),
          null !== a && g
            ? ((b.child = Ug(b, a.child, null, f)),
              (b.child = Ug(b, null, h, f)))
            : Xi(a, b, h, f),
          (b.memoizedState = d.state),
          e && dg(b, c, !0),
          b.child
        );
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext
          ? ag(0, b.pendingContext, b.pendingContext !== b.context)
          : b.context && ag(0, b.context, !1),
          yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        return Ig(), Jg(e), (b.flags |= 256), Xi(a, b, c, d), b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var h,
          k,
          d = b.pendingProps,
          e = L.current,
          f = !1,
          g = 0 != (128 & b.flags);
        return (
          (h =
            (h = g) ||
            ((null === a || null !== a.memoizedState) && 0 != (2 & e)))
            ? ((f = !0), (b.flags &= -129))
            : (null !== a && null === a.memoizedState) || (e |= 1),
          G(L, 1 & e),
          null === a
            ? (Eg(b),
              null !== (a = b.memoizedState) && null !== (a = a.dehydrated)
                ? (0 == (1 & b.mode)
                    ? (b.lanes = 1)
                    : "$!" === a.data
                    ? (b.lanes = 8)
                    : (b.lanes = 1073741824),
                  null)
                : ((g = d.children),
                  (a = d.fallback),
                  f
                    ? ((d = b.mode),
                      (f = b.child),
                      (g = { mode: "hidden", children: g }),
                      0 == (1 & d) && null !== f
                        ? ((f.childLanes = 0), (f.pendingProps = g))
                        : (f = pj(g, d, 0, null)),
                      (a = Tg(a, d, c, null)),
                      (f.return = b),
                      (a.return = b),
                      (f.sibling = a),
                      (b.child = f),
                      (b.child.memoizedState = nj(c)),
                      (b.memoizedState = mj),
                      a)
                    : qj(b, g)))
            : null !== (e = a.memoizedState) && null !== (h = e.dehydrated)
            ? (function rj(a, b, c, d, e, f, g) {
                if (c)
                  return 256 & b.flags
                    ? ((b.flags &= -257),
                      (d = Ki(Error(p(422)))),
                      sj(a, b, g, d))
                    : null !== b.memoizedState
                    ? ((b.child = a.child), (b.flags |= 128), null)
                    : ((f = d.fallback),
                      (e = b.mode),
                      (d = pj(
                        { mode: "visible", children: d.children },
                        e,
                        0,
                        null
                      )),
                      ((f = Tg(f, e, g, null)).flags |= 2),
                      (d.return = b),
                      (f.return = b),
                      (d.sibling = f),
                      (b.child = d),
                      0 != (1 & b.mode) && Ug(b, a.child, null, g),
                      (b.child.memoizedState = nj(g)),
                      (b.memoizedState = mj),
                      f);
                if (0 == (1 & b.mode)) return sj(a, b, g, null);
                {
                  var h;
                  if ("$!" === e.data)
                    return (
                      (d = h =
                        (d = e.nextSibling && e.nextSibling.dataset)
                          ? d.dgst
                          : h),
                      (f = Error(p(419))),
                      (d = Ki(f, d, void 0)),
                      sj(a, b, g, d)
                    );
                }
                if (((h = 0 != (g & a.childLanes)), dh || h)) {
                  if (null !== (d = Q)) {
                    switch (g & -g) {
                      case 4:
                        e = 2;
                        break;
                      case 16:
                        e = 8;
                        break;
                      case 64:
                      case 128:
                      case 256:
                      case 512:
                      case 1024:
                      case 2048:
                      case 4096:
                      case 8192:
                      case 16384:
                      case 32768:
                      case 65536:
                      case 131072:
                      case 262144:
                      case 524288:
                      case 1048576:
                      case 2097152:
                      case 4194304:
                      case 8388608:
                      case 16777216:
                      case 33554432:
                      case 67108864:
                        e = 32;
                        break;
                      case 536870912:
                        e = 268435456;
                        break;
                      default:
                        e = 0;
                    }
                    0 !== (e = 0 != (e & (d.suspendedLanes | g)) ? 0 : e) &&
                      e !== f.retryLane &&
                      ((f.retryLane = e), ih(a, e), gi(d, a, e, -1));
                  }
                  return tj(), (d = Ki(Error(p(421)))), sj(a, b, g, d);
                }
                return "$?" === e.data
                  ? ((b.flags |= 128),
                    (b.child = a.child),
                    (b = function uj(a) {
                      var b = a.memoizedState,
                        c = 0;
                      null !== b && (c = b.retryLane), Yk(a, c);
                    }.bind(null, a)),
                    (e._reactRetry = b),
                    null)
                  : ((a = f.treeContext),
                    (yg = Lf(e.nextSibling)),
                    (xg = b),
                    (I = !0),
                    (zg = null) !== a &&
                      ((og[pg++] = rg),
                      (og[pg++] = sg),
                      (og[pg++] = qg),
                      (rg = a.id),
                      (sg = a.overflow),
                      (qg = b)),
                    ((b = qj(b, d.children)).flags |= 4096),
                    b);
              })(a, b, g, d, h, e, c)
            : (f
                ? ((f = d.fallback),
                  (g = b.mode),
                  (h = (e = a.child).sibling),
                  (k = { mode: "hidden", children: d.children }),
                  0 == (1 & g) && b.child !== e
                    ? (((d = b.child).childLanes = 0),
                      (d.pendingProps = k),
                      (b.deletions = null))
                    : ((d = Pg(e, k)).subtreeFlags = 14680064 & e.subtreeFlags),
                  null !== h
                    ? (f = Pg(h, f))
                    : ((f = Tg(f, g, c, null)).flags |= 2),
                  (f.return = b),
                  (d.return = b),
                  (d.sibling = f),
                  (b.child = d),
                  (d = f),
                  (f = b.child),
                  (g =
                    null === (g = a.child.memoizedState)
                      ? nj(c)
                      : {
                          baseLanes: g.baseLanes | c,
                          cachePool: null,
                          transitions: g.transitions,
                        }),
                  (f.memoizedState = g),
                  (f.childLanes = a.childLanes & ~c),
                  (b.memoizedState = mj))
                : ((a = (f = a.child).sibling),
                  (d = Pg(f, { mode: "visible", children: d.children })),
                  0 == (1 & b.mode) && (d.lanes = c),
                  (d.return = b),
                  (d.sibling = null) !== a &&
                    (null === (c = b.deletions)
                      ? ((b.deletions = [a]), (b.flags |= 16))
                      : c.push(a)),
                  (b.child = d),
                  (b.memoizedState = null)),
              d)
        );
      }
      function qj(a, b) {
        return (((b = pj(
          { mode: "visible", children: b },
          a.mode,
          0,
          null
        )).return = a).child = b);
      }
      function sj(a, b, c, d) {
        return (
          null !== d && Jg(d),
          Ug(b, a.child, null, c),
          ((a = qj(b, b.pendingProps.children)).flags |= 2),
          (b.memoizedState = null),
          a
        );
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b), bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f
          ? (a.memoizedState = {
              isBackwards: b,
              rendering: null,
              renderingStartTime: 0,
              last: d,
              tail: c,
              tailMode: e,
            })
          : ((f.isBackwards = b),
            (f.rendering = null),
            (f.renderingStartTime = 0),
            (f.last = d),
            (f.tail = c),
            (f.tailMode = e));
      }
      function xj(a, b, c) {
        var d = b.pendingProps,
          e = d.revealOrder,
          f = d.tail;
        if ((Xi(a, b, d.children, c), 0 != (2 & (d = L.current))))
          (d = (1 & d) | 2), (b.flags |= 128);
        else {
          if (null !== a && 0 != (128 & a.flags))
            a: for (a = b.child; null !== a; ) {
              if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
              else if (19 === a.tag) vj(a, c, b);
              else if (null !== a.child) {
                a = (a.child.return = a).child;
                continue;
              }
              if (a === b) break;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b) break a;
                a = a.return;
              }
              (a.sibling.return = a.return), (a = a.sibling);
            }
          d &= 1;
        }
        if ((G(L, d), 0 == (1 & b.mode))) b.memoizedState = null;
        else
          switch (e) {
            case "forwards":
              for (c = b.child, e = null; null !== c; )
                null !== (a = c.alternate) && null === Ch(a) && (e = c),
                  (c = c.sibling);
              null === (c = e)
                ? ((e = b.child), (b.child = null))
                : ((e = c.sibling), (c.sibling = null)),
                wj(b, !1, e, c, f);
              break;
            case "backwards":
              for (e = b.child, b.child = c = null; null !== e; ) {
                if (null !== (a = e.alternate) && null === Ch(a)) {
                  b.child = e;
                  break;
                }
                (a = e.sibling), (e.sibling = c), (c = e), (e = a);
              }
              wj(b, !0, c, null, f);
              break;
            case "together":
              wj(b, !1, null, null, void 0);
              break;
            default:
              b.memoizedState = null;
          }
        return b.child;
      }
      function ij(a, b) {
        0 == (1 & b.mode) &&
          null !== a &&
          ((a.alternate = null), (b.alternate = null), (b.flags |= 2));
      }
      function Zi(a, b, c) {
        if (
          (null !== a && (b.dependencies = a.dependencies),
          (rh |= b.lanes),
          0 == (c & b.childLanes))
        )
          return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          for (
            c = Pg((a = b.child), a.pendingProps), (b.child = c).return = b;
            null !== a.sibling;

          )
            (a = a.sibling),
              ((c = c.sibling = Pg(a, a.pendingProps)).return = b);
          c.sibling = null;
        }
        return b.child;
      }
      function Dj(a, b) {
        if (!I)
          switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b; )
                null !== b.alternate && (c = b), (b = b.sibling);
              null === c ? (a.tail = null) : (c.sibling = null);
              break;
            case "collapsed":
              for (var c = a.tail, d = null; null !== c; )
                null !== c.alternate && (d = c), (c = c.sibling);
              null === d
                ? b || null === a.tail
                  ? (a.tail = null)
                  : (a.tail.sibling = null)
                : (d.sibling = null);
          }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child,
          c = 0,
          d = 0;
        if (b)
          for (var e = a.child; null !== e; )
            (c |= e.lanes | e.childLanes),
              (d = (d |= 14680064 & e.subtreeFlags) | (14680064 & e.flags)),
              (e.return = a),
              (e = e.sibling);
        else
          for (e = a.child; null !== e; )
            (c |= e.lanes | e.childLanes),
              (d = (d |= e.subtreeFlags) | e.flags),
              (e.return = a),
              (e = e.sibling);
        (a.subtreeFlags |= d), (a.childLanes = c);
      }
      var zj = function (a, b) {
          for (var c = b.child; null !== c; ) {
            if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
            else if (4 !== c.tag && null !== c.child) {
              c = (c.child.return = c).child;
              continue;
            }
            if (c === b) break;
            for (; null === c.sibling; ) {
              if (null === c.return || c.return === b) return;
              c = c.return;
            }
            (c.sibling.return = c.return), (c = c.sibling);
          }
        },
        Bj = function (a, b, c, d) {
          var e = a.memoizedProps;
          if (e !== d) {
            (a = b.stateNode), xh(uh.current);
            var g,
              f = null;
            switch (c) {
              case "input":
                (e = Ya(a, e)), (d = Ya(a, d)), (f = []);
                break;
              case "select":
                (e = A({}, e, { value: void 0 })),
                  (d = A({}, d, { value: void 0 })),
                  (f = []);
                break;
              case "textarea":
                (e = gb(a, e)), (d = gb(a, d)), (f = []);
                break;
              default:
                "function" != typeof e.onClick &&
                  "function" == typeof d.onClick &&
                  (a.onclick = Bf);
            }
            for (l in (ub(c, d), (c = null), e))
              if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
                if ("style" === l) {
                  var h = e[l];
                  for (g in h)
                    h.hasOwnProperty(g) && ((c = c || {}), (c[g] = ""));
                } else
                  "dangerouslySetInnerHTML" !== l &&
                    "children" !== l &&
                    "suppressContentEditableWarning" !== l &&
                    "suppressHydrationWarning" !== l &&
                    "autoFocus" !== l &&
                    (ea.hasOwnProperty(l)
                      ? (f = f || [])
                      : (f = f || []).push(l, null));
            for (l in d) {
              var k = d[l],
                h = null != e ? e[l] : void 0;
              if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
                if ("style" === l)
                  if (h) {
                    for (g in h)
                      !h.hasOwnProperty(g) ||
                        (k && k.hasOwnProperty(g)) ||
                        ((c = c || {}), (c[g] = ""));
                    for (g in k)
                      k.hasOwnProperty(g) &&
                        h[g] !== k[g] &&
                        ((c = c || {}), (c[g] = k[g]));
                  } else c || (f = f || []).push(l, c), (c = k);
                else
                  "dangerouslySetInnerHTML" === l
                    ? ((k = k ? k.__html : void 0),
                      (h = h ? h.__html : void 0),
                      null != k && h !== k && (f = f || []).push(l, k))
                    : "children" === l
                    ? ("string" != typeof k && "number" != typeof k) ||
                      (f = f || []).push(l, "" + k)
                    : "suppressContentEditableWarning" !== l &&
                      "suppressHydrationWarning" !== l &&
                      (ea.hasOwnProperty(l)
                        ? (null != k && "onScroll" === l && D("scroll", a),
                          f || h === k || (f = []))
                        : (f = f || []).push(l, k));
            }
            c && (f = f || []).push("style", c);
            var l = f;
            (b.updateQueue = l) && (b.flags |= 4);
          }
        },
        Cj = function (a, b, c, d) {
          c !== d && (b.flags |= 4);
        },
        Jj = !1,
        U = !1,
        Kj = "function" == typeof WeakSet ? WeakSet : Set,
        V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c)
          if ("function" == typeof c)
            try {
              c(null);
            } catch (d) {
              W(a, b, d);
            }
          else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = !1;
      function Pj(a, b, c) {
        var d = b.updateQueue;
        if (null !== (d = null !== d ? d.lastEffect : null)) {
          var f,
            e = (d = d.next);
          do {} while (
            ((e.tag & a) === a &&
              ((f = e.destroy), (e.destroy = void 0) !== f) &&
              Mj(b, c, f),
            (e = e.next) !== d)
          );
        }
      }
      function Qj(a, b) {
        if (null !== (b = null !== (b = b.updateQueue) ? b.lastEffect : null)) {
          var d,
            c = (b = b.next);
          do {} while (
            ((c.tag & a) === a && ((d = c.create), (c.destroy = d())),
            (c = c.next) !== b)
          );
        }
      }
      function Rj(a) {
        var c,
          b = a.ref;
        null !== b &&
          ((c = a.stateNode),
          a.tag,
          (a = c),
          "function" == typeof b ? b(a) : (b.current = a));
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (;;) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          for (
            a.sibling.return = a.return, a = a.sibling;
            5 !== a.tag && 6 !== a.tag && 18 !== a.tag;

          ) {
            if (2 & a.flags) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            a = (a.child.return = a).child;
          }
          if (!(2 & a.flags)) return a.stateNode;
        }
      }
      var X = null,
        Xj = !1;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), (c = c.sibling);
      }
      function Zj(a, b, c) {
        if (lc && "function" == typeof lc.onCommitFiberUnmount)
          try {
            lc.onCommitFiberUnmount(kc, c);
          } catch (h) {}
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X,
              e = Xj;
            (X = null),
              Yj(a, b, c),
              (Xj = e),
              null !== (X = d) &&
                (Xj
                  ? ((a = X),
                    (c = c.stateNode),
                    (8 === a.nodeType ? a.parentNode : a).removeChild(c))
                  : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X &&
              (Xj
                ? ((a = X),
                  (c = c.stateNode),
                  8 === a.nodeType
                    ? Kf(a.parentNode, c)
                    : 1 === a.nodeType && Kf(a, c),
                  bd(a))
                : Kf(X, c.stateNode));
            break;
          case 4:
            (d = X),
              (e = Xj),
              (X = c.stateNode.containerInfo),
              (Xj = !0),
              Yj(a, b, c),
              (X = d),
              (Xj = e);
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (
              !U &&
              null !== (d = c.updateQueue) &&
              null !== (d = d.lastEffect)
            ) {
              e = d = d.next;
              do {
                var g = e.destroy,
                  f = e.tag;
              } while (
                (void 0 === g || (0 == (2 & f) && 0 == (4 & f)) || Mj(c, b, g),
                (e = e.next) !== d)
              );
            }
            Yj(a, b, c);
            break;
          case 1:
            if (
              !U &&
              (Lj(c, b),
              "function" == typeof (d = c.stateNode).componentWillUnmount)
            )
              try {
                (d.props = c.memoizedProps),
                  (d.state = c.memoizedState),
                  d.componentWillUnmount();
              } catch (h) {
                W(c, b, h);
              }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            1 & c.mode
              ? ((U = (d = U) || null !== c.memoizedState),
                Yj(a, b, c),
                (U = d))
              : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var c,
          b = a.updateQueue;
        null !== b &&
          ((a.updateQueue = null) === (c = a.stateNode) &&
            (c = a.stateNode = new Kj()),
          b.forEach(function (b) {
            var d = function bk(a, b) {
              var c = 0;
              switch (a.tag) {
                case 13:
                  var d = a.stateNode,
                    e = a.memoizedState;
                  null !== e && (c = e.retryLane);
                  break;
                case 19:
                  d = a.stateNode;
                  break;
                default:
                  throw Error(p(314));
              }
              null !== d && d.delete(b), Yk(a, c);
            }.bind(null, a, b);
            c.has(b) || (c.add(b), b.then(d, d));
          }));
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c)
          for (var d = 0; d < c.length; d++) {
            var e = c[d];
            try {
              var f = a,
                g = b,
                h = g;
              a: for (; null !== h; ) {
                switch (h.tag) {
                  case 5:
                    (X = h.stateNode), (Xj = !1);
                    break a;
                  case 3:
                  case 4:
                    (X = h.stateNode.containerInfo), (Xj = !0);
                    break a;
                }
                h = h.return;
              }
              if (null === X) throw Error(p(160));
              Zj(f, g, e), (X = null), (Xj = !1);
              var k = e.alternate;
              null !== k && (k.return = null), (e.return = null);
            } catch (l) {
              W(e, b, l);
            }
          }
        if (12854 & b.subtreeFlags)
          for (b = b.child; null !== b; ) dk(b, a), (b = b.sibling);
      }
      function dk(a, b) {
        var c = a.alternate,
          d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            if ((ck(b, a), ek(a), 4 & d)) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a), ek(a), 512 & d && null !== c && Lj(c, c.return);
            break;
          case 5:
            if (
              (ck(b, a),
              ek(a),
              512 & d && null !== c && Lj(c, c.return),
              32 & a.flags)
            ) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (4 & d && null != (e = a.stateNode)) {
              var f = a.memoizedProps,
                g = null !== c ? c.memoizedProps : f,
                h = a.type,
                k = a.updateQueue;
              if ((a.updateQueue = null) !== k)
                try {
                  "input" === h &&
                    "radio" === f.type &&
                    null != f.name &&
                    ab(e, f),
                    vb(h, g);
                  for (var l = vb(h, f), g = 0; g < k.length; g += 2) {
                    var m = k[g],
                      q = k[g + 1];
                    "style" === m
                      ? sb(e, q)
                      : "dangerouslySetInnerHTML" === m
                      ? nb(e, q)
                      : "children" === m
                      ? ob(e, q)
                      : ta(e, m, q, l);
                  }
                  switch (h) {
                    case "input":
                      bb(e, f);
                      break;
                    case "textarea":
                      ib(e, f);
                      break;
                    case "select":
                      var r = e._wrapperState.wasMultiple,
                        y =
                          ((e._wrapperState.wasMultiple = !!f.multiple),
                          f.value);
                      null != y
                        ? fb(e, !!f.multiple, y, !1)
                        : r !== !!f.multiple &&
                          (null != f.defaultValue
                            ? fb(e, !!f.multiple, f.defaultValue, !0)
                            : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                  }
                  e[Pf] = f;
                } catch (t) {
                  W(a, a.return, t);
                }
            }
            break;
          case 6:
            if ((ck(b, a), ek(a), 4 & d)) {
              if (null === a.stateNode) throw Error(p(162));
              (e = a.stateNode), (f = a.memoizedProps);
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            if (
              (ck(b, a),
              ek(a),
              4 & d && null !== c && c.memoizedState.isDehydrated)
            )
              try {
                bd(b.containerInfo);
              } catch (t) {
                W(a, a.return, t);
              }
            break;
          case 4:
            ck(b, a), ek(a);
            break;
          case 13:
            ck(b, a),
              ek(a),
              8192 & (e = a.child).flags &&
                ((f = null !== e.memoizedState),
                !(e.stateNode.isHidden = f) ||
                  (null !== e.alternate &&
                    null !== e.alternate.memoizedState) ||
                  (fk = B())),
              4 & d && ak(a);
            break;
          case 22:
            if (
              ((m = null !== c && null !== c.memoizedState),
              1 & a.mode ? ((U = (l = U) || m), ck(b, a), (U = l)) : ck(b, a),
              ek(a),
              8192 & d)
            ) {
              if (
                ((l = null !== a.memoizedState),
                (a.stateNode.isHidden = l) && !m && 0 != (1 & a.mode))
              )
                for (m = (V = a).child; null !== m; ) {
                  for (q = V = m; null !== V; ) {
                    switch (((y = (r = V).child), r.tag)) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Pj(4, r, r.return);
                        break;
                      case 1:
                        Lj(r, r.return);
                        var n = r.stateNode;
                        if ("function" == typeof n.componentWillUnmount) {
                          c = (d = r).return;
                          try {
                            (b = d),
                              (n.props = b.memoizedProps),
                              (n.state = b.memoizedState),
                              n.componentWillUnmount();
                          } catch (t) {
                            W(d, c, t);
                          }
                        }
                        break;
                      case 5:
                        Lj(r, r.return);
                        break;
                      case 22:
                        if (null !== r.memoizedState) {
                          gk(q);
                          continue;
                        }
                    }
                    null !== y ? ((y.return = r), (V = y)) : gk(q);
                  }
                  m = m.sibling;
                }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      (e = q.stateNode),
                        l
                          ? "function" == typeof (f = e.style).setProperty
                            ? f.setProperty("display", "none", "important")
                            : (f.display = "none")
                          : ((h = q.stateNode),
                            (g =
                              null != (k = q.memoizedProps.style) &&
                              k.hasOwnProperty("display")
                                ? k.display
                                : null),
                            (h.style.display = rb("display", g)));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m)
                    try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                } else if (
                  ((22 !== q.tag && 23 !== q.tag) ||
                    null === q.memoizedState ||
                    q === a) &&
                  null !== q.child
                ) {
                  q = (q.child.return = q).child;
                  continue;
                }
                if (q === a) break;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null), (q = q.return);
                }
                m === q && (m = null),
                  (q.sibling.return = q.return),
                  (q = q.sibling);
              }
            }
            break;
          case 19:
            ck(b, a), ek(a), 4 & d && ak(a);
            break;
          case 21:
            break;
          default:
            ck(b, a), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (2 & b) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                32 & d.flags && (ob(e, ""), (d.flags &= -33)),
                  !(function Wj(a, b, c) {
                    var d = a.tag;
                    if (5 === d || 6 === d)
                      (a = a.stateNode),
                        b ? c.insertBefore(a, b) : c.appendChild(a);
                    else if (4 !== d && null !== (a = a.child))
                      for (Wj(a, b, c), a = a.sibling; null !== a; )
                        Wj(a, b, c), (a = a.sibling);
                  })(a, Uj(a), e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo;
                !(function Vj(a, b, c) {
                  var d = a.tag;
                  if (5 === d || 6 === d)
                    (a = a.stateNode),
                      b
                        ? (8 === c.nodeType ? c.parentNode : c).insertBefore(
                            a,
                            b
                          )
                        : (8 === c.nodeType
                            ? (b = c.parentNode).insertBefore(a, c)
                            : (b = c).appendChild(a),
                          null == (c = c._reactRootContainer) &&
                            null === b.onclick &&
                            (b.onclick = Bf));
                  else if (4 !== d && null !== (a = a.child))
                    for (Vj(a, b, c), a = a.sibling; null !== a; )
                      Vj(a, b, c), (a = a.sibling);
                })(a, Uj(a), g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        4096 & b && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        !(function ik(a, b, c) {
          for (var d = 0 != (1 & a.mode); null !== V; ) {
            var e = V,
              f = e.child;
            if (22 === e.tag && d) {
              var g = null !== e.memoizedState || Jj;
              if (!g) {
                var h = e.alternate,
                  k = (null !== h && null !== h.memoizedState) || U,
                  l = ((h = Jj), U);
                if (((Jj = g), (U = k) && !l))
                  for (V = e; null !== V; )
                    (k = (g = V).child),
                      (22 !== g.tag || null === g.memoizedState) && null !== k
                        ? ((k.return = g), (V = k))
                        : jk(e);
                for (; null !== f; ) ik((V = f), b, c), (f = f.sibling);
                (V = e), (Jj = h), (U = l);
              }
              kk(a);
            } else
              0 != (8772 & e.subtreeFlags) && null !== f
                ? ((f.return = e), (V = f))
                : kk(a);
          }
        })((V = a), b, c);
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 != (8772 & b.flags)) {
            var l,
              m,
              q,
              c = b.alternate;
            try {
              if (0 != (8772 & b.flags))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U || Qj(5, b);
                    break;
                  case 1:
                    var e,
                      d = b.stateNode,
                      f =
                        (4 & b.flags &&
                          !U &&
                          (null === c
                            ? d.componentDidMount()
                            : ((e =
                                b.elementType === b.type
                                  ? c.memoizedProps
                                  : Ci(b.type, c.memoizedProps)),
                              d.componentDidUpdate(
                                e,
                                c.memoizedState,
                                d.__reactInternalSnapshotBeforeUpdate
                              ))),
                        b.updateQueue);
                    null !== f && sh(0, f, d);
                    break;
                  case 3:
                    var g = b.updateQueue;
                    if (null !== g) {
                      if ((c = null) !== b.child)
                        switch (b.child.tag) {
                          case 5:
                          case 1:
                            c = b.child.stateNode;
                        }
                      sh(0, g, c);
                    }
                    break;
                  case 5:
                    var h = b.stateNode;
                    if (null === c && 4 & b.flags) {
                      var c = h,
                        k = b.memoizedProps;
                      switch (b.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k.autoFocus && c.focus();
                          break;
                        case "img":
                          k.src && (c.src = k.src);
                      }
                    }
                    break;
                  case 6:
                  case 4:
                  case 12:
                    break;
                  case 13:
                    null === b.memoizedState &&
                      null !== (l = b.alternate) &&
                      null !== (m = l.memoizedState) &&
                      null !== (q = m.dehydrated) &&
                      bd(q);
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p(163));
                }
              U || (512 & b.flags && Rj(b));
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          if (null !== (c = b.sibling)) {
            (c.return = b.return), (V = c);
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            (c.return = b.return), (V = c);
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" == typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            (h.return = b.return), (V = h);
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil,
        mk = aa.ReactCurrentDispatcher,
        nk = aa.ReactCurrentOwner,
        ok = aa.ReactCurrentBatchConfig,
        K = 0,
        Q = null,
        Y = null,
        Z = 0,
        fj = 0,
        ej = Uf(0),
        T = 0,
        pk = null,
        rh = 0,
        qk = 0,
        rk = 0,
        sk = null,
        tk = null,
        fk = 0,
        Gj = 1 / 0,
        uk = null,
        Oi = !1,
        Pi = null,
        Ri = null,
        vk = !1,
        wk = null,
        xk = 0,
        yk = 0,
        zk = null,
        Ak = -1,
        Bk = 0;
      function R() {
        return 0 != (6 & K) ? B() : -1 !== Ak ? Ak : (Ak = B());
      }
      function yi(a) {
        return 0 == (1 & a.mode)
          ? 1
          : 0 != (2 & K) && 0 !== Z
          ? Z & -Z
          : null !== Kg.transition
          ? (Bk = 0 === Bk ? yc() : Bk)
          : 0 === (a = C)
          ? void 0 === (a = window.event)
            ? 16
            : jd(a.type)
          : a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw ((yk = 0), (zk = null), Error(p(185)));
        Ac(a, c, d),
          (0 != (2 & K) && a === Q) ||
            (a === Q && (0 == (2 & K) && (qk |= c), 4 === T) && Ck(a, Z),
            Dk(a, d),
            1 === c &&
              0 === K &&
              0 == (1 & b.mode) &&
              ((Gj = B() + 500), fg) &&
              jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode,
          d =
            (!(function wc(a, b) {
              for (
                var c = a.suspendedLanes,
                  d = a.pingedLanes,
                  e = a.expirationTimes,
                  f = a.pendingLanes;
                0 < f;

              ) {
                var g = 31 - oc(f),
                  h = 1 << g,
                  k = e[g];
                -1 === k
                  ? (0 != (h & c) && 0 == (h & d)) ||
                    (e[g] = (function vc(a, b) {
                      switch (a) {
                        case 1:
                        case 2:
                        case 4:
                          return b + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                          return b + 5e3;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                          return -1;
                        default:
                          return -1;
                      }
                    })(h, b))
                  : k <= b && (a.expiredLanes |= h),
                  (f &= ~h);
              }
            })(a, b),
            uc(a, a === Q ? Z : 0));
        if (0 === d)
          null !== c && bc(c),
            (a.callbackNode = null),
            (a.callbackPriority = 0);
        else if (a.callbackPriority !== (b = d & -d)) {
          if ((null != c && bc(c), 1 === b))
            (0 === a.tag
              ? function ig(a) {
                  (fg = !0), hg(a);
                }
              : hg)(Ek.bind(null, a)),
              Jf(function () {
                0 == (6 & K) && jg();
              }),
              (c = null);
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          (a.callbackPriority = b), (a.callbackNode = c);
        }
      }
      function Gk(a, b) {
        if (((Ak = -1), (Bk = 0) != (6 & K))) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 != (30 & d) || 0 != (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K,
            f = ((K |= 2), Jk());
          for (
            (Q === a && Z === b) || ((uk = null), (Gj = B() + 500), Kk(a, b));
            ;

          )
            try {
              !(function Lk() {
                for (; null !== Y && !cc(); ) Uk(Y);
              })();
              break;
            } catch (h) {
              Mk(a, h);
            }
          $g(),
            (mk.current = f),
            (K = e),
            (b = null !== Y ? 0 : ((Q = null), (Z = 0), T));
        }
        if (0 !== b) {
          if (1 === (b = 2 === b && 0 !== (e = xc(a)) ? Nk(a, (d = e)) : b))
            throw ((c = pk), Kk(a, 0), Ck(a, d), Dk(a, B()), c);
          if (6 === b) Ck(a, d);
          else {
            if (
              ((e = a.current.alternate),
              0 == (30 & d) &&
                !(function Ok(a) {
                  for (var b = a; ; ) {
                    if (16384 & b.flags) {
                      var c = b.updateQueue;
                      if (null !== c && null !== (c = c.stores))
                        for (var d = 0; d < c.length; d++) {
                          var e = c[d],
                            f = e.getSnapshot;
                          e = e.value;
                          try {
                            if (!He(f(), e)) return;
                          } catch (g) {
                            return;
                          }
                        }
                    }
                    if (((c = b.child), 16384 & b.subtreeFlags && null !== c))
                      (c.return = b), (b = c);
                    else {
                      if (b === a) break;
                      for (; null === b.sibling; ) {
                        if (null === b.return || b.return === a) return 1;
                        b = b.return;
                      }
                      (b.sibling.return = b.return), (b = b.sibling);
                    }
                  }
                  return 1;
                })(e) &&
                1 ===
                  (b =
                    2 === (b = Ik(a, d)) && 0 !== (f = xc(a))
                      ? Nk(a, (d = f))
                      : b))
            )
              throw ((c = pk), Kk(a, 0), Ck(a, d), Dk(a, B()), c);
            switch (((a.finishedWork = e), (a.finishedLanes = d), b)) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                if (
                  (Ck(a, d), (130023424 & d) === d && 10 < (b = fk + 500 - B()))
                ) {
                  if (0 !== uc(a, 0)) break;
                  if (((e = a.suspendedLanes) & d) !== d) {
                    R(), (a.pingedLanes |= a.suspendedLanes & e);
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                } else Pk(a, tk, uk);
                break;
              case 4:
                if ((Ck(a, d), (4194240 & d) !== d)) {
                  for (b = a.eventTimes, e = -1; 0 < d; ) {
                    var g = 31 - oc(d),
                      f = 1 << g;
                    e < (g = b[g]) && (e = g), (d &= ~f);
                  }
                  (d = e),
                    10 <
                    (d =
                      ((d = B() - d) < 120
                        ? 120
                        : d < 480
                        ? 480
                        : d < 1080
                        ? 1080
                        : d < 1920
                        ? 1920
                        : d < 3e3
                        ? 3e3
                        : d < 4320
                        ? 4320
                        : 1960 * lk(d / 1960)) - d)
                      ? (a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d))
                      : Pk(a, tk, uk);
                }
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        return Dk(a, B()), a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        return (
          a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256),
          2 !== (a = Ik(a, b)) && ((b = tk), (tk = c), null !== b) && Fj(b),
          a
        );
      }
      function Fj(a) {
        null === tk ? (tk = a) : tk.push.apply(tk, a);
      }
      function Ck(a, b) {
        for (
          b = b & ~rk & ~qk,
            a.suspendedLanes |= b,
            a.pingedLanes &= ~b,
            a = a.expirationTimes;
          0 < b;

        ) {
          var c = 31 - oc(b),
            d = 1 << c;
          (a[c] = -1), (b &= ~d);
        }
      }
      function Ek(a) {
        if (0 != (6 & K)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 != (1 & b)) {
          var d,
            c = Ik(a, b);
          if (
            (0 !== a.tag &&
              2 === c &&
              0 !== (d = xc(a)) &&
              ((b = d), (c = Nk(a, d))),
            1 === c)
          )
            throw ((c = pk), Kk(a, 0), Ck(a, b), Dk(a, B()), c);
          if (6 === c) throw Error(p(345));
          (a.finishedWork = a.current.alternate),
            (a.finishedLanes = b),
            Pk(a, tk, uk);
        }
        return Dk(a, B()), null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          0 === (K = c) && ((Gj = B() + 500), fg) && jg();
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 == (6 & K) && Hk();
        var b = K,
          c = ((K |= 1), ok.transition),
          d = C;
        try {
          if (((ok.transition = null), (C = 1), a)) return a();
        } finally {
          (C = d), (ok.transition = c), 0 == (6 & (K = b)) && jg();
        }
      }
      function Hj() {
        (fj = ej.current), E(ej);
      }
      function Kk(a, b) {
        (a.finishedWork = null), (a.finishedLanes = 0);
        var e,
          f,
          g,
          c = a.timeoutHandle;
        if ((-1 !== c && ((a.timeoutHandle = -1), Gf(c)), null !== Y))
          for (c = Y.return; null !== c; ) {
            var d = c;
            switch ((wg(d), d.tag)) {
              case 1:
                null != (d = d.type.childContextTypes) && $f();
                break;
              case 3:
                zh(), E(Wf), E(H), Eh();
                break;
              case 5:
                Bh(d);
                break;
              case 4:
                zh();
                break;
              case 13:
              case 19:
                E(L);
                break;
              case 10:
                ah(d.type._context);
                break;
              case 22:
              case 23:
                Hj();
            }
            c = c.return;
          }
        if (
          ((Y = a = Pg((Q = a).current, null)),
          (Z = fj = b),
          (rk = qk = rh = T = 0),
          (tk = sk = pk = null) !== fh)
        ) {
          for (b = 0; b < fh.length; b++)
            null !== (d = (c = fh[b]).interleaved) &&
              ((c.interleaved = null),
              (e = d.next),
              null !== (f = c.pending) &&
                ((g = f.next), (f.next = e), (d.next = g)),
              (c.pending = d));
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            if (($g(), (Fh.current = Rh), Ih)) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null), (d = d.next);
              }
              Ih = !1;
            }
            if (
              ((O = N = M = null),
              (Jh = !1),
              (Kh = Hh = 0),
              (nk.current = null) === c || null === c.return)
            ) {
              (T = 1), (pk = b), (Y = null);
              break;
            }
            a: {
              var f = a,
                g = c.return,
                k = b;
              if (
                ((b = Z),
                ((h = c).flags |= 32768),
                null !== k &&
                  "object" == typeof k &&
                  "function" == typeof k.then)
              ) {
                var r,
                  l = k,
                  m = h,
                  q = m.tag,
                  y =
                    (0 != (1 & m.mode) ||
                      (0 !== q && 11 !== q && 15 !== q) ||
                      ((r = m.alternate)
                        ? ((m.updateQueue = r.updateQueue),
                          (m.memoizedState = r.memoizedState),
                          (m.lanes = r.lanes))
                        : ((m.updateQueue = null), (m.memoizedState = null))),
                    Ui(g));
                if (null !== y) {
                  (y.flags &= -257),
                    Vi(y, g, h, 0, b),
                    1 & y.mode && Si(f, l, b);
                  var t,
                    k = l,
                    n = (b = y).updateQueue;
                  null === n
                    ? ((t = new Set()).add(k), (b.updateQueue = t))
                    : n.add(k);
                  break a;
                }
                if (0 == (1 & b)) {
                  Si(f, l, b), tj();
                  break a;
                }
                k = Error(p(426));
              } else if (I && 1 & h.mode) {
                var J = Ui(g);
                if (null !== J) {
                  0 == (65536 & J.flags) && (J.flags |= 256),
                    Vi(J, g, h, 0, b),
                    Jg(Ji(k, h));
                  break a;
                }
              }
              (f = k = Ji(k, h)),
                4 !== T && (T = 2),
                null === sk ? (sk = [f]) : sk.push(f),
                (f = g);
              do {
                switch (f.tag) {
                  case 3:
                    (f.flags |= 65536),
                      (b &= -b),
                      (f.lanes |= b),
                      ph(f, Ni(0, k, b));
                    break a;
                  case 1:
                    var h = k,
                      w = f.type,
                      u = f.stateNode;
                    if (
                      0 == (128 & f.flags) &&
                      ("function" == typeof w.getDerivedStateFromError ||
                        (null !== u &&
                          "function" == typeof u.componentDidCatch &&
                          (null === Ri || !Ri.has(u))))
                    ) {
                      (f.flags |= 65536),
                        (b &= -b),
                        (f.lanes |= b),
                        ph(f, Qi(f, h, b));
                      break a;
                    }
                }
              } while (null !== (f = f.return));
            }
            Sk(c);
          } catch (na) {
            (b = na), Y === c && null !== c && (Y = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        return (mk.current = Rh), null === a ? Rh : a;
      }
      function tj() {
        (0 !== T && 3 !== T && 2 !== T) || (T = 4),
          null === Q ||
            (0 == (268435455 & rh) && 0 == (268435455 & qk)) ||
            Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K,
          d = ((K |= 2), Jk());
        for ((Q === a && Z === b) || ((uk = null), Kk(a, b)); ; )
          try {
            !(function Tk() {
              for (; null !== Y; ) Uk(Y);
            })();
            break;
          } catch (e) {
            Mk(a, e);
          }
        if (($g(), (K = c), (mk.current = d), null !== Y)) throw Error(p(261));
        return (Q = null), (Z = 0), T;
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        (a.memoizedProps = a.pendingProps),
          null === b ? Sk(a) : (Y = b),
          (nk.current = null);
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          if (((a = b.return), 0 == (32768 & b.flags))) {
            if (
              null !==
              (c = (function Ej(a, b, c) {
                var d = b.pendingProps;
                switch ((wg(b), b.tag)) {
                  case 2:
                  case 16:
                  case 15:
                  case 0:
                  case 11:
                  case 7:
                  case 8:
                  case 12:
                  case 9:
                  case 14:
                    return S(b), null;
                  case 1:
                    return Zf(b.type) && $f(), S(b), null;
                  case 3:
                    return (
                      (d = b.stateNode),
                      zh(),
                      E(Wf),
                      E(H),
                      Eh(),
                      d.pendingContext &&
                        ((d.context = d.pendingContext),
                        (d.pendingContext = null)),
                      (null !== a && null !== a.child) ||
                        (Gg(b)
                          ? (b.flags |= 4)
                          : null === a ||
                            (a.memoizedState.isDehydrated &&
                              0 == (256 & b.flags)) ||
                            ((b.flags |= 1024),
                            null !== zg && (Fj(zg), (zg = null)))),
                      S(b),
                      null
                    );
                  case 5:
                    Bh(b);
                    var k,
                      e = xh(wh.current);
                    if (((c = b.type), null !== a && null != b.stateNode))
                      Bj(a, b, c, d),
                        a.ref !== b.ref &&
                          ((b.flags |= 512), (b.flags |= 2097152));
                    else {
                      if (!d) {
                        if (null === b.stateNode) throw Error(p(166));
                        return S(b), null;
                      }
                      if (((a = xh(uh.current)), Gg(b))) {
                        (d = b.stateNode), (c = b.type);
                        var g,
                          h,
                          f = b.memoizedProps;
                        switch (
                          ((d[Of] = b), (d[Pf] = f), (a = 0 != (1 & b.mode)), c)
                        ) {
                          case "dialog":
                            D("cancel", d), D("close", d);
                            break;
                          case "iframe":
                          case "object":
                          case "embed":
                            D("load", d);
                            break;
                          case "video":
                          case "audio":
                            for (e = 0; e < lf.length; e++) D(lf[e], d);
                            break;
                          case "source":
                            D("error", d);
                            break;
                          case "img":
                          case "image":
                          case "link":
                            D("error", d), D("load", d);
                            break;
                          case "details":
                            D("toggle", d);
                            break;
                          case "input":
                            Za(d, f), D("invalid", d);
                            break;
                          case "select":
                            (d._wrapperState = { wasMultiple: !!f.multiple }),
                              D("invalid", d);
                            break;
                          case "textarea":
                            hb(d, f), D("invalid", d);
                        }
                        for (g in (ub(c, f), (e = null), f))
                          f.hasOwnProperty(g) &&
                            ((h = f[g]),
                            "children" === g
                              ? "string" == typeof h
                                ? d.textContent !== h &&
                                  (!0 !== f.suppressHydrationWarning &&
                                    Af(d.textContent, h, a),
                                  (e = ["children", h]))
                                : "number" == typeof h &&
                                  d.textContent !== "" + h &&
                                  (!0 !== f.suppressHydrationWarning &&
                                    Af(d.textContent, h, a),
                                  (e = ["children", "" + h]))
                              : ea.hasOwnProperty(g) &&
                                null != h &&
                                "onScroll" === g &&
                                D("scroll", d));
                        switch (c) {
                          case "input":
                            Va(d), db(d, f, !0);
                            break;
                          case "textarea":
                            Va(d), jb(d);
                            break;
                          case "select":
                          case "option":
                            break;
                          default:
                            "function" == typeof f.onClick && (d.onclick = Bf);
                        }
                        (d = e), null !== (b.updateQueue = d) && (b.flags |= 4);
                      } else {
                        (g = 9 === e.nodeType ? e : e.ownerDocument),
                          "http://www.w3.org/1999/xhtml" ===
                          (a = "http://www.w3.org/1999/xhtml" === a ? kb(c) : a)
                            ? "script" === c
                              ? (((a = g.createElement("div")).innerHTML =
                                  "<script></script>"),
                                (a = a.removeChild(a.firstChild)))
                              : "string" == typeof d.is
                              ? (a = g.createElement(c, { is: d.is }))
                              : ((a = g.createElement(c)),
                                "select" === c &&
                                  ((g = a),
                                  d.multiple
                                    ? (g.multiple = !0)
                                    : d.size && (g.size = d.size)))
                            : (a = g.createElementNS(a, c)),
                          (a[Of] = b),
                          (a[Pf] = d),
                          zj(a, b),
                          (b.stateNode = a);
                        a: {
                          switch (((g = vb(c, d)), c)) {
                            case "dialog":
                              D("cancel", a), D("close", a), (e = d);
                              break;
                            case "iframe":
                            case "object":
                            case "embed":
                              D("load", a), (e = d);
                              break;
                            case "video":
                            case "audio":
                              for (e = 0; e < lf.length; e++) D(lf[e], a);
                              e = d;
                              break;
                            case "source":
                              D("error", a), (e = d);
                              break;
                            case "img":
                            case "image":
                            case "link":
                              D("error", a), D("load", a), (e = d);
                              break;
                            case "details":
                              D("toggle", a), (e = d);
                              break;
                            case "input":
                              Za(a, d), (e = Ya(a, d)), D("invalid", a);
                              break;
                            case "option":
                              e = d;
                              break;
                            case "select":
                              (a._wrapperState = { wasMultiple: !!d.multiple }),
                                (e = A({}, d, { value: void 0 })),
                                D("invalid", a);
                              break;
                            case "textarea":
                              hb(a, d), (e = gb(a, d)), D("invalid", a);
                              break;
                            default:
                              e = d;
                          }
                          for (f in (ub(c, e), (h = e)))
                            h.hasOwnProperty(f) &&
                              ((k = h[f]),
                              "style" === f
                                ? sb(a, k)
                                : "dangerouslySetInnerHTML" === f
                                ? null != (k = k ? k.__html : void 0) &&
                                  nb(a, k)
                                : "children" === f
                                ? "string" == typeof k
                                  ? ("textarea" === c && "" === k) || ob(a, k)
                                  : "number" == typeof k && ob(a, "" + k)
                                : "suppressContentEditableWarning" !== f &&
                                  "suppressHydrationWarning" !== f &&
                                  "autoFocus" !== f &&
                                  (ea.hasOwnProperty(f)
                                    ? null != k &&
                                      "onScroll" === f &&
                                      D("scroll", a)
                                    : null != k && ta(a, f, k, g)));
                          switch (c) {
                            case "input":
                              Va(a), db(a, d, !1);
                              break;
                            case "textarea":
                              Va(a), jb(a);
                              break;
                            case "option":
                              null != d.value &&
                                a.setAttribute("value", "" + Sa(d.value));
                              break;
                            case "select":
                              (a.multiple = !!d.multiple),
                                null != (f = d.value)
                                  ? fb(a, !!d.multiple, f, !1)
                                  : null != d.defaultValue &&
                                    fb(a, !!d.multiple, d.defaultValue, !0);
                              break;
                            default:
                              "function" == typeof e.onClick &&
                                (a.onclick = Bf);
                          }
                          switch (c) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                              d = !!d.autoFocus;
                              break a;
                            case "img":
                              d = !0;
                              break a;
                            default:
                              d = !1;
                          }
                        }
                        d && (b.flags |= 4);
                      }
                      null !== b.ref &&
                        ((b.flags |= 512), (b.flags |= 2097152));
                    }
                    return S(b), null;
                  case 6:
                    if (a && null != b.stateNode) Cj(0, b, a.memoizedProps, d);
                    else {
                      if ("string" != typeof d && null === b.stateNode)
                        throw Error(p(166));
                      if (((c = xh(wh.current)), xh(uh.current), Gg(b))) {
                        if (
                          ((d = b.stateNode),
                          (c = b.memoizedProps),
                          (d[Of] = b),
                          (f = d.nodeValue !== c) && null !== (a = xg))
                        )
                          switch (a.tag) {
                            case 3:
                              Af(d.nodeValue, c, 0 != (1 & a.mode));
                              break;
                            case 5:
                              !0 !== a.memoizedProps.suppressHydrationWarning &&
                                Af(d.nodeValue, c, 0 != (1 & a.mode));
                          }
                        f && (b.flags |= 4);
                      } else
                        ((d = (
                          9 === c.nodeType ? c : c.ownerDocument
                        ).createTextNode(d))[Of] = b).stateNode = d;
                    }
                    return S(b), null;
                  case 13:
                    if (
                      (E(L),
                      (d = b.memoizedState),
                      null === a ||
                        (null !== a.memoizedState &&
                          null !== a.memoizedState.dehydrated))
                    ) {
                      if (
                        I &&
                        null !== yg &&
                        0 != (1 & b.mode) &&
                        0 == (128 & b.flags)
                      )
                        Hg(), Ig(), (b.flags |= 98560), (f = !1);
                      else if (
                        ((f = Gg(b)), null !== d && null !== d.dehydrated)
                      ) {
                        if (null === a) {
                          if (!f) throw Error(p(318));
                          if (
                            !(f =
                              null !== (f = b.memoizedState)
                                ? f.dehydrated
                                : null)
                          )
                            throw Error(p(317));
                          f[Of] = b;
                        } else
                          Ig(),
                            0 == (128 & b.flags) && (b.memoizedState = null),
                            (b.flags |= 4);
                        S(b), (f = !1);
                      } else null !== zg && (Fj(zg), (zg = null)), (f = !0);
                      if (!f) return 65536 & b.flags ? b : null;
                    }
                    return 0 != (128 & b.flags)
                      ? ((b.lanes = c), b)
                      : ((d = null !== d) !==
                          (null !== a && null !== a.memoizedState) &&
                          d &&
                          ((b.child.flags |= 8192), 0 != (1 & b.mode)) &&
                          (null === a || 0 != (1 & L.current)
                            ? 0 === T && (T = 3)
                            : tj()),
                        null !== b.updateQueue && (b.flags |= 4),
                        S(b),
                        null);
                  case 4:
                    return (
                      zh(),
                      null === a && sf(b.stateNode.containerInfo),
                      S(b),
                      null
                    );
                  case 10:
                    return ah(b.type._context), S(b), null;
                  case 17:
                    return Zf(b.type) && $f(), S(b), null;
                  case 19:
                    if ((E(L), null === (f = b.memoizedState)));
                    else {
                      if (
                        ((d = 0 != (128 & b.flags)), null === (g = f.rendering))
                      )
                        if (d) Dj(f, !1);
                        else {
                          if (0 !== T || (null !== a && 0 != (128 & a.flags)))
                            for (a = b.child; null !== a; ) {
                              if (null !== (g = Ch(a))) {
                                for (
                                  b.flags |= 128,
                                    Dj(f, !1),
                                    null !== (d = g.updateQueue) &&
                                      ((b.updateQueue = d), (b.flags |= 4)),
                                    b.subtreeFlags = 0,
                                    d = c,
                                    c = b.child;
                                  null !== c;

                                )
                                  (a = d),
                                    ((f = c).flags &= 14680066),
                                    null === (g = f.alternate)
                                      ? ((f.childLanes = 0),
                                        (f.lanes = a),
                                        (f.child = null),
                                        (f.subtreeFlags = 0),
                                        (f.memoizedProps = null),
                                        (f.memoizedState = null),
                                        (f.updateQueue = null),
                                        (f.dependencies = null),
                                        (f.stateNode = null))
                                      : ((f.childLanes = g.childLanes),
                                        (f.lanes = g.lanes),
                                        (f.child = g.child),
                                        (f.subtreeFlags = 0),
                                        (f.deletions = null),
                                        (f.memoizedProps = g.memoizedProps),
                                        (f.memoizedState = g.memoizedState),
                                        (f.updateQueue = g.updateQueue),
                                        (f.type = g.type),
                                        (a = g.dependencies),
                                        (f.dependencies =
                                          null === a
                                            ? null
                                            : {
                                                lanes: a.lanes,
                                                firstContext: a.firstContext,
                                              })),
                                    (c = c.sibling);
                                return G(L, (1 & L.current) | 2), b.child;
                              }
                              a = a.sibling;
                            }
                          null !== f.tail &&
                            B() > Gj &&
                            ((b.flags |= 128),
                            Dj(f, !(d = !0)),
                            (b.lanes = 4194304));
                        }
                      else {
                        if (!d)
                          if (null !== (a = Ch(g))) {
                            if (
                              ((b.flags |= 128),
                              (d = !0),
                              null !== (c = a.updateQueue) &&
                                ((b.updateQueue = c), (b.flags |= 4)),
                              Dj(f, !0),
                              null === f.tail &&
                                "hidden" === f.tailMode &&
                                !g.alternate &&
                                !I)
                            )
                              return S(b), null;
                          } else
                            2 * B() - f.renderingStartTime > Gj &&
                              1073741824 !== c &&
                              ((b.flags |= 128),
                              Dj(f, !(d = !0)),
                              (b.lanes = 4194304));
                        f.isBackwards
                          ? ((g.sibling = b.child), (b.child = g))
                          : (null !== (c = f.last)
                              ? (c.sibling = g)
                              : (b.child = g),
                            (f.last = g));
                      }
                      if (null !== f.tail)
                        return (
                          (b = f.tail),
                          (f.rendering = b),
                          (f.tail = b.sibling),
                          (f.renderingStartTime = B()),
                          (b.sibling = null),
                          (c = L.current),
                          G(L, d ? (1 & c) | 2 : 1 & c),
                          b
                        );
                    }
                    return S(b), null;
                  case 22:
                  case 23:
                    return (
                      Hj(),
                      (d = null !== b.memoizedState),
                      null !== a &&
                        (null !== a.memoizedState) !== d &&
                        (b.flags |= 8192),
                      d && 0 != (1 & b.mode)
                        ? 0 != (1073741824 & fj) &&
                          (S(b), 6 & b.subtreeFlags) &&
                          (b.flags |= 8192)
                        : S(b),
                      null
                    );
                  case 24:
                  case 25:
                    return null;
                }
                throw Error(p(156, b.tag));
              })(c, b, fj))
            )
              return void (Y = c);
          } else {
            if (
              null !==
              (c = (function Ij(a, b) {
                switch ((wg(b), b.tag)) {
                  case 1:
                    return (
                      Zf(b.type) && $f(),
                      65536 & (a = b.flags)
                        ? ((b.flags = (-65537 & a) | 128), b)
                        : null
                    );
                  case 3:
                    return (
                      zh(),
                      E(Wf),
                      E(H),
                      Eh(),
                      0 != (65536 & (a = b.flags)) && 0 == (128 & a)
                        ? ((b.flags = (-65537 & a) | 128), b)
                        : null
                    );
                  case 5:
                    return Bh(b), null;
                  case 13:
                    if (
                      (E(L),
                      null !== (a = b.memoizedState) && null !== a.dehydrated)
                    ) {
                      if (null === b.alternate) throw Error(p(340));
                      Ig();
                    }
                    return 65536 & (a = b.flags)
                      ? ((b.flags = (-65537 & a) | 128), b)
                      : null;
                  case 19:
                    return E(L), null;
                  case 4:
                    return zh(), null;
                  case 10:
                    return ah(b.type._context), null;
                  case 22:
                  case 23:
                    return Hj(), null;
                  default:
                    return null;
                }
              })(c, b))
            )
              return (c.flags &= 32767), void (Y = c);
            if (null === a) return (T = 6), void (Y = null);
            (a.flags |= 32768), (a.subtreeFlags = 0), (a.deletions = null);
          }
          if (null !== (b = b.sibling)) return void (Y = b);
        } while (((Y = b = a), null !== b));
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C,
          e = ok.transition;
        try {
          (ok.transition = null),
            (C = 1),
            (function Wk(a, b, c, d) {
              for (; Hk(), null !== wk; );
              if (0 != (6 & K)) throw Error(p(327));
              c = a.finishedWork;
              var e = a.finishedLanes;
              if (null !== c) {
                if (
                  ((a.finishedWork = null),
                  (a.finishedLanes = 0),
                  c === a.current)
                )
                  throw Error(p(177));
                (a.callbackNode = null), (a.callbackPriority = 0);
                var g,
                  h,
                  f = c.lanes | c.childLanes;
                if (
                  (!(function Bc(a, b) {
                    var c = a.pendingLanes & ~b,
                      d =
                        ((a.pendingLanes = b),
                        (a.suspendedLanes = 0),
                        (a.pingedLanes = 0),
                        (a.expiredLanes &= b),
                        (a.mutableReadLanes &= b),
                        (a.entangledLanes &= b),
                        (b = a.entanglements),
                        a.eventTimes);
                    for (a = a.expirationTimes; 0 < c; ) {
                      var e = 31 - oc(c),
                        f = 1 << e;
                      (b[e] = 0), (d[e] = -1), (a[e] = -1), (c &= ~f);
                    }
                  })(a, f),
                  a === Q && ((Y = Q = null), (Z = 0)),
                  (0 == (2064 & c.subtreeFlags) && 0 == (2064 & c.flags)) ||
                    vk ||
                    ((vk = !0),
                    Fk(hc, function () {
                      return Hk(), null;
                    })),
                  (f = 0 != (15990 & c.flags)),
                  0 != (15990 & c.subtreeFlags) || f
                    ? ((f = ok.transition),
                      (ok.transition = null),
                      (g = C),
                      (C = 1),
                      (h = K),
                      (K |= 4),
                      (nk.current = null),
                      (function Oj(a, b) {
                        if (((Cf = dd), Ne((a = Me())))) {
                          if ("selectionStart" in a)
                            var c = {
                              start: a.selectionStart,
                              end: a.selectionEnd,
                            };
                          else
                            a: if (
                              (d =
                                (c =
                                  ((c = a.ownerDocument) && c.defaultView) ||
                                  window).getSelection && c.getSelection()) &&
                              0 !== d.rangeCount
                            ) {
                              var c = d.anchorNode,
                                e = d.anchorOffset,
                                f = d.focusNode,
                                d = d.focusOffset;
                              try {
                                c.nodeType, f.nodeType;
                              } catch (F) {
                                c = null;
                                break a;
                              }
                              var y,
                                g = 0,
                                h = -1,
                                k = -1,
                                l = 0,
                                m = 0,
                                q = a,
                                r = null;
                              b: for (;;) {
                                for (
                                  ;
                                  q !== c ||
                                    (0 !== e && 3 !== q.nodeType) ||
                                    (h = g + e),
                                    q !== f ||
                                      (0 !== d && 3 !== q.nodeType) ||
                                      (k = g + d),
                                    3 === q.nodeType &&
                                      (g += q.nodeValue.length),
                                    null !== (y = q.firstChild);

                                )
                                  (r = q), (q = y);
                                for (;;) {
                                  if (q === a) break b;
                                  if (
                                    (r === c && ++l === e && (h = g),
                                    r === f && ++m === d && (k = g),
                                    null !== (y = q.nextSibling))
                                  )
                                    break;
                                  r = (q = r).parentNode;
                                }
                                q = y;
                              }
                              c =
                                -1 === h || -1 === k
                                  ? null
                                  : { start: h, end: k };
                            } else c = null;
                          c = c || { start: 0, end: 0 };
                        } else c = null;
                        for (
                          dd = !(Df = { focusedElem: a, selectionRange: c }),
                            V = b;
                          null !== V;

                        )
                          if (
                            ((a = (b = V).child),
                            0 != (1028 & b.subtreeFlags) && null !== a)
                          )
                            (a.return = b), (V = a);
                          else
                            for (; null !== V; ) {
                              b = V;
                              try {
                                var t,
                                  J,
                                  x,
                                  w,
                                  n = b.alternate;
                                if (0 != (1024 & b.flags))
                                  switch (b.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                      break;
                                    case 1:
                                      null !== n &&
                                        ((t = n.memoizedProps),
                                        (J = n.memoizedState),
                                        (w = (x =
                                          b.stateNode).getSnapshotBeforeUpdate(
                                          b.elementType === b.type
                                            ? t
                                            : Ci(b.type, t),
                                          J
                                        )),
                                        (x.__reactInternalSnapshotBeforeUpdate =
                                          w));
                                      break;
                                    case 3:
                                      var u = b.stateNode.containerInfo;
                                      1 === u.nodeType
                                        ? (u.textContent = "")
                                        : 9 === u.nodeType &&
                                          u.documentElement &&
                                          u.removeChild(u.documentElement);
                                      break;
                                    case 5:
                                    case 6:
                                    case 4:
                                    case 17:
                                      break;
                                    default:
                                      throw Error(p(163));
                                  }
                              } catch (F) {
                                W(b, b.return, F);
                              }
                              if (null !== (a = b.sibling)) {
                                (a.return = b.return), (V = a);
                                break;
                              }
                              V = b.return;
                            }
                        (n = Nj), (Nj = !1);
                      })(a, c),
                      dk(c, a),
                      Oe(Df),
                      (dd = !!Cf),
                      (Df = Cf = null),
                      (a.current = c),
                      hk(c, a, e),
                      dc(),
                      (K = h),
                      (C = g),
                      (ok.transition = f))
                    : (a.current = c),
                  vk && ((vk = !1), (wk = a), (xk = e)),
                  0 === (f = a.pendingLanes) && (Ri = null),
                  !(function mc(a) {
                    if (lc && "function" == typeof lc.onCommitFiberRoot)
                      try {
                        lc.onCommitFiberRoot(
                          kc,
                          a,
                          void 0,
                          128 == (128 & a.current.flags)
                        );
                      } catch (b) {}
                  })(c.stateNode),
                  Dk(a, B()),
                  null !== b)
                )
                  for (d = a.onRecoverableError, c = 0; c < b.length; c++)
                    (e = b[c]),
                      d(e.value, { componentStack: e.stack, digest: e.digest });
                if (Oi) throw ((Oi = !1), (a = Pi), (Pi = null), a);
                0 != (1 & xk) && 0 !== a.tag && Hk(),
                  0 != (1 & (f = a.pendingLanes))
                    ? a === zk
                      ? yk++
                      : ((yk = 0), (zk = a))
                    : (yk = 0),
                  jg();
              }
            })(a, b, c, d);
        } finally {
          (ok.transition = e), (C = d);
        }
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk),
            b = ok.transition,
            c = C;
          try {
            if (((ok.transition = null), (C = a < 16 ? 16 : a), null === wk))
              var d = !1;
            else {
              if (((a = wk), (wk = null), (xk = 0) != (6 & K)))
                throw Error(p(331));
              var e = K;
              for (K |= 4, V = a.current; null !== V; ) {
                var f = V,
                  g = f.child;
                if (0 != (16 & V.flags)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        switch ((m = V).tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) (q.return = m), (V = q);
                        else
                          for (; null !== V; ) {
                            var m,
                              r = (m = V).sibling,
                              y = m.return;
                            if (
                              (!(function Sj(a) {
                                var b = a.alternate;
                                null !== b && ((a.alternate = null), Sj(b)),
                                  (a.child = null),
                                  (a.deletions = null),
                                  (a.sibling = null),
                                  5 === a.tag &&
                                    null !== (b = a.stateNode) &&
                                    (delete b[Of],
                                    delete b[Pf],
                                    delete b[of],
                                    delete b[Qf],
                                    delete b[Rf]),
                                  (a.stateNode = null),
                                  (a.return = null),
                                  (a.dependencies = null),
                                  (a.memoizedProps = null),
                                  (a.memoizedState = null),
                                  (a.pendingProps = null),
                                  (a.stateNode = null),
                                  (a.updateQueue = null);
                              })(m),
                              m === l)
                            ) {
                              V = null;
                              break;
                            }
                            if (null !== r) {
                              (r.return = y), (V = r);
                              break;
                            }
                            V = y;
                          }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                        } while ((t.sibling = null) !== (t = J));
                      }
                    }
                    V = f;
                  }
                }
                if (0 != (2064 & f.subtreeFlags) && null !== g)
                  (g.return = f), (V = g);
                else
                  for (; null !== V; ) {
                    if (0 != (2048 & (f = V).flags))
                      switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f, f.return);
                      }
                    var x = f.sibling;
                    if (null !== x) {
                      (x.return = f.return), (V = x);
                      break;
                    }
                    V = f.return;
                  }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                var u = (g = V).child;
                if (0 != (2064 & g.subtreeFlags) && null !== u)
                  (u.return = g), (V = u);
                else
                  for (g = w; null !== V; ) {
                    if (0 != (2048 & (h = V).flags))
                      try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h);
                        }
                      } catch (na) {
                        W(h, h.return, na);
                      }
                    if (h === g) {
                      V = null;
                      break;
                    }
                    var F = h.sibling;
                    if (null !== F) {
                      (F.return = h.return), (V = F);
                      break;
                    }
                    V = h.return;
                  }
              }
              if (
                ((K = e),
                jg(),
                lc && "function" == typeof lc.onPostCommitFiberRoot)
              )
                try {
                  lc.onPostCommitFiberRoot(kc, a);
                } catch (na) {}
              d = !0;
            }
            return d;
          } finally {
            (C = c), (ok.transition = b);
          }
        }
      }
      function Xk(a, b, c) {
        (a = nh(a, (b = Ni(0, (b = Ji(c, b)), 1)), 1)),
          (b = R()),
          null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else
          for (; null !== b; ) {
            if (3 === b.tag) {
              Xk(b, a, c);
              break;
            }
            if (1 === b.tag) {
              var d = b.stateNode;
              if (
                "function" == typeof b.type.getDerivedStateFromError ||
                ("function" == typeof d.componentDidCatch &&
                  (null === Ri || !Ri.has(d)))
              ) {
                (b = nh(b, (a = Qi(b, (a = Ji(c, a)), 1)), 1)),
                  (a = R()),
                  null !== b && (Ac(b, 1, a), Dk(b, a));
                break;
              }
            }
            b = b.return;
          }
      }
      function Yk(a, b) {
        0 === b &&
          (0 == (1 & a.mode)
            ? (b = 1)
            : ((b = sc), 0 == (130023424 & (sc <<= 1)) && (sc = 4194304)));
        var c = R();
        null !== (a = ih(a, b)) && (Ac(a, b, c), Dk(a, c));
      }
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        (this.tag = a),
          (this.key = c),
          (this.sibling =
            this.child =
            this.return =
            this.stateNode =
            this.type =
            this.elementType =
              null),
          (this.index = 0),
          (this.ref = null),
          (this.pendingProps = b),
          (this.dependencies =
            this.memoizedState =
            this.updateQueue =
            this.memoizedProps =
              null),
          (this.mode = d),
          (this.subtreeFlags = this.flags = 0),
          (this.deletions = null),
          (this.childLanes = this.lanes = 0),
          (this.alternate = null);
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        return (a = a.prototype) && a.isReactComponent;
      }
      function Pg(a, b) {
        var c = a.alternate;
        return (
          null === c
            ? (((c = Bg(a.tag, b, a.key, a.mode)).elementType = a.elementType),
              (c.type = a.type),
              (c.stateNode = a.stateNode),
              ((c.alternate = a).alternate = c))
            : ((c.pendingProps = b),
              (c.type = a.type),
              (c.flags = 0),
              (c.subtreeFlags = 0),
              (c.deletions = null)),
          (c.flags = 14680064 & a.flags),
          (c.childLanes = a.childLanes),
          (c.lanes = a.lanes),
          (c.child = a.child),
          (c.memoizedProps = a.memoizedProps),
          (c.memoizedState = a.memoizedState),
          (c.updateQueue = a.updateQueue),
          (b = a.dependencies),
          (c.dependencies =
            null === b
              ? null
              : { lanes: b.lanes, firstContext: b.firstContext }),
          (c.sibling = a.sibling),
          (c.index = a.index),
          (c.ref = a.ref),
          c
        );
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        if ("function" == typeof (d = a)) aj(a) && (g = 1);
        else if ("string" == typeof a) g = 5;
        else
          a: switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              e |= g = 8;
              break;
            case Aa:
              return (
                ((a = Bg(12, c, b, 2 | e)).elementType = Aa), (a.lanes = f), a
              );
            case Ea:
              return ((a = Bg(13, c, b, e)).elementType = Ea), (a.lanes = f), a;
            case Fa:
              return ((a = Bg(19, c, b, e)).elementType = Fa), (a.lanes = f), a;
            case Ia:
              return pj(c, e, f, b);
            default:
              if ("object" == typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    (g = 16), (d = null);
                    break a;
                }
              throw Error(p(130, null == a ? a : typeof a, ""));
          }
        return (
          ((b = Bg(g, c, b, e)).elementType = a), (b.type = d), (b.lanes = f), b
        );
      }
      function Tg(a, b, c, d) {
        return ((a = Bg(7, a, d, b)).lanes = c), a;
      }
      function pj(a, b, c, d) {
        return (
          ((a = Bg(22, a, d, b)).elementType = Ia),
          (a.lanes = c),
          (a.stateNode = { isHidden: !1 }),
          a
        );
      }
      function Qg(a, b, c) {
        return ((a = Bg(6, a, null, b)).lanes = c), a;
      }
      function Sg(a, b, c) {
        return (
          ((b = Bg(4, null !== a.children ? a.children : [], a.key, b)).lanes =
            c),
          (b.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation,
          }),
          b
        );
      }
      function al(a, b, c, d, e) {
        (this.tag = b),
          (this.containerInfo = a),
          (this.finishedWork =
            this.pingCache =
            this.current =
            this.pendingChildren =
              null),
          (this.timeoutHandle = -1),
          (this.callbackNode = this.pendingContext = this.context = null),
          (this.callbackPriority = 0),
          (this.eventTimes = zc(0)),
          (this.expirationTimes = zc(-1)),
          (this.entangledLanes =
            this.finishedLanes =
            this.mutableReadLanes =
            this.expiredLanes =
            this.pingedLanes =
            this.suspendedLanes =
            this.pendingLanes =
              0),
          (this.entanglements = zc(0)),
          (this.identifierPrefix = d),
          (this.onRecoverableError = e),
          (this.mutableSourceEagerHydrationData = null);
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        return (
          (a = new al(a, b, 0, h, k)),
          1 === b ? ((b = 1), !0 === f && (b |= 8)) : (b = 0),
          (f = Bg(3, null, null, b)),
          ((a.current = f).stateNode = a),
          (f.memoizedState = {
            element: d,
            isDehydrated: c,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null,
          }),
          kh(f),
          a
        );
      }
      function dl(a) {
        if (!a) return Vf;
        a: {
          if (Vb((a = a._reactInternals)) !== a || 1 !== a.tag)
            throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
          } while (null !== (b = b.return));
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        return (
          ((a = bl(c, d, !0, a, 0, f, 0, h, k)).context = dl(null)),
          (c = a.current),
          ((f = mh((d = R()), (e = yi(c)))).callback = null != b ? b : null),
          nh(c, f, e),
          (a.current.lanes = e),
          Ac(a, e, d),
          Dk(a, d),
          a
        );
      }
      function fl(a, b, c, d) {
        var e = b.current,
          f = R(),
          g = yi(e);
        (c = dl(c)),
          null === b.context ? (b.context = c) : (b.pendingContext = c),
          ((b = mh(f, g)).payload = { element: a }),
          null !== (d = void 0 === d ? null : d) && (b.callback = d),
          null !== (a = nh(e, b, g)) && (gi(a, e, g, f), oh(a, e, g));
      }
      function gl(a) {
        return (a = a.current).child ? (a.child.tag, a.child.stateNode) : null;
      }
      function hl(a, b) {
        var c;
        null !== (a = a.memoizedState) &&
          null !== a.dehydrated &&
          ((c = a.retryLane), (a.retryLane = 0 !== c && c < b ? c : b));
      }
      function il(a, b) {
        hl(a, b), (a = a.alternate) && hl(a, b);
      }
      var Vk = function (a, b, c) {
          if (null !== a)
            if (a.memoizedProps !== b.pendingProps || Wf.current) dh = !0;
            else {
              if (0 == (a.lanes & c) && 0 == (128 & b.flags))
                return (
                  (dh = !1),
                  (function yj(a, b, c) {
                    switch (b.tag) {
                      case 3:
                        kj(b), Ig();
                        break;
                      case 5:
                        Ah(b);
                        break;
                      case 1:
                        Zf(b.type) && cg(b);
                        break;
                      case 4:
                        yh(b, b.stateNode.containerInfo);
                        break;
                      case 10:
                        var d = b.type._context,
                          e = b.memoizedProps.value;
                        G(Wg, d._currentValue), (d._currentValue = e);
                        break;
                      case 13:
                        if (null !== (d = b.memoizedState))
                          return null !== d.dehydrated
                            ? (G(L, 1 & L.current), (b.flags |= 128), null)
                            : 0 != (c & b.child.childLanes)
                            ? oj(a, b, c)
                            : (G(L, 1 & L.current),
                              null !== (a = Zi(a, b, c)) ? a.sibling : null);
                        G(L, 1 & L.current);
                        break;
                      case 19:
                        if (
                          ((d = 0 != (c & b.childLanes)), 0 != (128 & a.flags))
                        ) {
                          if (d) return xj(a, b, c);
                          b.flags |= 128;
                        }
                        if (
                          (null !== (e = b.memoizedState) &&
                            ((e.rendering = null),
                            (e.tail = null),
                            (e.lastEffect = null)),
                          G(L, L.current),
                          d)
                        )
                          break;
                        return null;
                      case 22:
                      case 23:
                        return (b.lanes = 0), dj(a, b, c);
                    }
                    return Zi(a, b, c);
                  })(a, b, c)
                );
              dh = 0 != (131072 & a.flags);
            }
          else (dh = !1), I && 0 != (1048576 & b.flags) && ug(b, ng, b.index);
          switch (((b.lanes = 0), b.tag)) {
            case 2:
              var d = b.type,
                e = (ij(a, b), (a = b.pendingProps), Yf(b, H.current)),
                f = (ch(b, c), (e = Nh(null, b, d, a, e, c)), Sh());
              return (
                (b.flags |= 1),
                (b =
                  "object" == typeof e &&
                  null !== e &&
                  "function" == typeof e.render &&
                  void 0 === e.$$typeof
                    ? ((b.tag = 1),
                      (b.memoizedState = null),
                      (b.updateQueue = null),
                      Zf(d) ? ((f = !0), cg(b)) : (f = !1),
                      (b.memoizedState =
                        null !== e.state && void 0 !== e.state
                          ? e.state
                          : null),
                      kh(b),
                      (e.updater = Ei),
                      Ii(((b.stateNode = e)._reactInternals = b), d, a, c),
                      jj(null, b, d, !0, f, c))
                    : ((b.tag = 0),
                      I && f && vg(b),
                      Xi(null, b, e, c),
                      b.child))
              );
            case 16:
              d = b.elementType;
              a: {
                switch (
                  (ij(a, b),
                  (a = b.pendingProps),
                  (d = (e = d._init)(d._payload)),
                  (b.type = d),
                  (e = b.tag =
                    (function Zk(a) {
                      if ("function" == typeof a) return aj(a) ? 1 : 0;
                      if (null != a) {
                        if ((a = a.$$typeof) === Da) return 11;
                        if (a === Ga) return 14;
                      }
                      return 2;
                    })(d)),
                  (a = Ci(d, a)),
                  e)
                ) {
                  case 0:
                    b = cj(null, b, d, a, c);
                    break a;
                  case 1:
                    b = hj(null, b, d, a, c);
                    break a;
                  case 11:
                    b = Yi(null, b, d, a, c);
                    break a;
                  case 14:
                    b = $i(null, b, d, Ci(d.type, a), c);
                    break a;
                }
                throw Error(p(306, d, ""));
              }
              return b;
            case 0:
              return (
                (d = b.type),
                (e = b.pendingProps),
                cj(a, b, d, (e = b.elementType === d ? e : Ci(d, e)), c)
              );
            case 1:
              return (
                (d = b.type),
                (e = b.pendingProps),
                hj(a, b, d, (e = b.elementType === d ? e : Ci(d, e)), c)
              );
            case 3:
              a: {
                if ((kj(b), null === a)) throw Error(p(387));
                (d = b.pendingProps),
                  (e = (f = b.memoizedState).element),
                  lh(a, b),
                  qh(b, d, null, c);
                var g = b.memoizedState,
                  d = g.element;
                if (f.isDehydrated) {
                  if (
                    ((f = {
                      element: d,
                      isDehydrated: !1,
                      cache: g.cache,
                      pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                      transitions: g.transitions,
                    }),
                    (b.updateQueue.baseState = f),
                    (b.memoizedState = f),
                    256 & b.flags)
                  ) {
                    b = lj(a, b, d, c, (e = Ji(Error(p(423)), b)));
                    break a;
                  }
                  if (d !== e) {
                    b = lj(a, b, d, c, (e = Ji(Error(p(424)), b)));
                    break a;
                  }
                  for (
                    yg = Lf(b.stateNode.containerInfo.firstChild),
                      I = !0,
                      c = Vg((xg = b), (zg = null), d, c),
                      b.child = c;
                    c;

                  )
                    (c.flags = (-3 & c.flags) | 4096), (c = c.sibling);
                } else {
                  if ((Ig(), d === e)) {
                    b = Zi(a, b, c);
                    break a;
                  }
                  Xi(a, b, d, c);
                }
                b = b.child;
              }
              return b;
            case 5:
              return (
                Ah(b),
                null === a && Eg(b),
                (d = b.type),
                (e = b.pendingProps),
                (f = null !== a ? a.memoizedProps : null),
                (g = e.children),
                Ef(d, e)
                  ? (g = null)
                  : null !== f && Ef(d, f) && (b.flags |= 32),
                gj(a, b),
                Xi(a, b, g, c),
                b.child
              );
            case 6:
              return null === a && Eg(b), null;
            case 13:
              return oj(a, b, c);
            case 4:
              return (
                yh(b, b.stateNode.containerInfo),
                (d = b.pendingProps),
                null === a ? (b.child = Ug(b, null, d, c)) : Xi(a, b, d, c),
                b.child
              );
            case 11:
              return (
                (d = b.type),
                (e = b.pendingProps),
                Yi(a, b, d, (e = b.elementType === d ? e : Ci(d, e)), c)
              );
            case 7:
              return Xi(a, b, b.pendingProps, c), b.child;
            case 8:
            case 12:
              return Xi(a, b, b.pendingProps.children, c), b.child;
            case 10:
              a: {
                if (
                  ((d = b.type._context),
                  (e = b.pendingProps),
                  (f = b.memoizedProps),
                  (g = e.value),
                  G(Wg, d._currentValue),
                  (d._currentValue = g),
                  null !== f)
                )
                  if (He(f.value, g)) {
                    if (f.children === e.children && !Wf.current) {
                      b = Zi(a, b, c);
                      break a;
                    }
                  } else
                    for (
                      null !== (f = b.child) && (f.return = b);
                      null !== f;

                    ) {
                      var h = f.dependencies;
                      if (null !== h)
                        for (
                          var l, m, g = f.child, k = h.firstContext;
                          null !== k;

                        ) {
                          if (k.context === d) {
                            1 === f.tag &&
                              (((k = mh(-1, c & -c)).tag = 2),
                              null !== (l = f.updateQueue)) &&
                              (null === (m = (l = l.shared).pending)
                                ? (k.next = k)
                                : ((k.next = m.next), (m.next = k)),
                              (l.pending = k)),
                              (f.lanes |= c),
                              null !== (k = f.alternate) && (k.lanes |= c),
                              bh(f.return, c, b),
                              (h.lanes |= c);
                            break;
                          }
                          k = k.next;
                        }
                      else if (10 === f.tag)
                        g = f.type === b.type ? null : f.child;
                      else if (18 === f.tag) {
                        if (null === (g = f.return)) throw Error(p(341));
                        (g.lanes |= c),
                          null !== (h = g.alternate) && (h.lanes |= c),
                          bh(g, c, b),
                          (g = f.sibling);
                      } else g = f.child;
                      if (null !== g) g.return = f;
                      else
                        for (g = f; null !== g; ) {
                          if (g === b) {
                            g = null;
                            break;
                          }
                          if (null !== (f = g.sibling)) {
                            (f.return = g.return), (g = f);
                            break;
                          }
                          g = g.return;
                        }
                      f = g;
                    }
                Xi(a, b, e.children, c), (b = b.child);
              }
              return b;
            case 9:
              return (
                (e = b.type),
                (d = b.pendingProps.children),
                ch(b, c),
                (d = d((e = eh(e)))),
                (b.flags |= 1),
                Xi(a, b, d, c),
                b.child
              );
            case 14:
              return (
                (e = Ci((d = b.type), b.pendingProps)),
                $i(a, b, d, (e = Ci(d.type, e)), c)
              );
            case 15:
              return bj(a, b, b.type, b.pendingProps, c);
            case 17:
              return (
                (d = b.type),
                (e = b.pendingProps),
                (e = b.elementType === d ? e : Ci(d, e)),
                ij(a, b),
                (b.tag = 1),
                Zf(d) ? ((a = !0), cg(b)) : (a = !1),
                ch(b, c),
                Gi(b, d, e),
                Ii(b, d, e, c),
                jj(null, b, d, !0, a, c)
              );
            case 19:
              return xj(a, b, c);
            case 22:
              return dj(a, b, c);
          }
          throw Error(p(156, b.tag));
        },
        kl =
          "function" == typeof reportError
            ? reportError
            : function (a) {
                console.error(a);
              };
      function ll(a) {
        this._internalRoot = a;
      }
      function ml(a) {
        this._internalRoot = a;
      }
      function nl(a) {
        return a && (1 === a.nodeType || 9 === a.nodeType || 11 === a.nodeType);
      }
      function ol(a) {
        return (
          a &&
          (1 === a.nodeType ||
            9 === a.nodeType ||
            11 === a.nodeType ||
            (8 === a.nodeType &&
              " react-mount-point-unstable " === a.nodeValue))
        );
      }
      function pl() {}
      function rl(a, b, c, d, e) {
        var g,
          h,
          f = c._reactRootContainer;
        return (
          f
            ? ("function" == typeof e &&
                ((h = e),
                (e = function () {
                  var a = gl(g);
                  h.call(a);
                })),
              fl(b, (g = f), a, e))
            : (g = (function ql(a, b, c, d, e) {
                var f, g, h;
                if (e)
                  return (
                    "function" == typeof d &&
                      ((f = d),
                      (d = function () {
                        var a = gl(g);
                        f.call(a);
                      })),
                    (g = el(b, d, a, 0, null, !1, 0, "", pl)),
                    (a._reactRootContainer = g),
                    (a[uf] = g.current),
                    sf(8 === a.nodeType ? a.parentNode : a),
                    Rk(),
                    g
                  );
                for (; (e = a.lastChild); ) a.removeChild(e);
                "function" == typeof d &&
                  ((h = d),
                  (d = function () {
                    var a = gl(k);
                    h.call(a);
                  }));
                var k = bl(a, 0, !1, null, 0, !1, 0, "", pl);
                return (
                  (a._reactRootContainer = k),
                  (a[uf] = k.current),
                  sf(8 === a.nodeType ? a.parentNode : a),
                  Rk(function () {
                    fl(b, k, c, d);
                  }),
                  k
                );
              })(c, b, a, e, d)),
          gl(g)
        );
      }
      (ml.prototype.render = ll.prototype.render =
        function (a) {
          var b = this._internalRoot;
          if (null === b) throw Error(p(409));
          fl(a, b, null, null);
        }),
        (ml.prototype.unmount = ll.prototype.unmount =
          function () {
            var b,
              a = this._internalRoot;
            null !== a &&
              ((this._internalRoot = null),
              (b = a.containerInfo),
              Rk(function () {
                fl(null, a, null, null);
              }),
              (b[uf] = null));
          }),
        (ml.prototype.unstable_scheduleHydration = function (a) {
          if (a) {
            var b = Hc();
            a = { blockedOn: null, target: a, priority: b };
            for (
              var c = 0;
              c < Qc.length && 0 !== b && b < Qc[c].priority;
              c++
            );
            Qc.splice(c, 0, a), 0 === c && Vc(a);
          }
        }),
        (Ec = function (a) {
          switch (a.tag) {
            case 3:
              var c,
                b = a.stateNode;
              b.current.memoizedState.isDehydrated &&
                0 !== (c = tc(b.pendingLanes)) &&
                (Cc(b, 1 | c), Dk(b, B()), 0 == (6 & K)) &&
                ((Gj = B() + 500), jg());
              break;
            case 13:
              Rk(function () {
                var c,
                  b = ih(a, 1);
                null !== b && ((c = R()), gi(b, a, 1, c));
              }),
                il(a, 1);
          }
        }),
        (Fc = function (a) {
          var b;
          13 === a.tag &&
            (null !== (b = ih(a, 134217728)) && gi(b, a, 134217728, R()),
            il(a, 134217728));
        }),
        (Gc = function (a) {
          var b, c;
          13 === a.tag &&
            (null !== (c = ih(a, (b = yi(a)))) && gi(c, a, b, R()), il(a, b));
        }),
        (Hc = function () {
          return C;
        }),
        (Ic = function (a, b) {
          var c = C;
          try {
            return (C = a), b();
          } finally {
            C = c;
          }
        }),
        (Hb = Rk);
      (Mb = {
        usingClientEntryPoint: !(yb = function (a, b, c) {
          switch (b) {
            case "input":
              if ((bb(a, c), (b = c.name), "radio" === c.type && null != b)) {
                for (c = a; c.parentNode; ) c = c.parentNode;
                for (
                  c = c.querySelectorAll(
                    "input[name=" + JSON.stringify("" + b) + '][type="radio"]'
                  ),
                    b = 0;
                  b < c.length;
                  b++
                ) {
                  var d = c[b];
                  if (d !== a && d.form === a.form) {
                    var e = Db(d);
                    if (!e) throw Error(p(90));
                    Wa(d), bb(d, e);
                  }
                }
              }
              break;
            case "textarea":
              ib(a, c);
              break;
            case "select":
              null != (b = c.value) && fb(a, !!c.multiple, b, !1);
          }
        }),
        Events: [Cb, ue, Db, Eb, Fb, (Gb = Qk)],
      }),
        (ud = {
          findFiberByHostInstance: Wc,
          bundleType: 0,
          version: "18.3.1",
          rendererPackageName: "react-dom",
        }),
        (__webpack_require__ = {
          bundleType: ud.bundleType,
          version: ud.version,
          rendererPackageName: ud.rendererPackageName,
          rendererConfig: ud.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: aa.ReactCurrentDispatcher,
          findHostInstanceByFiber: function (a) {
            return null === (a = Zb(a)) ? null : a.stateNode;
          },
          findFiberByHostInstance:
            ud.findFiberByHostInstance ||
            function jl() {
              return null;
            },
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
        });
      if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        Ad = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Ad.isDisabled && Ad.supportsFiber)
          try {
            (kc = Ad.inject(__webpack_require__)), (lc = Ad);
          } catch (a) {}
      }
      (exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Mb),
        (exports.createPortal = function (a, b) {
          if (nl(b))
            return (function cl(a, b, c, argument_3) {
              return {
                $$typeof: wa,
                key:
                  null ==
                  (argument_3 =
                    3 < arguments.length && void 0 !== argument_3
                      ? argument_3
                      : null)
                    ? null
                    : "" + argument_3,
                children: a,
                containerInfo: b,
                implementation: c,
              };
            })(
              a,
              b,
              null,
              2 < arguments.length && void 0 !== arguments[2]
                ? arguments[2]
                : null
            );
          throw Error(p(200));
        }),
        (exports.createRoot = function (a, b) {
          var c, d, e;
          if (nl(a))
            return (
              (c = !1),
              (d = ""),
              (e = kl),
              null != b &&
                (!0 === b.unstable_strictMode && (c = !0),
                void 0 !== b.identifierPrefix && (d = b.identifierPrefix),
                void 0 !== b.onRecoverableError) &&
                (e = b.onRecoverableError),
              (b = bl(a, 1, !1, null, 0, c, 0, d, e)),
              (a[uf] = b.current),
              sf(8 === a.nodeType ? a.parentNode : a),
              new ll(b)
            );
          throw Error(p(299));
        }),
        (exports.findDOMNode = function (a) {
          if (null == a) return null;
          if (1 !== a.nodeType) {
            var b = a._reactInternals;
            if (void 0 === b) {
              if ("function" == typeof a.render) throw Error(p(188));
              throw ((a = Object.keys(a).join(",")), Error(p(268, a)));
            }
            a = null === (a = Zb(b)) ? null : a.stateNode;
          }
          return a;
        }),
        (exports.flushSync = Rk),
        (exports.hydrate = function (a, b, c) {
          if (ol(b)) return rl(null, a, b, !0, c);
          throw Error(p(200));
        }),
        (exports.hydrateRoot = function (a, b, c) {
          if (!nl(a)) throw Error(p(405));
          var d = (null != c && c.hydratedSources) || null,
            e = !1,
            f = "",
            g = kl;
          if (
            (null != c &&
              (!0 === c.unstable_strictMode && (e = !0),
              void 0 !== c.identifierPrefix && (f = c.identifierPrefix),
              void 0 !== c.onRecoverableError) &&
              (g = c.onRecoverableError),
            (b = el(b, null, a, 1, null != c ? c : null, e, 0, f, g)),
            (a[uf] = b.current),
            sf(a),
            d)
          )
            for (a = 0; a < d.length; a++)
              (e = (e = (c = d[a])._getVersion)(c._source)),
                null == b.mutableSourceEagerHydrationData
                  ? (b.mutableSourceEagerHydrationData = [c, e])
                  : b.mutableSourceEagerHydrationData.push(c, e);
          return new ml(b);
        }),
        (exports.render = function (a, b, c) {
          if (ol(b)) return rl(null, a, b, !1, c);
          throw Error(p(200));
        }),
        (exports.unmountComponentAtNode = function (a) {
          if (ol(a))
            return (
              !!a._reactRootContainer &&
              (Rk(function () {
                rl(null, null, a, !1, function () {
                  (a._reactRootContainer = null), (a[uf] = null);
                });
              }),
              !0)
            );
          throw Error(p(40));
        }),
        (exports.unstable_batchedUpdates = Qk),
        (exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
          if (!ol(c)) throw Error(p(200));
          if (null == a || void 0 === a._reactInternals) throw Error(p(38));
          return rl(a, b, c, !1, d);
        }),
        (exports.version = "18.3.1-next-f1338f8080-20240426");
    },
    7470: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      __webpack_require__ = __webpack_require__(8325);
      (exports.createRoot = __webpack_require__.createRoot),
        (exports.hydrateRoot = __webpack_require__.hydrateRoot);
    },
    8325: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      !(function checkDCE() {
        if (
          "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
          "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE
        )
          try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
          } catch (err) {
            console.error(err);
          }
      })(),
        (module.exports = __webpack_require__(6067));
    },
    8996: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var _createClass = function (Constructor, protoProps, staticProps) {
        return (
          protoProps && defineProperties(Constructor.prototype, protoProps),
          staticProps && defineProperties(Constructor, staticProps),
          Constructor
        );
      };
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          (descriptor.enumerable = descriptor.enumerable || !1),
            (descriptor.configurable = !0),
            "value" in descriptor && (descriptor.writable = !0),
            Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      var _react = __webpack_require__(3696),
        _react2 = _interopRequireDefault(_react),
        _propTypes2 = _interopRequireDefault(__webpack_require__(2688)),
        _howler4 = __webpack_require__(7529),
        __webpack_require__ = __webpack_require__(8719);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ReactHowler = (function () {
        function ReactHowler(props) {
          !(function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          })(this, ReactHowler);
          props = (function _possibleConstructorReturn(self, call) {
            if (self)
              return !call ||
                ("object" != typeof call && "function" != typeof call)
                ? self
                : call;
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          })(
            this,
            (ReactHowler.__proto__ || Object.getPrototypeOf(ReactHowler)).call(
              this,
              props
            )
          );
          return (props.initHowler = props.initHowler.bind(props)), props;
        }
        return (
          (function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass)
              throw new TypeError(
                "Super expression must either be null or a function, not " +
                  typeof superClass
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                (Object.setPrototypeOf
                  ? Object.setPrototypeOf(subClass, superClass)
                  : (subClass.__proto__ = superClass));
          })(ReactHowler, _react.Component),
          _createClass(ReactHowler, [
            {
              key: "componentDidMount",
              value: function componentDidMount() {
                this.initHowler();
              },
            },
            {
              key: "componentDidUpdate",
              value: function componentDidUpdate(prevProps) {
                JSON.stringify(prevProps.src) !== JSON.stringify(this.props.src)
                  ? this.initHowler(this.props)
                  : this.toggleHowler(prevProps);
              },
            },
            {
              key: "componentWillUnmount",
              value: function componentWillUnmount() {
                this.destroyHowler();
              },
            },
            {
              key: "initHowler",
              value: function initHowler() {
                var props =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : this.props;
                this.destroyHowler(),
                  void 0 !== _howler4.Howl &&
                    ((this.howler = new _howler4.Howl({
                      src: props.src,
                      xhr: props.xhr,
                      format: props.format,
                      mute: props.mute,
                      loop: props.loop,
                      preload: props.preload,
                      volume: props.volume,
                      rate: props.rate,
                      onend: props.onEnd,
                      onplay: props.onPlay,
                      onplayerror: props.onPlayError,
                      onpause: props.onPause,
                      onvolume: props.onVolume,
                      onstop: props.onStop,
                      onload: props.onLoad,
                      onseek: props.onSeek,
                      onloaderror: props.onLoadError,
                      html5: props.html5,
                    })),
                    props.playing) &&
                    this.play();
              },
            },
            {
              key: "destroyHowler",
              value: function destroyHowler() {
                this.howler &&
                  (this.howler.off(),
                  this.howler.stop(),
                  this.howler.unload(),
                  (this.howler = null));
              },
            },
            {
              key: "toggleHowler",
              value: function toggleHowler(prevProps) {
                this.props.playing ? this.play() : this.pause(),
                  this.loop(this.props.loop),
                  prevProps.mute !== this.props.mute &&
                    this.mute(this.props.mute),
                  prevProps.volume !== this.props.volume &&
                    this.volume(this.props.volume),
                  this.props.preload &&
                    "unloaded" === this.howlerState() &&
                    this.load();
              },
            },
            {
              key: "play",
              value: function play() {
                this.howler.playing() ||
                  ("unloaded" === this.howlerState() && this.load(),
                  this.howler.play());
              },
            },
            {
              key: "pause",
              value: function pause() {
                var id =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : void 0;
                id ? this.howler.pause(id) : this.howler.pause();
              },
            },
            {
              key: "rate",
              value: function rate() {
                var value =
                    0 < arguments.length && void 0 !== arguments[0]
                      ? arguments[0]
                      : 1,
                  id =
                    1 < arguments.length && void 0 !== arguments[1]
                      ? arguments[1]
                      : void 0;
                "number" == typeof value &&
                  (id ? this.howler.rate(value, id) : this.howler.rate(value));
              },
            },
            {
              key: "howlerState",
              value: function howlerState() {
                return this.howler.state();
              },
            },
            {
              key: "stop",
              value: function stop() {
                var id =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : void 0;
                id ? this.howler.stop(id) : this.howler.stop();
              },
            },
            {
              key: "mute",
              value: function mute() {
                var _howler;
                (_howler = this.howler).mute.apply(_howler, arguments);
              },
            },
            {
              key: "volume",
              value: function volume() {
                var _howler2;
                return (_howler2 = this.howler).volume.apply(
                  _howler2,
                  arguments
                );
              },
            },
            {
              key: "loop",
              value: function loop() {
                var _howler3;
                return (_howler3 = this.howler).loop.apply(_howler3, arguments);
              },
            },
            {
              key: "seek",
              value: function seek() {
                var pos =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : null;
                return this.howler
                  ? pos || 0 === pos
                    ? (this.howler.seek(pos), pos)
                    : this.howler.seek()
                  : 0;
              },
            },
            {
              key: "duration",
              value: function duration() {
                return this.howler.duration();
              },
            },
            {
              key: "load",
              value: function load() {
                this.howler.load();
              },
            },
            {
              key: "render",
              value: function render() {
                return _react2.default.createElement("div", null);
              },
            },
            {
              key: "howler",
              set: function set(howl) {
                howl && (this._howler = howl);
              },
              get: function get() {
                return this._howler;
              },
            },
          ]),
          ReactHowler
        );
      })();
      (ReactHowler.propTypes = {
        src: _propTypes2.default.oneOfType([
          _propTypes2.default.string,
          _propTypes2.default.arrayOf(_propTypes2.default.string),
        ]).isRequired,
        format: _propTypes2.default.arrayOf(_propTypes2.default.string),
        xhr: _propTypes2.default.object,
        playing: _propTypes2.default.bool,
        mute: _propTypes2.default.bool,
        loop: _propTypes2.default.bool,
        preload: _propTypes2.default.bool,
        volume: _propTypes2.default.number,
        rate: _propTypes2.default.number,
        onEnd: _propTypes2.default.func,
        onPause: _propTypes2.default.func,
        onPlay: _propTypes2.default.func,
        onPlayError: _propTypes2.default.func,
        onVolume: _propTypes2.default.func,
        onStop: _propTypes2.default.func,
        onLoad: _propTypes2.default.func,
        onSeek: _propTypes2.default.func,
        onLoadError: _propTypes2.default.func,
        html5: _propTypes2.default.bool,
      }),
        (ReactHowler.defaultProps = {
          playing: !0,
          format: [],
          xhr: {},
          mute: !1,
          preload: !0,
          loop: !1,
          volume: 1,
          rate: 1,
          onEnd: __webpack_require__.noop,
          onPause: __webpack_require__.noop,
          onPlay: __webpack_require__.noop,
          onPlayError: __webpack_require__.noop,
          onVolume: __webpack_require__.noop,
          onStop: __webpack_require__.noop,
          onLoad: __webpack_require__.noop,
          onSeek: __webpack_require__.noop,
          onLoadError: __webpack_require__.noop,
          html5: !1,
        }),
        (exports.default = ReactHowler);
    },
    7529: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var Howler = void 0;
      "undefined" != typeof window && (Howler = __webpack_require__(7472)),
        (module.exports = Howler);
    },
    8798: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(8996).default;
    },
    8719: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 });
      exports.noop = function noop() {};
    },
    8004: (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        A: () => __WEBPACK_DEFAULT_EXPORT__,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3696),
        page_flip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1352),
        __webpack_exports__ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
          (props, ref) => {
            const htmlElementRef = (0,
              react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),
              childRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]),
              pageFlip = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(),
              [pages, setPages] = (0,
              react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
              refreshOnPageDelete =
                ((0, react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(
                  ref,
                  () => ({ pageFlip: () => pageFlip.current })
                ),
                (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
                  pageFlip.current && pageFlip.current.clear();
                }, [])),
              removeHandlers = (0,
              react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
                var flip = pageFlip.current;
                flip &&
                  (flip.off("flip"),
                  flip.off("changeOrientation"),
                  flip.off("changeState"),
                  flip.off("init"),
                  flip.off("update"));
              }, []);
            return (
              (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
                var childList;
                (childRef.current = []),
                  props.children &&
                    ((childList =
                      react__WEBPACK_IMPORTED_MODULE_0__.Children.map(
                        props.children,
                        (child) =>
                          react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(
                            child,
                            {
                              ref: (dom) => {
                                dom && childRef.current.push(dom);
                              },
                            }
                          )
                      )),
                    (props.renderOnlyPageLengthChange &&
                      pages.length === childList.length) ||
                      (childList.length < pages.length && refreshOnPageDelete(),
                      setPages(childList)));
              }, [props.children]),
              (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
                var flip;
                0 < pages.length &&
                  0 < childRef.current.length &&
                  (removeHandlers(),
                  htmlElementRef.current &&
                    !pageFlip.current &&
                    (pageFlip.current =
                      new page_flip__WEBPACK_IMPORTED_MODULE_1__.PageFlip(
                        htmlElementRef.current,
                        props
                      )),
                  pageFlip.current.getFlipController()
                    ? pageFlip.current.updateFromHtml(childRef.current)
                    : pageFlip.current.loadFromHTML(childRef.current),
                  (flip = pageFlip.current)) &&
                  (props.onFlip && flip.on("flip", (e) => props.onFlip(e)),
                  props.onChangeOrientation &&
                    flip.on("changeOrientation", (e) =>
                      props.onChangeOrientation(e)
                    ),
                  props.onChangeState &&
                    flip.on("changeState", (e) => props.onChangeState(e)),
                  props.onInit && flip.on("init", (e) => props.onInit(e)),
                  props.onUpdate) &&
                  flip.on("update", (e) => props.onUpdate(e));
              }, [pages]),
              react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                "div",
                {
                  ref: htmlElementRef,
                  className: props.className,
                  style: props.style,
                },
                pages
              )
            );
          }
        );
      const __WEBPACK_DEFAULT_EXPORT__ =
        react__WEBPACK_IMPORTED_MODULE_0__.memo(__webpack_exports__);
    },
    4403: (__unused_webpack_module, exports) => {
      "use strict";
      var l = Symbol.for("react.element"),
        n = Symbol.for("react.portal"),
        p = Symbol.for("react.fragment"),
        q = Symbol.for("react.strict_mode"),
        r = Symbol.for("react.profiler"),
        t = Symbol.for("react.provider"),
        u = Symbol.for("react.context"),
        v = Symbol.for("react.forward_ref"),
        w = Symbol.for("react.suspense"),
        x = Symbol.for("react.memo"),
        y = Symbol.for("react.lazy"),
        z = Symbol.iterator;
      var B = {
          isMounted: function () {
            return !1;
          },
          enqueueForceUpdate: function () {},
          enqueueReplaceState: function () {},
          enqueueSetState: function () {},
        },
        C = Object.assign,
        D = {};
      function E(a, b, e) {
        (this.props = a),
          (this.context = b),
          (this.refs = D),
          (this.updater = e || B);
      }
      function F() {}
      function G(a, b, e) {
        (this.props = a),
          (this.context = b),
          (this.refs = D),
          (this.updater = e || B);
      }
      (E.prototype.isReactComponent = {}),
        (E.prototype.setState = function (a, b) {
          if ("object" != typeof a && "function" != typeof a && null != a)
            throw Error(
              "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, a, b, "setState");
        }),
        (E.prototype.forceUpdate = function (a) {
          this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        }),
        (F.prototype = E.prototype);
      var H = (G.prototype = new F()),
        I =
          ((H.constructor = G),
          C(H, E.prototype),
          (H.isPureReactComponent = !0),
          Array.isArray),
        J = Object.prototype.hasOwnProperty,
        K = { current: null },
        L = { key: !0, ref: !0, __self: !0, __source: !0 };
      function M(a, b, e) {
        var d,
          c = {},
          k = null,
          h = null;
        if (null != b)
          for (d in (void 0 !== b.ref && (h = b.ref),
          void 0 !== b.key && (k = "" + b.key),
          b))
            J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps)
          for (d in (g = a.defaultProps)) void 0 === c[d] && (c[d] = g[d]);
        return {
          $$typeof: l,
          type: a,
          key: k,
          ref: h,
          props: c,
          _owner: K.current,
        };
      }
      function O(a) {
        return "object" == typeof a && null !== a && a.$$typeof === l;
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" == typeof a && null !== a && null != a.key
          ? (function escape(a) {
              var b = { "=": "=0", ":": "=2" };
              return (
                "$" +
                a.replace(/[=:]/g, function (a) {
                  return b[a];
                })
              );
            })("" + a.key)
          : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var h = !1;
        if (
          null ===
          (a = "undefined" !== (k = typeof a) && "boolean" !== k ? a : null)
        )
          h = !0;
        else
          switch (k) {
            case "string":
            case "number":
              h = !0;
              break;
            case "object":
              switch (a.$$typeof) {
                case l:
                case n:
                  h = !0;
              }
          }
        if (h)
          return (
            (c = c((h = a))),
            (a = "" === d ? "." + Q(h, 0) : d),
            I(c)
              ? ((e = ""),
                R(
                  c,
                  b,
                  (e = null != a ? a.replace(P, "$&/") + "/" : e),
                  "",
                  function (a) {
                    return a;
                  }
                ))
              : null != c &&
                (O(c) &&
                  (c = (function N(a, b) {
                    return {
                      $$typeof: l,
                      type: a.type,
                      key: b,
                      ref: a.ref,
                      props: a.props,
                      _owner: a._owner,
                    };
                  })(
                    c,
                    e +
                      (!c.key || (h && h.key === c.key)
                        ? ""
                        : ("" + c.key).replace(P, "$&/") + "/") +
                      a
                  )),
                b.push(c)),
            1
          );
        if (((h = 0), (d = "" === d ? "." : d + ":"), I(a)))
          for (var g = 0; g < a.length; g++) {
            var k,
              f = d + Q((k = a[g]), g);
            h += R(k, b, e, f, c);
          }
        else if (
          "function" ==
          typeof (f = (function A(a) {
            return null !== a &&
              "object" == typeof a &&
              "function" == typeof (a = (z && a[z]) || a["@@iterator"])
              ? a
              : null;
          })(a))
        )
          for (a = f.call(a), g = 0; !(k = a.next()).done; )
            h += R((k = k.value), b, e, (f = d + Q(k, g++)), c);
        else if ("object" === k)
          throw (
            ((b = String(a)),
            Error(
              "Objects are not valid as a React child (found: " +
                ("[object Object]" === b
                  ? "object with keys {" + Object.keys(a).join(", ") + "}"
                  : b) +
                "). If you meant to render a collection of children, use an array instead."
            ))
          );
        return h;
      }
      function S(a, b, e) {
        var c;
        return (
          null == a ||
            ((c = 0),
            R(a, (a = []), "", "", function (a) {
              return b.call(e, a, c++);
            })),
          a
        );
      }
      function T(a) {
        var b;
        if (
          (-1 === a._status &&
            ((b = (b = a._result)()).then(
              function (b) {
                (0 !== a._status && -1 !== a._status) ||
                  ((a._status = 1), (a._result = b));
              },
              function (b) {
                (0 !== a._status && -1 !== a._status) ||
                  ((a._status = 2), (a._result = b));
              }
            ),
            -1 === a._status) &&
            ((a._status = 0), (a._result = b)),
          1 === a._status)
        )
          return a._result.default;
        throw a._result;
      }
      var U = { current: null },
        V = { transition: null },
        H = {
          ReactCurrentDispatcher: U,
          ReactCurrentBatchConfig: V,
          ReactCurrentOwner: K,
        };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      (exports.Children = {
        map: S,
        forEach: function (a, b, e) {
          S(
            a,
            function () {
              b.apply(this, arguments);
            },
            e
          );
        },
        count: function (a) {
          var b = 0;
          return (
            S(a, function () {
              b++;
            }),
            b
          );
        },
        toArray: function (a) {
          return (
            S(a, function (a) {
              return a;
            }) || []
          );
        },
        only: function (a) {
          if (O(a)) return a;
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        },
      }),
        (exports.Component = E),
        (exports.Fragment = p),
        (exports.Profiler = r),
        (exports.PureComponent = G),
        (exports.StrictMode = q),
        (exports.Suspense = w),
        (exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = H),
        (exports.act = X),
        (exports.cloneElement = function (a, b, e) {
          if (null == a)
            throw Error(
              "React.cloneElement(...): The argument must be a React element, but you passed " +
                a +
                "."
            );
          var d = C({}, a.props),
            c = a.key,
            k = a.ref,
            h = a._owner;
          if (null != b)
            for (f in (void 0 !== b.ref && ((k = b.ref), (h = K.current)),
            void 0 !== b.key && (c = "" + b.key),
            a.type && a.type.defaultProps && (g = a.type.defaultProps),
            b))
              J.call(b, f) &&
                !L.hasOwnProperty(f) &&
                (d[f] = (void 0 === b[f] && void 0 !== g ? g : b)[f]);
          var f = arguments.length - 2;
          if (1 === f) d.children = e;
          else if (1 < f) {
            for (var g = Array(f), m = 0; m < f; m++) g[m] = arguments[m + 2];
            d.children = g;
          }
          return {
            $$typeof: l,
            type: a.type,
            key: c,
            ref: k,
            props: d,
            _owner: h,
          };
        }),
        (exports.createContext = function (a) {
          return (
            ((a = {
              $$typeof: u,
              _currentValue: a,
              _currentValue2: a,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null,
            }).Provider = { $$typeof: t, _context: a }),
            (a.Consumer = a)
          );
        }),
        (exports.createElement = M),
        (exports.createFactory = function (a) {
          var b = M.bind(null, a);
          return (b.type = a), b;
        }),
        (exports.createRef = function () {
          return { current: null };
        }),
        (exports.forwardRef = function (a) {
          return { $$typeof: v, render: a };
        }),
        (exports.isValidElement = O),
        (exports.lazy = function (a) {
          return {
            $$typeof: y,
            _payload: { _status: -1, _result: a },
            _init: T,
          };
        }),
        (exports.memo = function (a, b) {
          return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
        }),
        (exports.startTransition = function (a) {
          var b = V.transition;
          V.transition = {};
          try {
            a();
          } finally {
            V.transition = b;
          }
        }),
        (exports.unstable_act = X),
        (exports.useCallback = function (a, b) {
          return U.current.useCallback(a, b);
        }),
        (exports.useContext = function (a) {
          return U.current.useContext(a);
        }),
        (exports.useDebugValue = function () {}),
        (exports.useDeferredValue = function (a) {
          return U.current.useDeferredValue(a);
        }),
        (exports.useEffect = function (a, b) {
          return U.current.useEffect(a, b);
        }),
        (exports.useId = function () {
          return U.current.useId();
        }),
        (exports.useImperativeHandle = function (a, b, e) {
          return U.current.useImperativeHandle(a, b, e);
        }),
        (exports.useInsertionEffect = function (a, b) {
          return U.current.useInsertionEffect(a, b);
        }),
        (exports.useLayoutEffect = function (a, b) {
          return U.current.useLayoutEffect(a, b);
        }),
        (exports.useMemo = function (a, b) {
          return U.current.useMemo(a, b);
        }),
        (exports.useReducer = function (a, b, e) {
          return U.current.useReducer(a, b, e);
        }),
        (exports.useRef = function (a) {
          return U.current.useRef(a);
        }),
        (exports.useState = function (a) {
          return U.current.useState(a);
        }),
        (exports.useSyncExternalStore = function (a, b, e) {
          return U.current.useSyncExternalStore(a, b, e);
        }),
        (exports.useTransition = function () {
          return U.current.useTransition();
        }),
        (exports.version = "18.3.1");
    },
    3696: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(4403);
    },
    1817: (module, exports, __webpack_require__) => {
      var buffer = __webpack_require__(8891),
        Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) dst[key] = src[key];
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      Buffer.from &&
      Buffer.alloc &&
      Buffer.allocUnsafe &&
      Buffer.allocUnsafeSlow
        ? (module.exports = buffer)
        : (copyProps(buffer, exports), (exports.Buffer = SafeBuffer)),
        (SafeBuffer.prototype = Object.create(Buffer.prototype)),
        copyProps(Buffer, SafeBuffer),
        (SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if ("number" == typeof arg)
            throw new TypeError("Argument must not be a number");
          return Buffer(arg, encodingOrOffset, length);
        }),
        (SafeBuffer.alloc = function (size, fill, encoding) {
          if ("number" != typeof size)
            throw new TypeError("Argument must be a number");
          size = Buffer(size);
          return (
            void 0 !== fill
              ? "string" == typeof encoding
                ? size.fill(fill, encoding)
                : size.fill(fill)
              : size.fill(0),
            size
          );
        }),
        (SafeBuffer.allocUnsafe = function (size) {
          if ("number" != typeof size)
            throw new TypeError("Argument must be a number");
          return Buffer(size);
        }),
        (SafeBuffer.allocUnsafeSlow = function (size) {
          if ("number" != typeof size)
            throw new TypeError("Argument must be a number");
          return buffer.SlowBuffer(size);
        });
    },
    7699: (__unused_webpack_module, exports) => {
      "use strict";
      function f(a, b) {
        var c = a.length;
        for (a.push(b); 0 < c; ) {
          var d = (c - 1) >>> 1,
            e = a[d];
          if (!(0 < g(e, b))) break;
          (a[d] = b), (a[c] = e), (c = d);
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 !== a.length) {
          var b = a[0],
            c = a.pop();
          if (c !== b) {
            a[0] = c;
            for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
              var m = 2 * (d + 1) - 1,
                C = a[m],
                n = 1 + m,
                x = a[n];
              if (g(C, c) < 0)
                d =
                  n < e && g(x, C) < 0
                    ? ((a[d] = x), (a[n] = c), n)
                    : ((a[d] = C), (a[m] = c), m);
              else {
                if (!(n < e && g(x, c) < 0)) break;
                (a[d] = x), (a[n] = c), (d = n);
              }
            }
          }
        }
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 != c ? c : a.id - b.id;
      }
      "object" == typeof performance && "function" == typeof performance.now
        ? ((l = performance),
          (exports.unstable_now = function () {
            return l.now();
          }))
        : ((p = Date),
          (q = p.now()),
          (exports.unstable_now = function () {
            return p.now() - q;
          }));
      var l,
        p,
        q,
        r = [],
        t = [],
        u = 1,
        v = null,
        y = 3,
        z = !1,
        A = !1,
        B = !1,
        D = "function" == typeof setTimeout ? setTimeout : null,
        E = "function" == typeof clearTimeout ? clearTimeout : null,
        F = "undefined" != typeof setImmediate ? setImmediate : null;
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else {
            if (!(b.startTime <= a)) break;
            k(t), (b.sortIndex = b.expirationTime), f(r, b);
          }
          b = h(t);
        }
      }
      function H(a) {
        var b;
        (B = !1),
          G(a),
          A ||
            (null !== h(r)
              ? ((A = !0), I(J))
              : null !== (b = h(t)) && K(H, b.startTime - a));
      }
      function J(a, b) {
        (A = !1), B && ((B = !1), E(L), (L = -1)), (z = !0);
        var c = y;
        try {
          for (
            G(b), v = h(r);
            null !== v && (!(v.expirationTime > b) || (a && !M()));

          ) {
            var e,
              d = v.callback;
            "function" == typeof d
              ? ((v.callback = null),
                (y = v.priorityLevel),
                (e = d(v.expirationTime <= b)),
                (b = exports.unstable_now()),
                "function" == typeof e ? (v.callback = e) : v === h(r) && k(r),
                G(b))
              : k(r),
              (v = h(r));
          }
          var m,
            w =
              null !== v || (null !== (m = h(t)) && K(H, m.startTime - b), !1);
          return w;
        } finally {
          (v = null), (y = c), (z = !1);
        }
      }
      "undefined" != typeof navigator &&
        void 0 !== navigator.scheduling &&
        void 0 !== navigator.scheduling.isInputPending &&
        navigator.scheduling.isInputPending.bind(navigator.scheduling);
      var S,
        T,
        U,
        N = !1,
        O = null,
        L = -1,
        P = 5,
        Q = -1;
      function M() {
        return !(exports.unstable_now() - Q < P);
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now(),
            b = ((Q = a), !0);
          try {
            b = O(!0, a);
          } finally {
            b ? S() : ((N = !1), (O = null));
          }
        } else N = !1;
      }
      function I(a) {
        (O = a), N || ((N = !0), S());
      }
      function K(a, b) {
        L = D(function () {
          a(exports.unstable_now());
        }, b);
      }
      (S =
        "function" == typeof F
          ? function () {
              F(R);
            }
          : "undefined" != typeof MessageChannel
          ? ((T = new MessageChannel()),
            (U = T.port2),
            (T.port1.onmessage = R),
            function () {
              U.postMessage(null);
            })
          : function () {
              D(R, 0);
            }),
        (exports.unstable_IdlePriority = 5),
        (exports.unstable_ImmediatePriority = 1),
        (exports.unstable_LowPriority = 4),
        (exports.unstable_NormalPriority = 3),
        (exports.unstable_Profiling = null),
        (exports.unstable_UserBlockingPriority = 2),
        (exports.unstable_cancelCallback = function (a) {
          a.callback = null;
        }),
        (exports.unstable_continueExecution = function () {
          A || z || ((A = !0), I(J));
        }),
        (exports.unstable_forceFrameRate = function (a) {
          a < 0 || 125 < a
            ? console.error(
                "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
              )
            : (P = 0 < a ? Math.floor(1e3 / a) : 5);
        }),
        (exports.unstable_getCurrentPriorityLevel = function () {
          return y;
        }),
        (exports.unstable_getFirstCallbackNode = function () {
          return h(r);
        }),
        (exports.unstable_next = function (a) {
          switch (y) {
            case 1:
            case 2:
            case 3:
              var b = 3;
              break;
            default:
              b = y;
          }
          var c = y;
          y = b;
          try {
            return a();
          } finally {
            y = c;
          }
        }),
        (exports.unstable_pauseExecution = function () {}),
        (exports.unstable_requestPaint = function () {}),
        (exports.unstable_runWithPriority = function (a, b) {
          switch (a) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              a = 3;
          }
          var c = y;
          y = a;
          try {
            return b();
          } finally {
            y = c;
          }
        }),
        (exports.unstable_scheduleCallback = function (a, b, c) {
          var d = exports.unstable_now();
          switch (
            ((c =
              "object" == typeof c &&
              null !== c &&
              "number" == typeof (c = c.delay) &&
              0 < c
                ? d + c
                : d),
            a)
          ) {
            case 1:
              var e = -1;
              break;
            case 2:
              e = 250;
              break;
            case 5:
              e = 1073741823;
              break;
            case 4:
              e = 1e4;
              break;
            default:
              e = 5e3;
          }
          return (
            (a = {
              id: u++,
              callback: b,
              priorityLevel: a,
              startTime: c,
              expirationTime: (e = c + e),
              sortIndex: -1,
            }),
            d < c
              ? ((a.sortIndex = c),
                f(t, a),
                null === h(r) &&
                  a === h(t) &&
                  (B ? (E(L), (L = -1)) : (B = !0), K(H, c - d)))
              : ((a.sortIndex = e), f(r, a), A || z || ((A = !0), I(J))),
            a
          );
        }),
        (exports.unstable_shouldYield = M),
        (exports.unstable_wrapCallback = function (a) {
          var b = y;
          return function () {
            var c = y;
            y = b;
            try {
              return a.apply(this, arguments);
            } finally {
              y = c;
            }
          };
        });
    },
    1434: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(7699);
    },
    6261: (__unused_webpack_module, exports) => {
      "use strict";
      function inRange(a, min, max) {
        return min <= a && a <= max;
      }
      function ToDictionary(o) {
        if (void 0 === o) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream.prototype = {
        endOfStream: function () {
          return !this.tokens.length;
        },
        read: function () {
          return this.tokens.length ? this.tokens.shift() : -1;
        },
        prepend: function (token) {
          if (Array.isArray(token))
            for (var tokens = token; tokens.length; )
              this.tokens.unshift(tokens.pop());
          else this.tokens.unshift(token);
        },
        push: function (token) {
          if (Array.isArray(token))
            for (var tokens = token; tokens.length; )
              this.tokens.push(tokens.shift());
          else this.tokens.push(token);
        },
      };
      function decoderError(fatal, opt_code_point) {
        if (fatal) throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      function TextDecoder(encoding, options) {
        if (!(this instanceof TextDecoder))
          return new TextDecoder(encoding, options);
        if (
          "utf-8" !==
          (encoding =
            void 0 !== encoding ? String(encoding).toLowerCase() : "utf-8")
        )
          throw new Error("Encoding not supported. Only utf-8 is supported");
        (options = ToDictionary(options)),
          (this._streaming = !1),
          (this._BOMseen = !1),
          (this._decoder = null),
          (this._fatal = Boolean(options.fatal)),
          (this._ignoreBOM = Boolean(options.ignoreBOM)),
          Object.defineProperty(this, "encoding", { value: "utf-8" }),
          Object.defineProperty(this, "fatal", { value: this._fatal }),
          Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      function TextEncoder(encoding, options) {
        if (!(this instanceof TextEncoder))
          return new TextEncoder(encoding, options);
        if (
          "utf-8" !==
          (encoding =
            void 0 !== encoding ? String(encoding).toLowerCase() : "utf-8")
        )
          throw new Error("Encoding not supported. Only utf-8 is supported");
        (options = ToDictionary(options)),
          (this._streaming = !1),
          (this._encoder = null),
          (this._options = { fatal: Boolean(options.fatal) }),
          Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      function UTF8Decoder(options) {
        var fatal = options.fatal,
          utf8_code_point = 0,
          utf8_bytes_seen = 0,
          utf8_bytes_needed = 0,
          utf8_lower_boundary = 128,
          utf8_upper_boundary = 191;
        this.handler = function (stream, bite) {
          if (-1 === bite && 0 !== utf8_bytes_needed)
            return (utf8_bytes_needed = 0), decoderError(fatal);
          if (-1 === bite) return -1;
          if (0 === utf8_bytes_needed) {
            if (inRange(bite, 0, 127)) return bite;
            if (inRange(bite, 194, 223))
              (utf8_bytes_needed = 1), (utf8_code_point = bite - 192);
            else if (inRange(bite, 224, 239))
              224 === bite && (utf8_lower_boundary = 160),
                237 === bite && (utf8_upper_boundary = 159),
                (utf8_bytes_needed = 2),
                (utf8_code_point = bite - 224);
            else {
              if (!inRange(bite, 240, 244)) return decoderError(fatal);
              240 === bite && (utf8_lower_boundary = 144),
                244 === bite && (utf8_upper_boundary = 143),
                (utf8_bytes_needed = 3),
                (utf8_code_point = bite - 240);
            }
            return (utf8_code_point <<= 6 * utf8_bytes_needed), null;
          }
          var code_point;
          return inRange(bite, utf8_lower_boundary, utf8_upper_boundary)
            ? ((utf8_upper_boundary = 191),
              (utf8_code_point +=
                (bite - (utf8_lower_boundary = 128)) <<
                (6 * (utf8_bytes_needed - (utf8_bytes_seen += 1)))),
              utf8_bytes_seen !== utf8_bytes_needed
                ? null
                : ((code_point = utf8_code_point),
                  (utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0),
                  code_point))
            : ((utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0),
              (utf8_lower_boundary = 128),
              (utf8_upper_boundary = 191),
              stream.prepend(bite),
              decoderError(fatal));
        };
      }
      function UTF8Encoder(options) {
        options.fatal;
        this.handler = function (stream, code_point) {
          if (-1 === code_point) return -1;
          if (inRange(code_point, 0, 127)) return code_point;
          inRange(code_point, 128, 2047)
            ? ((count = 1), (offset = 192))
            : inRange(code_point, 2048, 65535)
            ? ((count = 2), (offset = 224))
            : inRange(code_point, 65536, 1114111) &&
              ((count = 3), (offset = 240));
          for (
            var count, offset, bytes = [(code_point >> (6 * count)) + offset];
            0 < count;

          )
            bytes.push(128 | (63 & (code_point >> (6 * (count - 1))))), --count;
          return bytes;
        };
      }
      (TextDecoder.prototype = {
        decode: function decode(input, options) {
          input =
            "object" == typeof input && input instanceof ArrayBuffer
              ? new Uint8Array(input)
              : "object" == typeof input &&
                "buffer" in input &&
                input.buffer instanceof ArrayBuffer
              ? new Uint8Array(input.buffer, input.byteOffset, input.byteLength)
              : new Uint8Array(0);
          (options = ToDictionary(options)),
            this._streaming ||
              ((this._decoder = new UTF8Decoder({ fatal: this._fatal })),
              (this._BOMseen = !1)),
            (this._streaming = Boolean(options.stream));
          for (
            var result, input_stream = new Stream(input), code_points = [];
            !input_stream.endOfStream() &&
            -1 !==
              (result = this._decoder.handler(
                input_stream,
                input_stream.read()
              ));

          )
            null !== result &&
              (Array.isArray(result)
                ? code_points.push.apply(code_points, result)
                : code_points.push(result));
          if (!this._streaming) {
            for (
              ;
              -1 !==
                (result = this._decoder.handler(
                  input_stream,
                  input_stream.read()
                )) &&
              (null !== result &&
                (Array.isArray(result)
                  ? code_points.push.apply(code_points, result)
                  : code_points.push(result)),
              !input_stream.endOfStream());

            );
            this._decoder = null;
          }
          return (
            !code_points.length ||
              -1 === ["utf-8"].indexOf(this.encoding) ||
              this._ignoreBOM ||
              this._BOMseen ||
              (65279 === code_points[0]
                ? ((this._BOMseen = !0), code_points.shift())
                : (this._BOMseen = !0)),
            (function codePointsToString(code_points) {
              for (var s = "", i = 0; i < code_points.length; ++i) {
                var cp = code_points[i];
                cp <= 65535
                  ? (s += String.fromCharCode(cp))
                  : ((cp -= 65536),
                    (s += String.fromCharCode(
                      55296 + (cp >> 10),
                      56320 + (1023 & cp)
                    )));
              }
              return s;
            })(code_points)
          );
        },
      }),
        (TextEncoder.prototype = {
          encode: function encode(opt_string, options) {
            (opt_string = opt_string ? String(opt_string) : ""),
              (options = ToDictionary(options)),
              this._streaming ||
                (this._encoder = new UTF8Encoder(this._options)),
              (this._streaming = Boolean(options.stream));
            for (
              var result,
                bytes = [],
                input_stream = new Stream(
                  (function stringToCodePoints(string) {
                    for (
                      var s = String(string), n = s.length, i = 0, u = [];
                      i < n;

                    ) {
                      var d,
                        c = s.charCodeAt(i);
                      c < 55296 || 57343 < c
                        ? u.push(c)
                        : 56320 <= c && c <= 57343
                        ? u.push(65533)
                        : 55296 <= c &&
                          c <= 56319 &&
                          (i !== n - 1 &&
                          56320 <= (d = string.charCodeAt(i + 1)) &&
                          d <= 57343
                            ? (u.push(65536 + ((1023 & c) << 10) + (1023 & d)),
                              (i += 1))
                            : u.push(65533)),
                        (i += 1);
                    }
                    return u;
                  })(opt_string)
                );
              !input_stream.endOfStream() &&
              -1 !==
                (result = this._encoder.handler(
                  input_stream,
                  input_stream.read()
                ));

            )
              Array.isArray(result)
                ? bytes.push.apply(bytes, result)
                : bytes.push(result);
            if (!this._streaming) {
              for (;;) {
                if (
                  -1 ===
                  (result = this._encoder.handler(
                    input_stream,
                    input_stream.read()
                  ))
                )
                  break;
                Array.isArray(result)
                  ? bytes.push.apply(bytes, result)
                  : bytes.push(result);
              }
              this._encoder = null;
            }
            return new Uint8Array(bytes);
          },
        }),
        (exports.TextEncoder = TextEncoder),
        (exports.TextDecoder = TextDecoder);
    },
    2793: (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, { v4: () => esm_browser_v4 });
      var getRandomValues,
        rnds8 = new Uint8Array(16);
      const regex =
        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      const esm_browser_validate = function validate(uuid) {
        return "string" == typeof uuid && regex.test(uuid);
      };
      for (var byteToHex = [], i = 0; i < 256; ++i)
        byteToHex.push((i + 256).toString(16).substr(1));
      const esm_browser_stringify = function stringify(arr) {
        var offset =
            1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
          arr = (
            byteToHex[arr[offset + 0]] +
            byteToHex[arr[offset + 1]] +
            byteToHex[arr[offset + 2]] +
            byteToHex[arr[offset + 3]] +
            "-" +
            byteToHex[arr[offset + 4]] +
            byteToHex[arr[offset + 5]] +
            "-" +
            byteToHex[arr[offset + 6]] +
            byteToHex[arr[offset + 7]] +
            "-" +
            byteToHex[arr[offset + 8]] +
            byteToHex[arr[offset + 9]] +
            "-" +
            byteToHex[arr[offset + 10]] +
            byteToHex[arr[offset + 11]] +
            byteToHex[arr[offset + 12]] +
            byteToHex[arr[offset + 13]] +
            byteToHex[arr[offset + 14]] +
            byteToHex[arr[offset + 15]]
          ).toLowerCase();
        if (esm_browser_validate(arr)) return arr;
        throw TypeError("Stringified UUID is invalid");
      };
      const esm_browser_v4 = function v4(options, buf, offset) {
        var rnds =
          (options = options || {}).random ||
          (
            options.rng ||
            function rng() {
              if (
                (getRandomValues =
                  getRandomValues ||
                  ("undefined" != typeof crypto &&
                    crypto.getRandomValues &&
                    crypto.getRandomValues.bind(crypto)) ||
                  ("undefined" != typeof msCrypto &&
                    "function" == typeof msCrypto.getRandomValues &&
                    msCrypto.getRandomValues.bind(msCrypto)))
              )
                return getRandomValues(rnds8);
              throw new Error(
                "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
              );
            }
          )();
        if (
          ((rnds[6] = (15 & rnds[6]) | 64),
          (rnds[8] = (63 & rnds[8]) | 128),
          buf)
        ) {
          offset = offset || 0;
          for (var i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
          return buf;
        }
        return esm_browser_stringify(rnds);
      };
    },
    1293: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var eventemitter3_1 = __webpack_require__(792);
      const utils_cjs_1 = __webpack_require__(4895);
      class CommonClient extends eventemitter3_1.EventEmitter {
        address;
        rpc_id;
        queue;
        options;
        autoconnect;
        ready;
        reconnect;
        reconnect_timer_id;
        reconnect_interval;
        max_reconnects;
        rest_options;
        current_reconnects;
        generate_request_id;
        socket;
        webSocketFactory;
        dataPack;
        constructor(
          webSocketFactory,
          address = "ws://localhost:8080",
          {
            autoconnect = !0,
            reconnect = !0,
            reconnect_interval = 1e3,
            max_reconnects = 5,
            ...rest_options
          } = {},
          generate_request_id,
          dataPack
        ) {
          super(),
            (this.webSocketFactory = webSocketFactory),
            (this.queue = {}),
            (this.rpc_id = 0),
            (this.address = address),
            (this.autoconnect = autoconnect),
            (this.ready = !1),
            (this.reconnect = reconnect),
            (this.reconnect_timer_id = void 0),
            (this.reconnect_interval = reconnect_interval),
            (this.max_reconnects = max_reconnects),
            (this.rest_options = rest_options),
            (this.current_reconnects = 0),
            (this.generate_request_id =
              generate_request_id || (() => ++this.rpc_id)),
            (this.dataPack = dataPack || new utils_cjs_1.DefaultDataPack()),
            this.autoconnect &&
              this._connect(this.address, {
                autoconnect: this.autoconnect,
                reconnect: this.reconnect,
                reconnect_interval: this.reconnect_interval,
                max_reconnects: this.max_reconnects,
                ...this.rest_options,
              });
        }
        connect() {
          this.socket ||
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options,
            });
        }
        call(method, params, timeout, ws_opts) {
          return (
            ws_opts ||
              "object" != typeof timeout ||
              ((ws_opts = timeout), (timeout = null)),
            new Promise((resolve, reject) => {
              if (!this.ready) return reject(new Error("socket not ready"));
              const rpc_id = this.generate_request_id(method, params);
              var message = {
                jsonrpc: "2.0",
                method: method,
                params: params || void 0,
                id: rpc_id,
              };
              this.socket.send(
                this.dataPack.encode(message),
                ws_opts,
                (error) => {
                  if (error) return reject(error);
                  (this.queue[rpc_id] = { promise: [resolve, reject] }),
                    timeout &&
                      (this.queue[rpc_id].timeout = setTimeout(() => {
                        delete this.queue[rpc_id],
                          reject(new Error("reply timeout"));
                      }, timeout));
                }
              );
            })
          );
        }
        async login(params) {
          params = await this.call("rpc.login", params);
          if (params) return params;
          throw new Error("authentication failed");
        }
        async listMethods() {
          return this.call("__listMethods");
        }
        notify(method, params) {
          return new Promise((resolve, reject) => {
            if (!this.ready) return reject(new Error("socket not ready"));
            this.socket.send(
              this.dataPack.encode({
                jsonrpc: "2.0",
                method: method,
                params: params,
              }),
              (error) => {
                if (error) return reject(error);
                resolve();
              }
            );
          });
        }
        async subscribe(event) {
          var result = await this.call(
            "rpc.on",
            (event = "string" == typeof event ? [event] : event)
          );
          if ("string" == typeof event && "ok" !== result[event])
            throw new Error(
              "Failed subscribing to an event '" +
                event +
                "' with: " +
                result[event]
            );
          return result;
        }
        async unsubscribe(event) {
          var result = await this.call(
            "rpc.off",
            (event = "string" == typeof event ? [event] : event)
          );
          if ("string" == typeof event && "ok" !== result[event])
            throw new Error(
              "Failed unsubscribing from an event with: " + result
            );
          return result;
        }
        close(code, data) {
          this.socket.close(code || 1e3, data);
        }
        setAutoReconnect(reconnect) {
          this.reconnect = reconnect;
        }
        setReconnectInterval(interval) {
          this.reconnect_interval = interval;
        }
        setMaxReconnects(max_reconnects) {
          this.max_reconnects = max_reconnects;
        }
        _connect(address, options) {
          clearTimeout(this.reconnect_timer_id),
            (this.socket = this.webSocketFactory(address, options)),
            this.socket.addEventListener("open", () => {
              (this.ready = !0),
                this.emit("open"),
                (this.current_reconnects = 0);
            }),
            this.socket.addEventListener("message", ({ data: message }) => {
              message instanceof ArrayBuffer &&
                (message = Buffer.from(message).toString());
              try {
                message = this.dataPack.decode(message);
              } catch (error) {
                return;
              }
              if (
                message.notification &&
                this.listeners(message.notification).length
              ) {
                if (!Object.keys(message.params).length)
                  return this.emit(message.notification);
                const args = [message.notification];
                if (message.params.constructor === Object)
                  args.push(message.params);
                else
                  for (let i = 0; i < message.params.length; i++)
                    args.push(message.params[i]);
                return Promise.resolve().then(() => {
                  this.emit.apply(this, args);
                });
              }
              if (!this.queue[message.id])
                return message.method
                  ? Promise.resolve().then(() => {
                      this.emit(message.method, message?.params);
                    })
                  : void 0;
              "error" in message == "result" in message &&
                this.queue[message.id].promise[1](
                  new Error(
                    'Server response malformed. Response must include either "result" or "error", but not both.'
                  )
                ),
                this.queue[message.id].timeout &&
                  clearTimeout(this.queue[message.id].timeout),
                message.error
                  ? this.queue[message.id].promise[1](message.error)
                  : this.queue[message.id].promise[0](message.result),
                delete this.queue[message.id];
            }),
            this.socket.addEventListener("error", (error) =>
              this.emit("error", error)
            ),
            this.socket.addEventListener("close", ({ code, reason }) => {
              this.ready &&
                setTimeout(() => this.emit("close", code, reason), 0),
                (this.ready = !1),
                (this.socket = void 0),
                1e3 !== code &&
                  (this.current_reconnects++, this.reconnect) &&
                  (this.max_reconnects > this.current_reconnects ||
                    0 === this.max_reconnects) &&
                  (this.reconnect_timer_id = setTimeout(
                    () => this._connect(address, options),
                    this.reconnect_interval
                  ));
            });
        }
      }
      exports.A = CommonClient;
    },
    5859: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      class WebSocketBrowserImpl extends __webpack_require__(792).EventEmitter {
        socket;
        constructor(address, options, protocols) {
          super(),
            (this.socket = new window.WebSocket(address, protocols)),
            (this.socket.onopen = () => this.emit("open")),
            (this.socket.onmessage = (event) =>
              this.emit("message", event.data)),
            (this.socket.onerror = (error) => this.emit("error", error)),
            (this.socket.onclose = (event) => {
              this.emit("close", event.code, event.reason);
            });
        }
        send(data, optionsOrCallback, callback) {
          callback = callback || optionsOrCallback;
          try {
            this.socket.send(data), callback();
          } catch (error) {
            callback(error);
          }
        }
        close(code, reason) {
          this.socket.close(code, reason);
        }
        addEventListener(type, listener, options) {
          this.socket.addEventListener(type, listener, options);
        }
      }
      exports.A = function default_1(address, options) {
        return new WebSocketBrowserImpl(address, options);
      };
    },
    4895: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }),
        (exports.createError = exports.DefaultDataPack = void 0);
      const errors = new Map([
        [-32e3, "Event not provided"],
        [-32600, "Invalid Request"],
        [-32601, "Method not found"],
        [-32602, "Invalid params"],
        [-32603, "Internal error"],
        [-32604, "Params not found"],
        [-32605, "Method forbidden"],
        [-32606, "Event forbidden"],
        [-32700, "Parse error"],
      ]);
      (exports.DefaultDataPack = class DefaultDataPack {
        encode(value) {
          return JSON.stringify(value);
        }
        decode(value) {
          return JSON.parse(value);
        }
      }),
        (exports.createError = function createError(code, details) {
          return (
            (code = {
              code: code,
              message: errors.get(code) || "Internal Server Error",
            }),
            details && (code.data = details),
            code
          );
        });
    },
    8716: (
      __unused_webpack___webpack_module__,
      __unused_webpack___webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      var react = __webpack_require__(3696);
      function _assertThisInitialized(self) {
        if (void 0 === self)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return self;
      }
      function _inheritsLoose(subClass, superClass) {
        (subClass.prototype = Object.create(superClass.prototype)),
          ((subClass.prototype.constructor = subClass).__proto__ = superClass);
      }
      function _isNotFalse(value) {
        return !1 !== value;
      }
      function _windowExists() {
        return "undefined" != typeof window;
      }
      function _isFuncOrString(value) {
        return _isFunction(value) || _isString(value);
      }
      function _install(scope) {
        return (_installScope = _merge(scope, _globals)) && gsap;
      }
      function _addGlobal(name, obj) {
        return (
          (name &&
            (_globals[name] = obj) &&
            _installScope &&
            (_installScope[name] = obj)) ||
          _globals
        );
      }
      function _emptyFunc() {
        return 0;
      }
      function _forEachName(names, func) {
        return (names = names.split(",")).forEach(func) || names;
      }
      function _arrayContainsAny(toSearch, toFind) {
        for (
          var l = toFind.length, i = 0;
          toSearch.indexOf(toFind[i]) < 0 && ++i < l;

        );
        return i < l;
      }
      function _lazySafeRender(animation, time, suppressEvents, force) {
        _lazyTweens.length && !_reverting && _lazyRender(),
          animation.render(
            time,
            suppressEvents,
            force ||
              (_reverting &&
                time < 0 &&
                (animation._initted || animation._startAt))
          ),
          _lazyTweens.length && !_reverting && _lazyRender();
      }
      function _numericIfPossible(value) {
        var n = parseFloat(value);
        return (n || 0 === n) &&
          (value + "").match(_delimitedValueExp).length < 2
          ? n
          : _isString(value)
          ? value.trim()
          : value;
      }
      function _passThrough(p) {
        return p;
      }
      function _setDefaults(obj, defaults) {
        for (var p in defaults) p in obj || (obj[p] = defaults[p]);
        return obj;
      }
      function _setKeyframeDefaults(excludeDuration) {
        return function (obj, defaults) {
          for (var p in defaults)
            p in obj ||
              ("duration" === p && excludeDuration) ||
              "ease" === p ||
              (obj[p] = defaults[p]);
        };
      }
      function _merge(base, toMerge) {
        for (var p in toMerge) base[p] = toMerge[p];
        return base;
      }
      function _mergeDeep(base, toMerge) {
        for (var p in toMerge)
          "__proto__" !== p &&
            "constructor" !== p &&
            "prototype" !== p &&
            (base[p] = _isObject(toMerge[p])
              ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p])
              : toMerge[p]);
        return base;
      }
      function _copyExcluding(obj, excluding) {
        var p,
          copy = {};
        for (p in obj) p in excluding || (copy[p] = obj[p]);
        return copy;
      }
      function _inheritDefaults(vars) {
        var parent = vars.parent || _globalTimeline,
          func = vars.keyframes
            ? _setKeyframeDefaults(_isArray(vars.keyframes))
            : _setDefaults;
        if (_isNotFalse(vars.inherit))
          for (; parent; )
            func(vars, parent.vars.defaults),
              (parent = parent.parent || parent._dp);
        return vars;
      }
      function _arraysMatch(a1, a2) {
        for (
          var i = a1.length, match = i === a2.length;
          match && i-- && a1[i] === a2[i];

        );
        return i < 0;
      }
      function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
        void 0 === firstProp && (firstProp = "_first");
        var t,
          prev = parent[(lastProp = void 0 === lastProp ? "_last" : lastProp)];
        if (sortBy)
          for (t = child[sortBy]; prev && prev[sortBy] > t; ) prev = prev._prev;
        return (
          prev
            ? ((child._next = prev._next), (prev._next = child))
            : ((child._next = parent[firstProp]), (parent[firstProp] = child)),
          child._next
            ? (child._next._prev = child)
            : (parent[lastProp] = child),
          (child._prev = prev),
          (child.parent = child._dp = parent),
          child
        );
      }
      function _removeLinkedListItem(parent, child, firstProp, lastProp) {
        void 0 === firstProp && (firstProp = "_first"),
          void 0 === lastProp && (lastProp = "_last");
        var prev = child._prev,
          next = child._next;
        prev
          ? (prev._next = next)
          : parent[firstProp] === child && (parent[firstProp] = next),
          next
            ? (next._prev = prev)
            : parent[lastProp] === child && (parent[lastProp] = prev),
          (child._next = child._prev = child.parent = null);
      }
      function _removeFromParent(child, onlyIfParentHasAutoRemove) {
        child.parent &&
          (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) &&
          child.parent.remove &&
          child.parent.remove(child),
          (child._act = 0);
      }
      function _recacheAncestors(animation) {
        for (var parent = animation.parent; parent && parent.parent; )
          (parent._dirty = 1), parent.totalDuration(), (parent = parent.parent);
        return animation;
      }
      function _rewindStartAt(tween, totalTime, suppressEvents, force) {
        return (
          tween._startAt &&
          (_reverting
            ? tween._startAt.revert(_revertConfigNoKill)
            : (tween.vars.immediateRender && !tween.vars.autoRevert) ||
              tween._startAt.render(totalTime, !0, force))
        );
      }
      function _hasNoPausedAncestors(animation) {
        return (
          !animation ||
          (animation._ts && _hasNoPausedAncestors(animation.parent))
        );
      }
      function _elapsedCycleDuration(animation) {
        return animation._repeat
          ? _animationCycle(
              animation._tTime,
              (animation = animation.duration() + animation._rDelay)
            ) * animation
          : 0;
      }
      function _animationCycle(tTime, cycleDuration) {
        return (
          (cycleDuration = Math.floor((tTime /= cycleDuration))),
          tTime && cycleDuration === tTime ? cycleDuration - 1 : cycleDuration
        );
      }
      function _parentToChildTotalTime(parentTime, child) {
        return (
          (parentTime - child._start) * child._ts +
          (0 <= child._ts
            ? 0
            : child._dirty
            ? child.totalDuration()
            : child._tDur)
        );
      }
      function _postAddChecks(timeline, child) {
        var t;
        if (
          ((child._time ||
            (!child._dur && child._initted) ||
            (child._start < timeline._time && (child._dur || !child.add))) &&
            ((t = _parentToChildTotalTime(timeline.rawTime(), child)),
            !child._dur ||
              _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) &&
            child.render(t, !0),
          _uncache(timeline, child)._dp &&
            timeline._initted &&
            timeline._time >= timeline._dur &&
            timeline._ts)
        ) {
          if (timeline._dur < timeline.duration())
            for (t = timeline; t._dp; )
              0 <= t.rawTime() && t.totalTime(t._tTime), (t = t._dp);
          timeline._zTime = -_tinyNum;
        }
      }
      function _addToTimeline(timeline, child, position, skipChecks) {
        return (
          child.parent && _removeFromParent(child),
          (child._start = _roundPrecise(
            (_isNumber(position)
              ? position
              : position || timeline !== _globalTimeline
              ? _parsePosition(timeline, position, child)
              : timeline._time) + child._delay
          )),
          (child._end = _roundPrecise(
            child._start +
              (child.totalDuration() / Math.abs(child.timeScale()) || 0)
          )),
          _addLinkedListItem(
            timeline,
            child,
            "_first",
            "_last",
            timeline._sort ? "_start" : 0
          ),
          _isFromOrFromStart(child) || (timeline._recent = child),
          skipChecks || _postAddChecks(timeline, child),
          timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime),
          timeline
        );
      }
      function _scrollTrigger(animation, trigger) {
        return (
          (_globals.ScrollTrigger ||
            _missingPlugin("scrollTrigger", trigger)) &&
          _globals.ScrollTrigger.create(trigger, animation)
        );
      }
      function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
        return (
          _initTween(tween, time, tTime),
          tween._initted
            ? !force &&
              tween._pt &&
              !_reverting &&
              ((tween._dur && !1 !== tween.vars.lazy) ||
                (!tween._dur && tween.vars.lazy)) &&
              _lastRenderedFrame !== _ticker.frame
              ? (_lazyTweens.push(tween),
                (tween._lazy = [tTime, suppressEvents]),
                1)
              : void 0
            : 1
        );
      }
      function _parentPlayheadIsBeforeStart(_ref) {
        return (
          (_ref = _ref.parent) &&
          _ref._ts &&
          _ref._initted &&
          !_ref._lock &&
          (_ref.rawTime() < 0 || _parentPlayheadIsBeforeStart(_ref))
        );
      }
      function _isFromOrFromStart(_ref2) {
        return "isFromStart" === (_ref2 = _ref2.data) || "isStart" === _ref2;
      }
      function _renderZeroDurationTween(
        tween,
        totalTime,
        suppressEvents,
        force
      ) {
        var pt,
          iteration,
          prevRatio = tween.ratio,
          ratio =
            totalTime < 0 ||
            (!totalTime &&
              ((!tween._start &&
                _parentPlayheadIsBeforeStart(tween) &&
                (tween._initted || !_isFromOrFromStart(tween))) ||
                ((tween._ts < 0 || tween._dp._ts < 0) &&
                  !_isFromOrFromStart(tween))))
              ? 0
              : 1,
          repeatDelay = tween._rDelay,
          tTime = 0;
        if (
          (repeatDelay &&
            tween._repeat &&
            ((tTime = _clamp(0, tween._tDur, totalTime)),
            (iteration = _animationCycle(tTime, repeatDelay)),
            tween._yoyo && 1 & iteration && (ratio = 1 - ratio),
            iteration !== _animationCycle(tween._tTime, repeatDelay)) &&
            ((prevRatio = 1 - ratio), tween.vars.repeatRefresh) &&
            tween._initted &&
            tween.invalidate(),
          ratio !== prevRatio ||
            _reverting ||
            force ||
            tween._zTime === _tinyNum ||
            (!totalTime && tween._zTime))
        ) {
          if (
            tween._initted ||
            !_attemptInitTween(tween, totalTime, force, suppressEvents, tTime)
          ) {
            for (
              iteration = tween._zTime,
                tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0),
                suppressEvents = suppressEvents || (totalTime && !iteration),
                tween.ratio = ratio,
                tween._from && (ratio = 1 - ratio),
                tween._time = 0,
                tween._tTime = tTime,
                pt = tween._pt;
              pt;

            )
              pt.r(ratio, pt.d), (pt = pt._next);
            totalTime < 0 && _rewindStartAt(tween, totalTime, 0, !0),
              tween._onUpdate &&
                !suppressEvents &&
                _callback(tween, "onUpdate"),
              tTime &&
                tween._repeat &&
                !suppressEvents &&
                tween.parent &&
                _callback(tween, "onRepeat"),
              (totalTime >= tween._tDur || totalTime < 0) &&
                tween.ratio === ratio &&
                (ratio && _removeFromParent(tween, 1),
                suppressEvents ||
                  _reverting ||
                  (_callback(
                    tween,
                    ratio ? "onComplete" : "onReverseComplete",
                    !0
                  ),
                  tween._prom && tween._prom()));
          }
        } else tween._zTime || (tween._zTime = totalTime);
      }
      function _findNextPauseTween(animation, prevTime, time) {
        var child;
        if (prevTime < time)
          for (child = animation._first; child && child._start <= time; ) {
            if ("isPause" === child.data && child._start > prevTime)
              return child;
            child = child._next;
          }
        else
          for (child = animation._last; child && child._start >= time; ) {
            if ("isPause" === child.data && child._start < prevTime)
              return child;
            child = child._prev;
          }
      }
      function _setDuration(animation, duration, skipUncache, leavePlayhead) {
        var repeat = animation._repeat,
          duration = _roundPrecise(duration) || 0,
          totalProgress = animation._tTime / animation._tDur;
        return (
          totalProgress &&
            !leavePlayhead &&
            (animation._time *= duration / animation._dur),
          (animation._dur = duration),
          (animation._tDur = repeat
            ? repeat < 0
              ? 1e10
              : _roundPrecise(
                  duration * (repeat + 1) + animation._rDelay * repeat
                )
            : duration),
          0 < totalProgress &&
            !leavePlayhead &&
            _alignPlayhead(
              animation,
              (animation._tTime = animation._tDur * totalProgress)
            ),
          animation.parent && _setEnd(animation),
          skipUncache || _uncache(animation.parent, animation),
          animation
        );
      }
      function _onUpdateTotalDuration(animation) {
        return animation instanceof Timeline
          ? _uncache(animation)
          : _setDuration(animation, animation._dur);
      }
      function _parsePosition(animation, position, percentAnimation) {
        var i,
          offset,
          isPercent,
          labels = animation.labels,
          recent = animation._recent || _zeroPosition,
          clippedDuration =
            animation.duration() >= _bigNum
              ? recent.endTime(!1)
              : animation._dur;
        return _isString(position) && (isNaN(position) || position in labels)
          ? ((offset = position.charAt(0)),
            (isPercent = "%" === position.substr(-1)),
            (i = position.indexOf("=")),
            "<" === offset || ">" === offset
              ? (0 <= i && (position = position.replace(/=/, "")),
                ("<" === offset
                  ? recent._start
                  : recent.endTime(0 <= recent._repeat)) +
                  (parseFloat(position.substr(1)) || 0) *
                    (isPercent
                      ? (i < 0 ? recent : percentAnimation).totalDuration() /
                        100
                      : 1))
              : i < 0
              ? (position in labels || (labels[position] = clippedDuration),
                labels[position])
              : ((offset = parseFloat(
                  position.charAt(i - 1) + position.substr(i + 1)
                )),
                isPercent &&
                  percentAnimation &&
                  (offset =
                    (offset / 100) *
                    (_isArray(percentAnimation)
                      ? percentAnimation[0]
                      : percentAnimation
                    ).totalDuration()),
                1 < i
                  ? _parsePosition(
                      animation,
                      position.substr(0, i - 1),
                      percentAnimation
                    ) + offset
                  : clippedDuration + offset))
          : null == position
          ? clippedDuration
          : +position;
      }
      function _createTweenType(type, params, timeline) {
        var irVars,
          parent,
          isLegacy = _isNumber(params[1]),
          varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
          vars = params[varsIndex];
        if (
          (isLegacy && (vars.duration = params[1]),
          (vars.parent = timeline),
          type)
        ) {
          for (
            irVars = vars, parent = timeline;
            parent && !("immediateRender" in irVars);

          )
            (irVars = parent.vars.defaults || {}),
              (parent = _isNotFalse(parent.vars.inherit) && parent.parent);
          (vars.immediateRender = _isNotFalse(irVars.immediateRender)),
            type < 2
              ? (vars.runBackwards = 1)
              : (vars.startAt = params[varsIndex - 1]);
        }
        return new Tween(params[0], vars, params[1 + varsIndex]);
      }
      function _clamp(min, max, value) {
        return value < min ? min : max < value ? max : value;
      }
      function clamp(min, max, value) {
        return _conditionalReturn(value, function (v) {
          return _clamp(min, max, v);
        });
      }
      function _flatten(ar, leaveStrings, accumulator) {
        return (
          void 0 === accumulator && (accumulator = []),
          ar.forEach(function (value) {
            return (_isString(value) && !leaveStrings) || _isArrayLike(value, 1)
              ? accumulator.push.apply(accumulator, toArray(value))
              : accumulator.push(value);
          }) || accumulator
        );
      }
      function selector(value) {
        return (
          (value = toArray(value)[0] || _warn("Invalid scope") || {}),
          function (v) {
            var el = value.current || value.nativeElement || value;
            return toArray(
              v,
              el.querySelectorAll
                ? el
                : el === value
                ? _warn("Invalid scope") || _doc.createElement("div")
                : value
            );
          }
        );
      }
      function distribute(v) {
        var vars, ease, from, base, cache, ratios, axis, ratioX, ratioY;
        return _isFunction(v)
          ? v
          : ((vars = _isObject(v) ? v : { each: v }),
            (ease = _parseEase(vars.ease)),
            (from = vars.from || 0),
            (base = parseFloat(vars.base) || 0),
            (cache = {}),
            (v = 0 < from && from < 1),
            (ratios = isNaN(from) || v),
            (axis = vars.axis),
            _isString((ratioY = ratioX = from))
              ? (ratioX = ratioY =
                  { center: 0.5, edges: 0.5, end: 1 }[from] || 0)
              : !v && ratios && ((ratioX = from[0]), (ratioY = from[1])),
            function (i, target, a) {
              var originX,
                originY,
                y,
                x,
                j,
                max,
                min,
                wrapAt,
                l = (a || vars).length,
                distances = cache[l];
              if (!distances) {
                if (
                  !(wrapAt =
                    "auto" === vars.grid ? 0 : (vars.grid || [1, _bigNum])[1])
                ) {
                  for (
                    max = -_bigNum;
                    max < (max = a[wrapAt++].getBoundingClientRect().left) &&
                    wrapAt < l;

                  );
                  wrapAt < l && wrapAt--;
                }
                for (
                  distances = cache[l] = [],
                    originX = ratios
                      ? Math.min(wrapAt, l) * ratioX - 0.5
                      : from % wrapAt,
                    originY =
                      wrapAt === _bigNum
                        ? 0
                        : ratios
                        ? (l * ratioY) / wrapAt - 0.5
                        : (from / wrapAt) | 0,
                    min = _bigNum,
                    j = max = 0;
                  j < l;
                  j++
                )
                  (x = (j % wrapAt) - originX),
                    (y = originY - ((j / wrapAt) | 0)),
                    (distances[j] = x =
                      axis
                        ? Math.abs("y" === axis ? y : x)
                        : _sqrt(x * x + y * y)),
                    max < x && (max = x),
                    x < min && (min = x);
                "random" === from && shuffle(distances),
                  (distances.max = max - min),
                  (distances.min = min),
                  (distances.v = l =
                    (parseFloat(vars.amount) ||
                      parseFloat(vars.each) *
                        (l < wrapAt
                          ? l - 1
                          : axis
                          ? "y" === axis
                            ? l / wrapAt
                            : wrapAt
                          : Math.max(wrapAt, l / wrapAt)) ||
                      0) * ("edges" === from ? -1 : 1)),
                  (distances.b = l < 0 ? base - l : base),
                  (distances.u = getUnit(vars.amount || vars.each) || 0),
                  (ease = ease && l < 0 ? _invertEase(ease) : ease);
              }
              return (
                (l = (distances[i] - distances.min) / distances.max || 0),
                _roundPrecise(
                  distances.b + (ease ? ease(l) : l) * distances.v
                ) + distances.u
              );
            });
      }
      function _roundModifier(v) {
        var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
        return function (raw) {
          var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
          return (n - (n % 1)) / p + (_isNumber(raw) ? 0 : getUnit(raw));
        };
      }
      function snap(snapTo, value) {
        var radius,
          is2D,
          isArray = _isArray(snapTo);
        return (
          !isArray &&
            _isObject(snapTo) &&
            ((radius = isArray = snapTo.radius || _bigNum),
            snapTo.values
              ? ((snapTo = toArray(snapTo.values)),
                (is2D = !_isNumber(snapTo[0])) && (radius *= radius))
              : (snapTo = _roundModifier(snapTo.increment))),
          _conditionalReturn(
            value,
            isArray
              ? _isFunction(snapTo)
                ? function (raw) {
                    return (
                      (is2D = snapTo(raw)),
                      Math.abs(is2D - raw) <= radius ? is2D : raw
                    );
                  }
                : function (raw) {
                    for (
                      var dx,
                        dy,
                        x = parseFloat(is2D ? raw.x : raw),
                        y = parseFloat(is2D ? raw.y : 0),
                        min = _bigNum,
                        closest = 0,
                        i = snapTo.length;
                      i--;

                    )
                      (dx = is2D
                        ? (dx = snapTo[i].x - x) * dx +
                          (dy = snapTo[i].y - y) * dy
                        : Math.abs(snapTo[i] - x)) < min &&
                        ((min = dx), (closest = i));
                    return (
                      (closest =
                        !radius || min <= radius ? snapTo[closest] : raw),
                      is2D || closest === raw || _isNumber(raw)
                        ? closest
                        : closest + getUnit(raw)
                    );
                  }
              : _roundModifier(snapTo)
          )
        );
      }
      function pipe() {
        for (
          var _len = arguments.length, functions = new Array(_len), _key = 0;
          _key < _len;
          _key++
        )
          functions[_key] = arguments[_key];
        return function (value) {
          return functions.reduce(function (v, f) {
            return f(v);
          }, value);
        };
      }
      function unitize(func, unit) {
        return function (value) {
          return func(parseFloat(value)) + (unit || getUnit(value));
        };
      }
      function normalize(min, max, value) {
        return mapRange(min, max, 0, 1, value);
      }
      function _wrapArray(a, wrapper, value) {
        return _conditionalReturn(value, function (index) {
          return a[~~wrapper(index)];
        });
      }
      function wrap(min, max, value) {
        var range = max - min;
        return _isArray(min)
          ? _wrapArray(min, wrap(0, min.length), max)
          : _conditionalReturn(value, function (value) {
              return ((range + ((value - min) % range)) % range) + min;
            });
      }
      function wrapYoyo(min, max, value) {
        var range = max - min,
          total = 2 * range;
        return _isArray(min)
          ? _wrapArray(min, wrapYoyo(0, min.length - 1), max)
          : _conditionalReturn(value, function (value) {
              return (
                min +
                (range <
                (value = (total + ((value - min) % total)) % total || 0)
                  ? total - value
                  : value)
              );
            });
      }
      function mapRange(inMin, inMax, outMin, outMax, value) {
        var inRange = inMax - inMin,
          outRange = outMax - outMin;
        return _conditionalReturn(value, function (value) {
          return outMin + (((value - inMin) / inRange) * outRange || 0);
        });
      }
      function interpolate(start, end, progress, mutate) {
        var func = isNaN(start + end)
          ? 0
          : function (p) {
              return (1 - p) * start + p * end;
            };
        if (!func) {
          var p,
            i,
            interpolators,
            l,
            il,
            isString = _isString(start),
            master = {};
          if ((!0 === progress && ((mutate = 1), (progress = null)), isString))
            (start = { p: start }), (end = { p: end });
          else if (_isArray(start) && !_isArray(end)) {
            for (
              interpolators = [], l = start.length, il = l - 2, i = 1;
              i < l;
              i++
            )
              interpolators.push(interpolate(start[i - 1], start[i]));
            l--,
              (func = function func(p) {
                p *= l;
                var i = Math.min(il, ~~p);
                return interpolators[i](p - i);
              }),
              (progress = end);
          } else mutate || (start = _merge(_isArray(start) ? [] : {}, start));
          if (!interpolators) {
            for (p in end) _addPropTween.call(master, start, p, "get", end[p]);
            func = function func(p) {
              return (
                _renderPropTweens(p, master) || (isString ? start.p : start)
              );
            };
          }
        }
        return _conditionalReturn(progress, func);
      }
      function _getLabelInDirection(timeline, fromTime, backward) {
        var p,
          distance,
          label,
          labels = timeline.labels,
          min = _bigNum;
        for (p in labels)
          (distance = labels[p] - fromTime) < 0 == !!backward &&
            distance &&
            min > (distance = Math.abs(distance)) &&
            ((label = p), (min = distance));
        return label;
      }
      function _callback(animation, type, executeLazyFirst) {
        var v = animation.vars,
          callback = v[type],
          prevContext = _context,
          context = animation._ctx;
        if (callback)
          return (
            (type = v[type + "Params"]),
            (v = v.callbackScope || animation),
            executeLazyFirst && _lazyTweens.length && _lazyRender(),
            context && (_context = context),
            (animation = type ? callback.apply(v, type) : callback.call(v)),
            (_context = prevContext),
            animation
          );
      }
      function _interrupt(animation) {
        return (
          _removeFromParent(animation),
          animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting),
          animation.progress() < 1 && _callback(animation, "onInterrupt"),
          animation
        );
      }
      function _createPlugin(config) {
        if (config)
          if (
            ((config = (!config.name && config.default) || config),
            _windowExists() || config.headless)
          ) {
            var name = config.name,
              isFunc = _isFunction(config),
              isFunc =
                name && !isFunc && config.init
                  ? function () {
                      this._props = [];
                    }
                  : config,
              instanceDefaults = {
                init: _emptyFunc,
                render: _renderPropTweens,
                add: _addPropTween,
                kill: _killPropTweensOf,
                modifier: _addPluginModifier,
                rawVars: 0,
              },
              statics = {
                targetTest: 0,
                get: 0,
                getSetter: _getSetter,
                aliases: {},
                register: 0,
              };
            if ((_wake(), config !== isFunc)) {
              if (_plugins[name]) return;
              _setDefaults(
                isFunc,
                _setDefaults(_copyExcluding(config, instanceDefaults), statics)
              ),
                _merge(
                  isFunc.prototype,
                  _merge(instanceDefaults, _copyExcluding(config, statics))
                ),
                (_plugins[(isFunc.prop = name)] = isFunc),
                config.targetTest &&
                  (_harnessPlugins.push(isFunc), (_reservedProps[name] = 1)),
                (name =
                  ("css" === name
                    ? "CSS"
                    : name.charAt(0).toUpperCase() + name.substr(1)) +
                  "Plugin");
            }
            _addGlobal(name, isFunc),
              config.register && config.register(gsap, isFunc, PropTween);
          } else _registerPluginQueue.push(config);
      }
      function _hue(h, m1, m2) {
        return (
          ((6 * (h += h < 0 ? 1 : 1 < h ? -1 : 0) < 1
            ? m1 + (m2 - m1) * h * 6
            : h < 0.5
            ? m2
            : 3 * h < 2
            ? m1 + (m2 - m1) * (2 / 3 - h) * 6
            : m1) *
            _255 +
            0.5) |
          0
        );
      }
      function _formatColors(s, toHSL, orderMatchData) {
        var c,
          shell,
          d,
          l,
          result = "",
          colors = (s + result).match(_colorExp),
          type = toHSL ? "hsla(" : "rgba(",
          i = 0;
        if (!colors) return s;
        if (
          ((colors = colors.map(function (color) {
            return (
              (color = splitColor(color, toHSL, 1)) &&
              type +
                (toHSL
                  ? color[0] +
                    "," +
                    color[1] +
                    "%," +
                    color[2] +
                    "%," +
                    color[3]
                  : color.join(",")) +
                ")"
            );
          })),
          orderMatchData &&
            ((d = _colorOrderData(s)),
            (c = orderMatchData.c).join(result) !== d.c.join(result)))
        )
          for (
            l =
              (shell = s.replace(_colorExp, "1").split(_numWithUnitExp))
                .length - 1;
            i < l;
            i++
          )
            result +=
              shell[i] +
              (~c.indexOf(i)
                ? colors.shift() || type + "0,0,0,0)"
                : (d.length
                    ? d
                    : colors.length
                    ? colors
                    : orderMatchData
                  ).shift());
        if (!shell)
          for (l = (shell = s.split(_colorExp)).length - 1; i < l; i++)
            result += shell[i] + colors[i];
        return result + shell[l];
      }
      function _colorStringFilter(a) {
        var combined = a.join(" ");
        if (((_colorExp.lastIndex = 0), _colorExp.test(combined)))
          return (
            (combined = _hslExp.test(combined)),
            (a[1] = _formatColors(a[1], combined)),
            (a[0] = _formatColors(a[0], combined, _colorOrderData(a[1]))),
            !0
          );
      }
      function _parseObjectInString(value) {
        for (
          var index,
            val,
            parsedVal,
            obj = {},
            split = value.substr(1, value.length - 3).split(":"),
            key = split[0],
            i = 1,
            l = split.length;
          i < l;
          i++
        )
          (val = split[i]),
            (index = i !== l - 1 ? val.lastIndexOf(",") : val.length),
            (parsedVal = val.substr(0, index)),
            (obj[key] = isNaN(parsedVal)
              ? parsedVal.replace(_quotesExp, "").trim()
              : +parsedVal),
            (key = val.substr(index + 1).trim());
        return obj;
      }
      function _valueInParentheses(value) {
        var open = value.indexOf("(") + 1,
          close = value.indexOf(")"),
          nested = value.indexOf("(", open);
        return value.substring(
          open,
          ~nested && nested < close ? value.indexOf(")", close + 1) : close
        );
      }
      function _propagateYoyoEase(timeline, isYoyo) {
        for (var ease, child = timeline._first; child; )
          child instanceof Timeline
            ? _propagateYoyoEase(child, isYoyo)
            : !child.vars.yoyoEase ||
              (child._yoyo && child._repeat) ||
              child._yoyo === isYoyo ||
              (child.timeline
                ? _propagateYoyoEase(child.timeline, isYoyo)
                : ((ease = child._ease),
                  (child._ease = child._yEase),
                  (child._yEase = ease),
                  (child._yoyo = isYoyo))),
            (child = child._next);
      }
      function _insertEase(names, easeIn, easeOut, easeInOut) {
        var lowercaseName,
          ease = {
            easeIn: easeIn,
            easeOut: (easeOut =
              void 0 === easeOut
                ? function easeOut(p) {
                    return 1 - easeIn(1 - p);
                  }
                : easeOut),
            easeInOut: (easeInOut =
              void 0 === easeInOut
                ? function easeInOut(p) {
                    return p < 0.5
                      ? easeIn(2 * p) / 2
                      : 1 - easeIn(2 * (1 - p)) / 2;
                  }
                : easeInOut),
          };
        return (
          _forEachName(names, function (name) {
            for (var p in ((_easeMap[name] = _globals[name] = ease),
            (_easeMap[(lowercaseName = name.toLowerCase())] = easeOut),
            ease))
              _easeMap[
                lowercaseName +
                  ("easeIn" === p ? ".in" : "easeOut" === p ? ".out" : ".inOut")
              ] = _easeMap[name + "." + p] = ease[p];
          }),
          ease
        );
      }
      function _easeInOutFromOut(easeOut) {
        return function (p) {
          return p < 0.5
            ? (1 - easeOut(1 - 2 * p)) / 2
            : 0.5 + easeOut(2 * (p - 0.5)) / 2;
        };
      }
      function _configElastic(type, amplitude, period) {
        function easeOut(p) {
          return 1 === p
            ? 1
            : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
        }
        var p1 = 1 <= amplitude ? amplitude : 1,
          p3 =
            ((p2 =
              (period || (type ? 0.3 : 0.45)) /
              (amplitude < 1 ? amplitude : 1)) /
              _2PI) *
            (Math.asin(1 / p1) || 0),
          period =
            "out" === type
              ? easeOut
              : "in" === type
              ? function (p) {
                  return 1 - easeOut(1 - p);
                }
              : _easeInOutFromOut(easeOut),
          p2 = _2PI / p2;
        return (
          (period.config = function (amplitude, period) {
            return _configElastic(type, amplitude, period);
          }),
          period
        );
      }
      function _configBack(type, overshoot) {
        function easeOut(p) {
          return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
        }
        void 0 === overshoot && (overshoot = 1.70158);
        var ease =
          "out" === type
            ? easeOut
            : "in" === type
            ? function (p) {
                return 1 - easeOut(1 - p);
              }
            : _easeInOutFromOut(easeOut);
        return (
          (ease.config = function (overshoot) {
            return _configBack(type, overshoot);
          }),
          ease
        );
      }
      var _suppressOverwrites,
        _reverting,
        _context,
        _globalTimeline,
        _win,
        _coreInitted,
        _doc,
        _coreReady,
        _lastRenderedFrame,
        _quickTween,
        _tickerActive,
        n,
        c,
        n1,
        _config = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: { lineHeight: "" },
        },
        _defaults = { duration: 0.5, overwrite: !1, delay: 0 },
        _bigNum = 1e8,
        _tinyNum = 1 / _bigNum,
        _2PI = 2 * Math.PI,
        _HALF_PI = _2PI / 4,
        _gsID = 0,
        _sqrt = Math.sqrt,
        _cos = Math.cos,
        _sin = Math.sin,
        _isString = function _isString(value) {
          return "string" == typeof value;
        },
        _isFunction = function _isFunction(value) {
          return "function" == typeof value;
        },
        _isNumber = function _isNumber(value) {
          return "number" == typeof value;
        },
        _isUndefined = function _isUndefined(value) {
          return void 0 === value;
        },
        _isObject = function _isObject(value) {
          return "object" == typeof value;
        },
        _isTypedArray =
          ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        _isArray = Array.isArray,
        _strictNumExp = /(?:-?\.?\d|\.)+/gi,
        _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        _relExp = /[+-]=-?[.\d]+/,
        _delimitedValueExp = /[^,'"\[\]\s]+/gi,
        _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        _globals = {},
        _installScope = {},
        _missingPlugin = function _missingPlugin(property, value) {
          return console.warn(
            "Invalid property",
            property,
            "set to",
            value,
            "Missing plugin? gsap.registerPlugin()"
          );
        },
        _warn = function _warn(message, suppress) {
          return !suppress && console.warn(message);
        },
        _startAtRevertConfig = { suppressEvents: !0, isStart: !0, kill: !1 },
        _revertConfigNoKill = { suppressEvents: !0, kill: !1 },
        _revertConfig = { suppressEvents: !0 },
        _reservedProps = {},
        _lazyTweens = [],
        _lazyLookup = {},
        _plugins = {},
        _effects = {},
        _nextGCFrame = 30,
        _harnessPlugins = [],
        _callbackNames = "",
        _harness = function _harness(targets) {
          var harnessPlugin,
            i,
            target = targets[0];
          if (
            (_isObject(target) || _isFunction(target) || (targets = [targets]),
            !(harnessPlugin = (target._gsap || {}).harness))
          ) {
            for (
              i = _harnessPlugins.length;
              i-- && !_harnessPlugins[i].targetTest(target);

            );
            harnessPlugin = _harnessPlugins[i];
          }
          for (i = targets.length; i--; )
            (targets[i] &&
              (targets[i]._gsap ||
                (targets[i]._gsap = new GSCache(targets[i], harnessPlugin)))) ||
              targets.splice(i, 1);
          return targets;
        },
        _getCache = function _getCache(target) {
          return target._gsap || _harness(toArray(target))[0]._gsap;
        },
        _getProperty = function _getProperty(target, property, v) {
          return (v = target[property]) && _isFunction(v)
            ? target[property]()
            : (_isUndefined(v) &&
                target.getAttribute &&
                target.getAttribute(property)) ||
                v;
        },
        _round = function _round(value) {
          return Math.round(1e5 * value) / 1e5 || 0;
        },
        _roundPrecise = function _roundPrecise(value) {
          return Math.round(1e7 * value) / 1e7 || 0;
        },
        _parseRelative = function _parseRelative(start, value) {
          var operator = value.charAt(0),
            value = parseFloat(value.substr(2));
          return (
            (start = parseFloat(start)),
            "+" === operator
              ? start + value
              : "-" === operator
              ? start - value
              : "*" === operator
              ? start * value
              : start / value
          );
        },
        _lazyRender = function _lazyRender() {
          var i,
            tween,
            l = _lazyTweens.length,
            a = _lazyTweens.slice(0);
          for (_lazyLookup = {}, i = _lazyTweens.length = 0; i < l; i++)
            (tween = a[i]) &&
              tween._lazy &&
              (tween.render(tween._lazy[0], tween._lazy[1], !0)._lazy = 0);
        },
        _uncache = function _uncache(animation, child) {
          if (
            animation &&
            (!child || child._end > animation._dur || child._start < 0)
          )
            for (var a = animation; a; ) (a._dirty = 1), (a = a.parent);
          return animation;
        },
        _setEnd = function _setEnd(animation) {
          return (animation._end = _roundPrecise(
            animation._start +
              (animation._tDur /
                Math.abs(animation._ts || animation._rts || _tinyNum) || 0)
          ));
        },
        _alignPlayhead = function _alignPlayhead(animation, totalTime) {
          var parent = animation._dp;
          return (
            parent &&
              parent.smoothChildTiming &&
              animation._ts &&
              ((animation._start = _roundPrecise(
                parent._time -
                  (0 < animation._ts
                    ? totalTime / animation._ts
                    : ((animation._dirty
                        ? animation.totalDuration()
                        : animation._tDur) -
                        totalTime) /
                      -animation._ts)
              )),
              _setEnd(animation),
              parent._dirty || _uncache(parent, animation)),
            animation
          );
        },
        _zeroPosition = {
          _start: 0,
          endTime: _emptyFunc,
          totalDuration: _emptyFunc,
        },
        _conditionalReturn = function _conditionalReturn(value, func) {
          return value || 0 === value ? func(value) : func;
        },
        getUnit = function getUnit(value, v) {
          return _isString(value) && (v = _unitExp.exec(value)) ? v[1] : "";
        },
        _slice = [].slice,
        _isArrayLike = function _isArrayLike(value, nonEmpty) {
          return (
            value &&
            _isObject(value) &&
            "length" in value &&
            ((!nonEmpty && !value.length) ||
              (value.length - 1 in value && _isObject(value[0]))) &&
            !value.nodeType &&
            value !== _win
          );
        },
        toArray = function toArray(value, scope, leaveStrings) {
          return _context && !scope && _context.selector
            ? _context.selector(value)
            : !_isString(value) || leaveStrings || (!_coreInitted && _wake())
            ? _isArray(value)
              ? _flatten(value, leaveStrings)
              : _isArrayLike(value)
              ? _slice.call(value, 0)
              : value
              ? [value]
              : []
            : _slice.call((scope || _doc).querySelectorAll(value), 0);
        },
        shuffle = function shuffle(a) {
          return a.sort(function () {
            return 0.5 - Math.random();
          });
        },
        random = function random(min, max, roundingIncrement, returnFunction) {
          return _conditionalReturn(
            _isArray(min)
              ? !max
              : !0 === roundingIncrement
              ? !!(roundingIncrement = 0)
              : !returnFunction,
            function () {
              return _isArray(min)
                ? min[~~(Math.random() * min.length)]
                : (roundingIncrement = roundingIncrement || 1e-5) &&
                    (returnFunction =
                      roundingIncrement < 1
                        ? Math.pow(10, (roundingIncrement + "").length - 2)
                        : 1) &&
                    Math.floor(
                      Math.round(
                        (min -
                          roundingIncrement / 2 +
                          Math.random() *
                            (max - min + 0.99 * roundingIncrement)) /
                          roundingIncrement
                      ) *
                        roundingIncrement *
                        returnFunction
                    ) / returnFunction;
            }
          );
        },
        _replaceRandom = function _replaceRandom(value) {
          for (
            var i, nums, end, isArray, prev = 0, s = "";
            ~(i = value.indexOf("random(", prev));

          )
            (end = value.indexOf(")", i)),
              (isArray = "[" === value.charAt(i + 7)),
              (nums = value
                .substr(i + 7, end - i - 7)
                .match(isArray ? _delimitedValueExp : _strictNumExp)),
              (s +=
                value.substr(prev, i - prev) +
                random(
                  isArray ? nums : +nums[0],
                  isArray ? 0 : +nums[1],
                  +nums[2] || 1e-5
                )),
              (prev = end + 1);
          return s + value.substr(prev, value.length - prev);
        },
        _registerPluginQueue = [],
        _255 = 255,
        _colorLookup = {
          aqua: [0, _255, _255],
          lime: [0, _255, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, _255],
          navy: [0, 0, 128],
          white: [_255, _255, _255],
          olive: [128, 128, 0],
          yellow: [_255, _255, 0],
          orange: [_255, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [_255, 0, 0],
          pink: [_255, 192, 203],
          cyan: [0, _255, _255],
          transparent: [_255, _255, _255, 0],
        },
        splitColor = function splitColor(v, toHSL, forceAlpha) {
          var r,
            g,
            b,
            h,
            s,
            l,
            wasHSL,
            a = v
              ? _isNumber(v)
                ? [v >> 16, (v >> 8) & _255, v & _255]
                : 0
              : _colorLookup.black;
          if (!a) {
            if (
              ("," === v.substr(-1) && (v = v.substr(0, v.length - 1)),
              _colorLookup[v])
            )
              a = _colorLookup[v];
            else if ("#" === v.charAt(0)) {
              if (
                9 ===
                (v =
                  v.length < 6
                    ? "#" +
                      (r = v.charAt(1)) +
                      r +
                      (g = v.charAt(2)) +
                      g +
                      (b = v.charAt(3)) +
                      b +
                      (5 === v.length ? v.charAt(4) + v.charAt(4) : "")
                    : v).length
              )
                return [
                  (a = parseInt(v.substr(1, 6), 16)) >> 16,
                  (a >> 8) & _255,
                  a & _255,
                  parseInt(v.substr(7), 16) / 255,
                ];
              a = [
                (v = parseInt(v.substr(1), 16)) >> 16,
                (v >> 8) & _255,
                v & _255,
              ];
            } else if ("hsl" === v.substr(0, 3))
              if (((a = wasHSL = v.match(_strictNumExp)), toHSL)) {
                if (~v.indexOf("="))
                  return (
                    (a = v.match(_numExp)),
                    forceAlpha && a.length < 4 && (a[3] = 1),
                    a
                  );
              } else
                (h = (+a[0] % 360) / 360),
                  (s = +a[1] / 100),
                  (r =
                    2 * (l = +a[2] / 100) -
                    (g = l <= 0.5 ? l * (s + 1) : l + s - l * s)),
                  3 < a.length && (a[3] *= 1),
                  (a[0] = _hue(h + 1 / 3, r, g)),
                  (a[1] = _hue(h, r, g)),
                  (a[2] = _hue(h - 1 / 3, r, g));
            else a = v.match(_strictNumExp) || _colorLookup.transparent;
            a = a.map(Number);
          }
          return (
            toHSL &&
              !wasHSL &&
              ((r = a[0] / _255),
              (g = a[1] / _255),
              (b = a[2] / _255),
              (l = ((v = Math.max(r, g, b)) + (toHSL = Math.min(r, g, b))) / 2),
              v === toHSL
                ? (h = s = 0)
                : ((wasHSL = v - toHSL),
                  (s =
                    0.5 < l ? wasHSL / (2 - v - toHSL) : wasHSL / (v + toHSL)),
                  (h =
                    v === r
                      ? (g - b) / wasHSL + (g < b ? 6 : 0)
                      : v === g
                      ? (b - r) / wasHSL + 2
                      : (r - g) / wasHSL + 4),
                  (h *= 60)),
              (a[0] = ~~(h + 0.5)),
              (a[1] = ~~(100 * s + 0.5)),
              (a[2] = ~~(100 * l + 0.5))),
            forceAlpha && a.length < 4 && (a[3] = 1),
            a
          );
        },
        _colorOrderData = function _colorOrderData(v) {
          var values = [],
            c = [],
            i = -1;
          return (
            v.split(_colorExp).forEach(function (v) {
              v = v.match(_numWithUnitExp) || [];
              values.push.apply(values, v), c.push((i += v.length + 1));
            }),
            (values.c = c),
            values
          );
        },
        _colorExp = (function () {
          var p,
            s =
              "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (p in _colorLookup) s += "|" + p + "\\b";
          return new RegExp(s + ")", "gi");
        })(),
        _hslExp = /hsl[a]?\(/,
        _ticker = (function () {
          function _tick(v) {
            var dispatch,
              time,
              frame,
              elapsed = _getTime() - _lastUpdate,
              manual = !0 === v;
            if (
              ((_lagThreshold < elapsed || elapsed < 0) &&
                (_startTime += elapsed - _adjustedLag),
              (0 <
                (elapsed =
                  (time = (_lastUpdate += elapsed) - _startTime) - _nextTime) ||
                manual) &&
                ((frame = ++_self.frame),
                (_delta = time - 1e3 * _self.time),
                (_self.time = time /= 1e3),
                (_nextTime += elapsed + (_gap <= elapsed ? 4 : _gap - elapsed)),
                (dispatch = 1)),
              manual || (_id = _req(_tick)),
              dispatch)
            )
              for (_i = 0; _i < _listeners.length; _i++)
                _listeners[_i](time, _delta, frame, v);
          }
          var _id,
            _req,
            _raf,
            _delta,
            _i,
            _getTime = Date.now,
            _lagThreshold = 500,
            _adjustedLag = 33,
            _startTime = _getTime(),
            _lastUpdate = _startTime,
            _gap = 1e3 / 240,
            _nextTime = _gap,
            _listeners = [],
            _self = {
              time: 0,
              frame: 0,
              tick: function tick() {
                _tick(!0);
              },
              deltaRatio: function deltaRatio(fps) {
                return _delta / (1e3 / (fps || 60));
              },
              wake: function wake() {
                _coreReady &&
                  (!_coreInitted &&
                    _windowExists() &&
                    ((_win = _coreInitted = window),
                    (_doc = _win.document || {}),
                    (_globals.gsap = gsap),
                    (_win.gsapVersions || (_win.gsapVersions = [])).push(
                      gsap.version
                    ),
                    _install(
                      _installScope ||
                        _win.GreenSockGlobals ||
                        (!_win.gsap && _win) ||
                        {}
                    ),
                    _registerPluginQueue.forEach(_createPlugin)),
                  (_raf =
                    "undefined" != typeof requestAnimationFrame &&
                    requestAnimationFrame),
                  _id && _self.sleep(),
                  (_req =
                    _raf ||
                    function (f) {
                      return setTimeout(
                        f,
                        (_nextTime - 1e3 * _self.time + 1) | 0
                      );
                    }),
                  (_tickerActive = 1),
                  _tick(2));
              },
              sleep: function sleep() {
                (_raf ? cancelAnimationFrame : clearTimeout)(_id),
                  (_tickerActive = 0),
                  (_req = _emptyFunc);
              },
              lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                (_lagThreshold = threshold || 1 / 0),
                  (_adjustedLag = Math.min(adjustedLag || 33, _lagThreshold));
              },
              fps: function fps(_fps) {
                (_gap = 1e3 / (_fps || 240)),
                  (_nextTime = 1e3 * _self.time + _gap);
              },
              add: function add(callback, once, prioritize) {
                var func = once
                  ? function (t, d, f, v) {
                      callback(t, d, f, v), _self.remove(func);
                    }
                  : callback;
                return (
                  _self.remove(callback),
                  _listeners[prioritize ? "unshift" : "push"](func),
                  _wake(),
                  func
                );
              },
              remove: function remove(callback, i) {
                ~(i = _listeners.indexOf(callback)) &&
                  _listeners.splice(i, 1) &&
                  i <= _i &&
                  _i--;
              },
              _listeners: _listeners,
            };
          return _self;
        })(),
        _wake = function _wake() {
          return !_tickerActive && _ticker.wake();
        },
        _easeMap = {},
        _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
        _quotesExp = /["']/g,
        _configEaseFromString = function _configEaseFromString(name) {
          var split = (name + "").split("("),
            ease = _easeMap[split[0]];
          return ease && 1 < split.length && ease.config
            ? ease.config.apply(
                null,
                ~name.indexOf("{")
                  ? [_parseObjectInString(split[1])]
                  : _valueInParentheses(name).split(",").map(_numericIfPossible)
              )
            : _easeMap._CE && _customEaseExp.test(name)
            ? _easeMap._CE("", name)
            : ease;
        },
        _invertEase = function _invertEase(ease) {
          return function (p) {
            return 1 - ease(1 - p);
          };
        },
        _parseEase = function _parseEase(ease, defaultEase) {
          return (
            (ease &&
              (_isFunction(ease)
                ? ease
                : _easeMap[ease] || _configEaseFromString(ease))) ||
            defaultEase
          );
        };
      function easeOut(p) {
        return p < n1
          ? n * p * p
          : p < 0.7272727272727273
          ? n * Math.pow(p - 1.5 / c, 2) + 0.75
          : p < 0.9090909090909092
          ? n * (p -= 2.25 / c) * p + 0.9375
          : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
      }
      _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
        var power = i < 5 ? i + 1 : i;
        _insertEase(
          name + ",Power" + (power - 1),
          i
            ? function (p) {
                return Math.pow(p, power);
              }
            : function (p) {
                return p;
              },
          function (p) {
            return 1 - Math.pow(1 - p, power);
          },
          function (p) {
            return p < 0.5
              ? Math.pow(2 * p, power) / 2
              : 1 - Math.pow(2 * (1 - p), power) / 2;
          }
        );
      }),
        (_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn),
        _insertEase(
          "Elastic",
          _configElastic("in"),
          _configElastic("out"),
          _configElastic()
        ),
        (n = 7.5625),
        (n1 = 1 / (c = 2.75)),
        _insertEase(
          "Bounce",
          function (p) {
            return 1 - easeOut(1 - p);
          },
          easeOut
        ),
        _insertEase("Expo", function (p) {
          return p ? Math.pow(2, 10 * (p - 1)) : 0;
        }),
        _insertEase("Circ", function (p) {
          return -(_sqrt(1 - p * p) - 1);
        }),
        _insertEase("Sine", function (p) {
          return 1 === p ? 1 : 1 - _cos(p * _HALF_PI);
        }),
        _insertEase(
          "Back",
          _configBack("in"),
          _configBack("out"),
          _configBack()
        ),
        (_easeMap.SteppedEase =
          _easeMap.steps =
          _globals.SteppedEase =
            {
              config: function config(steps, immediateStart) {
                var p1 = 1 / (steps = void 0 === steps ? 1 : steps),
                  p2 = steps + (immediateStart ? 0 : 1),
                  p3 = immediateStart ? 1 : 0,
                  max = 1 - _tinyNum;
                return function (p) {
                  return (((p2 * _clamp(0, max, p)) | 0) + p3) * p1;
                };
              },
            }),
        (_defaults.ease = _easeMap["quad.out"]),
        _forEachName(
          "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
          function (name) {
            return (_callbackNames += name + "," + name + "Params,");
          }
        );
      function _addComplexStringPropTween(
        target,
        prop,
        start,
        end,
        setter,
        stringFilter,
        funcParam
      ) {
        var startNums,
          color,
          endNum,
          result,
          startNum,
          pt = new PropTween(
            this._pt,
            target,
            prop,
            0,
            1,
            _renderComplexString,
            null,
            setter
          ),
          index = 0,
          matchIndex = 0;
        for (
          pt.b = start,
            pt.e = end,
            start += "",
            (setter = ~(end += "").indexOf("random(")) &&
              (end = _replaceRandom(end)),
            stringFilter &&
              (stringFilter((stringFilter = [start, end]), target, prop),
              (start = stringFilter[0]),
              (end = stringFilter[1])),
            startNums = start.match(_complexStringNumExp) || [];
          (result = _complexStringNumExp.exec(end));

        )
          (endNum = result[0]),
            (result = end.substring(index, result.index)),
            color
              ? (color = (color + 1) % 5)
              : "rgba(" === result.substr(-5) && (color = 1),
            endNum !== startNums[matchIndex++] &&
              ((startNum = parseFloat(startNums[matchIndex - 1]) || 0),
              (pt._pt = {
                _next: pt._pt,
                p: result || 1 === matchIndex ? result : ",",
                s: startNum,
                c:
                  "=" === endNum.charAt(1)
                    ? _parseRelative(startNum, endNum) - startNum
                    : parseFloat(endNum) - startNum,
                m: color && color < 4 ? Math.round : 0,
              }),
              (index = _complexStringNumExp.lastIndex));
        return (
          (pt.c = index < end.length ? end.substring(index, end.length) : ""),
          (pt.fp = funcParam),
          (_relExp.test(end) || setter) && (pt.e = 0),
          (this._pt = pt)
        );
      }
      function _checkPlugin(property, vars, tween, index, target, targets) {
        var plugin, pt, ptLookup, i;
        if (
          _plugins[property] &&
          !1 !==
            (plugin = new _plugins[property]()).init(
              target,
              plugin.rawVars
                ? vars[property]
                : _processVars(vars[property], index, target, targets, tween),
              tween,
              index,
              targets
            ) &&
          ((tween._pt = pt =
            new PropTween(
              tween._pt,
              target,
              property,
              0,
              1,
              plugin.render,
              plugin,
              0,
              plugin.priority
            )),
          tween !== _quickTween)
        )
          for (
            ptLookup = tween._ptLookup[tween._targets.indexOf(target)],
              i = plugin._props.length;
            i--;

          )
            ptLookup[plugin._props[i]] = pt;
        return plugin;
      }
      function _updatePropTweens(
        tween,
        property,
        value,
        start,
        startIsRelative,
        ratio,
        time,
        skipRecursion
      ) {
        var pt,
          rootPT,
          lookup,
          i,
          ptCache = ((tween._pt && tween._ptCache) || (tween._ptCache = {}))[
            property
          ];
        if (!ptCache)
          for (
            ptCache = tween._ptCache[property] = [],
              lookup = tween._ptLookup,
              i = tween._targets.length;
            i--;

          ) {
            if ((pt = lookup[i][property]) && pt.d && pt.d._pt)
              for (
                pt = pt.d._pt;
                pt && pt.p !== property && pt.fp !== property;

              )
                pt = pt._next;
            if (!pt)
              return (
                (_forceAllPropTweens = 1),
                (tween.vars[property] = "+=0"),
                _initTween(tween, time),
                (_forceAllPropTweens = 0),
                skipRecursion ? _warn(property + " not eligible for reset") : 1
              );
            ptCache.push(pt);
          }
        for (i = ptCache.length; i--; )
          ((pt = (rootPT = ptCache[i])._pt || rootPT).s =
            (!start && 0 !== start) || startIsRelative
              ? pt.s + (start || 0) + ratio * pt.c
              : start),
            (pt.c = value - pt.s),
            rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)),
            rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
      }
      function _addAliasesToVars(targets, vars) {
        var copy,
          p,
          i,
          aliases,
          propertyAliases =
            (targets = targets[0] ? _getCache(targets[0]).harness : 0) &&
            targets.aliases;
        if (!propertyAliases) return vars;
        for (p in ((copy = _merge({}, vars)), propertyAliases))
          if (p in copy)
            for (i = (aliases = propertyAliases[p].split(",")).length; i--; )
              copy[aliases[i]] = copy[p];
        return copy;
      }
      function _parseKeyframe(prop, obj, allProps, easeEach) {
        var p,
          a,
          ease = obj.ease || easeEach || "power1.inOut";
        if (_isArray(obj))
          (a = allProps[prop] || (allProps[prop] = [])),
            obj.forEach(function (value, i) {
              return a.push({
                t: (i / (obj.length - 1)) * 100,
                v: value,
                e: ease,
              });
            });
        else
          for (p in obj)
            (a = allProps[p] || (allProps[p] = [])),
              "ease" !== p &&
                a.push({ t: parseFloat(prop), v: obj[p], e: ease });
      }
      function _parseFuncOrString(value, tween, i, target, targets) {
        return _isFunction(value)
          ? value.call(tween, i, target, targets)
          : _isString(value) && ~value.indexOf("random(")
          ? _replaceRandom(value)
          : value;
      }
      function _setterAttribute(target, property, value) {
        return target.setAttribute(property, value);
      }
      function _setterWithModifier(target, property, value, data) {
        data.mSet(
          target,
          property,
          data.m.call(data.tween, value, data.mt),
          data
        );
      }
      function _dispatch(type) {
        return (_listeners[type] || _emptyArray).map(function (f) {
          return f();
        });
      }
      function _onMediaChange() {
        var time = Date.now(),
          matches = [];
        2 < time - _lastMediaTime &&
          (_dispatch("matchMediaInit"),
          _media.forEach(function (c) {
            var match,
              p,
              anyMatch,
              toggled,
              queries = c.queries,
              conditions = c.conditions;
            for (p in queries)
              (match = _win.matchMedia(queries[p]).matches) && (anyMatch = 1),
                match !== conditions[p] &&
                  ((conditions[p] = match), (toggled = 1));
            toggled && (c.revert(), anyMatch) && matches.push(c);
          }),
          _dispatch("matchMediaRevert"),
          matches.forEach(function (c) {
            return c.onMatch(c, function (func) {
              return c.add(null, func);
            });
          }),
          (_lastMediaTime = time),
          _dispatch("matchMedia"));
      }
      function _addModifiers(tween, modifiers) {
        var p,
          i,
          pt,
          targets = tween._targets;
        for (p in modifiers)
          for (i = targets.length; i--; )
            (pt =
              (pt = (pt = tween._ptLookup[i][p]) && pt.d) &&
              (pt._pt ? _getPluginPropTween(pt, p) : pt)) &&
              pt.modifier &&
              pt.modifier(modifiers[p], tween, targets[i], p);
      }
      function _buildModifierPlugin(name, modifier) {
        return {
          name: name,
          rawVars: 1,
          init: function init(target, vars, tween) {
            tween._onInit = function (tween) {
              var temp, p;
              if (
                (_isString(vars) &&
                  ((temp = {}),
                  _forEachName(vars, function (name) {
                    return (temp[name] = 1);
                  }),
                  (vars = temp)),
                modifier)
              ) {
                for (p in ((temp = {}), vars)) temp[p] = modifier(vars[p]);
                vars = temp;
              }
              _addModifiers(tween, vars);
            };
          },
        };
      }
      function _renderCSSProp(ratio, data) {
        return data.set(
          data.t,
          data.p,
          Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u,
          data
        );
      }
      function _renderPropWithEnd(ratio, data) {
        return data.set(
          data.t,
          data.p,
          1 === ratio
            ? data.e
            : Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u,
          data
        );
      }
      function _renderCSSPropWithBeginning(ratio, data) {
        return data.set(
          data.t,
          data.p,
          ratio
            ? Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u
            : data.b,
          data
        );
      }
      function _renderRoundedCSSProp(ratio, data) {
        (ratio = data.s + data.c * ratio),
          data.set(
            data.t,
            data.p,
            ~~(ratio + (ratio < 0 ? -0.5 : 0.5)) + data.u,
            data
          );
      }
      function _renderNonTweeningValue(ratio, data) {
        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
      }
      function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
        return data.set(data.t, data.p, 1 !== ratio ? data.b : data.e, data);
      }
      function _setterCSSStyle(target, property, value) {
        return (target.style[property] = value);
      }
      function _setterCSSProp(target, property, value) {
        return target.style.setProperty(property, value);
      }
      function _setterTransform(target, property, value) {
        return (target._gsap[property] = value);
      }
      function _setterScale(target, property, value) {
        return (target._gsap.scaleX = target._gsap.scaleY = value);
      }
      function _setterScaleWithRender(target, property, value, data, ratio) {
        ((target = target._gsap).scaleX = target.scaleY = value),
          target.renderTransform(ratio, target);
      }
      function _setterTransformWithRender(
        target,
        property,
        value,
        data,
        ratio
      ) {
        ((target = target._gsap)[property] = value),
          target.renderTransform(ratio, target);
      }
      function _saveStyle(property, isNotCSS) {
        var _this = this,
          target = this.target,
          style = target.style,
          cache = target._gsap;
        if (property in _transformProps && style) {
          if (((this.tfm = this.tfm || {}), "transform" === property))
            return _propertyAliases.transform.split(",").forEach(function (p) {
              return _saveStyle.call(_this, p, isNotCSS);
            });
          if (
            (~(property = _propertyAliases[property] || property).indexOf(",")
              ? property.split(",").forEach(function (a) {
                  return (_this.tfm[a] = _get(target, a));
                })
              : (this.tfm[property] = cache.x
                  ? cache[property]
                  : _get(target, property)),
            property === _transformOriginProp &&
              (this.tfm.zOrigin = cache.zOrigin),
            0 <= this.props.indexOf(_transformProp))
          )
            return;
          cache.svg &&
            ((this.svgo = target.getAttribute("data-svg-origin")),
            this.props.push(_transformOriginProp, isNotCSS, "")),
            (property = _transformProp);
        }
        (style || isNotCSS) &&
          this.props.push(property, isNotCSS, style[property]);
      }
      function _revertStyle() {
        for (
          var p,
            props = this.props,
            target = this.target,
            style = target.style,
            cache = target._gsap,
            i = 0;
          i < props.length;
          i += 3
        )
          props[i + 1]
            ? (target[props[i]] = props[i + 2])
            : props[i + 2]
            ? (style[props[i]] = props[i + 2])
            : style.removeProperty(
                "--" === props[i].substr(0, 2)
                  ? props[i]
                  : props[i].replace(_capsExp, "-$1").toLowerCase()
              );
        if (this.tfm) {
          for (p in this.tfm) cache[p] = this.tfm[p];
          cache.svg &&
            (cache.renderTransform(),
            target.setAttribute("data-svg-origin", this.svgo || "")),
            ((i = CSSPlugin_reverting()) && i.isStart) ||
              style[_transformProp] ||
              (_removeIndependentTransforms(style),
              cache.zOrigin &&
                style[_transformOriginProp] &&
                ((style[_transformOriginProp] += " " + cache.zOrigin + "px"),
                (cache.zOrigin = 0),
                cache.renderTransform()),
              (cache.uncache = 1));
        }
      }
      function _getStyleSaver(target, properties) {
        var saver = {
          target: target,
          props: [],
          revert: _revertStyle,
          save: _saveStyle,
        };
        return (
          target._gsap || gsap.core.getCache(target),
          properties &&
            properties.split(",").forEach(function (p) {
              return saver.save(p);
            }),
          saver
        );
      }
      function _initCore() {
        CSSPlugin_windowExists() &&
          window.document &&
          ((CSSPlugin_win = window),
          (CSSPlugin_doc = CSSPlugin_win.document),
          (_docElement = CSSPlugin_doc.documentElement),
          (_tempDiv = _createElement("div") || { style: {} }),
          _createElement("div"),
          (_transformProp = _checkPropPrefix(_transformProp)),
          (_transformOriginProp = _transformProp + "Origin"),
          (_tempDiv.style.cssText =
            "border-width:0;line-height:0;position:absolute;padding:0"),
          (_supports3D = !!_checkPropPrefix("perspective")),
          (CSSPlugin_reverting = gsap.core.reverting),
          (_pluginInitted = 1));
      }
      function _getBBoxHack(swapIfPossible) {
        var bbox,
          svg = _createElement(
            "svg",
            (this.ownerSVGElement &&
              this.ownerSVGElement.getAttribute("xmlns")) ||
              "http://www.w3.org/2000/svg"
          ),
          oldParent = this.parentNode,
          oldSibling = this.nextSibling,
          oldCSS = this.style.cssText;
        if (
          (_docElement.appendChild(svg),
          svg.appendChild(this),
          (this.style.display = "block"),
          swapIfPossible)
        )
          try {
            (bbox = this.getBBox()),
              (this._gsapBBox = this.getBBox),
              (this.getBBox = _getBBoxHack);
          } catch (e) {}
        else this._gsapBBox && (bbox = this._gsapBBox());
        return (
          oldParent &&
            (oldSibling
              ? oldParent.insertBefore(this, oldSibling)
              : oldParent.appendChild(this)),
          _docElement.removeChild(svg),
          (this.style.cssText = oldCSS),
          bbox
        );
      }
      function _getAttributeFallbacks(target, attributesArray) {
        for (var i = attributesArray.length; i--; )
          if (target.hasAttribute(attributesArray[i]))
            return target.getAttribute(attributesArray[i]);
      }
      function _tweenComplexCSSString(target, prop, start, end) {
        (start && "none" !== start) ||
          ((s =
            (p = _checkPropPrefix(prop, target, 1)) &&
            _getComputedProperty(target, p, 1)) && s !== start
            ? ((prop = p), (start = s))
            : "borderColor" === prop &&
              (start = _getComputedProperty(target, "borderTopColor")));
        var s,
          p,
          startValues,
          startNum,
          color,
          startValue,
          endNum,
          result,
          endValue,
          startUnit,
          pt = new PropTween(
            this._pt,
            target.style,
            prop,
            0,
            1,
            _renderComplexString
          ),
          index = 0,
          matchIndex = 0;
        if (
          ((pt.b = start),
          (pt.e = end),
          (start += ""),
          "auto" === (end += "") &&
            ((startValue = target.style[prop]),
            (target.style[prop] = end),
            (end = _getComputedProperty(target, prop) || end),
            startValue
              ? (target.style[prop] = startValue)
              : _removeProperty(target, prop)),
          _colorStringFilter((p = [start, end])),
          (end = p[1]),
          (startValues = (start = p[0]).match(_numWithUnitExp) || []),
          (end.match(_numWithUnitExp) || []).length)
        ) {
          for (; (result = _numWithUnitExp.exec(end)); )
            (endValue = result[0]),
              (result = end.substring(index, result.index)),
              color
                ? (color = (color + 1) % 5)
                : ("rgba(" !== result.substr(-5) &&
                    "hsla(" !== result.substr(-5)) ||
                  (color = 1),
              endValue !== (startValue = startValues[matchIndex++] || "") &&
                ((startNum = parseFloat(startValue) || 0),
                (startUnit = startValue.substr((startNum + "").length)),
                "=" === endValue.charAt(1) &&
                  (endValue = _parseRelative(startNum, endValue) + startUnit),
                (endNum = parseFloat(endValue)),
                (endValue = endValue.substr((endNum + "").length)),
                (index = _numWithUnitExp.lastIndex - endValue.length),
                endValue ||
                  ((endValue = endValue || _config.units[prop] || startUnit),
                  index === end.length &&
                    ((end += endValue), (pt.e += endValue))),
                startUnit !== endValue &&
                  (startNum =
                    _convertToUnit(target, prop, startValue, endValue) || 0),
                (pt._pt = {
                  _next: pt._pt,
                  p: result || 1 === matchIndex ? result : ",",
                  s: startNum,
                  c: endNum - startNum,
                  m: (color && color < 4) || "zIndex" === prop ? Math.round : 0,
                }));
          pt.c = index < end.length ? end.substring(index, end.length) : "";
        } else
          pt.r =
            "display" === prop && "none" === end
              ? _renderNonTweeningValueOnlyAtEnd
              : _renderNonTweeningValue;
        return _relExp.test(end) && (pt.e = 0), (this._pt = pt);
      }
      function _convertKeywordsToPercentages(value) {
        var split = value.split(" "),
          x = split[0],
          y = split[1] || "50%";
        return (
          ("top" !== x && "bottom" !== x && "left" !== y && "right" !== y) ||
            ((value = x), (x = y), (y = value)),
          (split[0] = _keywordToPercent[x] || x),
          (split[1] = _keywordToPercent[y] || y),
          split.join(" ")
        );
      }
      function _renderClearProps(ratio, data) {
        if (data.tween && data.tween._time === data.tween._dur) {
          var prop,
            clearTransforms,
            i,
            target = data.t,
            style = target.style,
            props = data.u,
            data = target._gsap;
          if ("all" === props || !0 === props)
            (style.cssText = ""), (clearTransforms = 1);
          else
            for (i = (props = props.split(",")).length; -1 < --i; )
              (prop = props[i]),
                _transformProps[prop] &&
                  ((clearTransforms = 1),
                  (prop =
                    "transformOrigin" === prop
                      ? _transformOriginProp
                      : _transformProp)),
                _removeProperty(target, prop);
          clearTransforms &&
            (_removeProperty(target, _transformProp), data) &&
            (data.svg && target.removeAttribute("transform"),
            _parseTransform(target, 1),
            (data.uncache = 1),
            _removeIndependentTransforms(style));
        }
      }
      function _isNullTransform(value) {
        return (
          "matrix(1, 0, 0, 1, 0, 0)" === value || "none" === value || !value
        );
      }
      function _applySVGOrigin(
        target,
        origin,
        originIsAbsolute,
        smooth,
        matrixArray,
        pluginToAddPropTweensTo
      ) {
        var y,
          cache = target._gsap,
          matrixArray = matrixArray || _getMatrix(target, !0),
          xOriginOld = cache.xOrigin || 0,
          yOriginOld = cache.yOrigin || 0,
          xOffsetOld = cache.xOffset || 0,
          yOffsetOld = cache.yOffset || 0,
          a = matrixArray[0],
          b = matrixArray[1],
          c = matrixArray[2],
          d = matrixArray[3],
          tx = matrixArray[4],
          ty = matrixArray[5],
          originSplit = origin.split(" "),
          xOrigin = parseFloat(originSplit[0]) || 0,
          yOrigin = parseFloat(originSplit[1]) || 0;
        originIsAbsolute
          ? matrixArray !== _identity2DMatrix &&
            (matrixArray = a * d - b * c) &&
            ((y =
              xOrigin * (-b / matrixArray) +
              yOrigin * (a / matrixArray) -
              (a * ty - b * tx) / matrixArray),
            (xOrigin =
              xOrigin * (d / matrixArray) +
              yOrigin * (-c / matrixArray) +
              (c * ty - d * tx) / matrixArray),
            (yOrigin = y))
          : ((xOrigin =
              (matrixArray = _getBBox(target)).x +
              (~originSplit[0].indexOf("%")
                ? (xOrigin / 100) * matrixArray.width
                : xOrigin)),
            (yOrigin =
              matrixArray.y +
              (~(originSplit[1] || originSplit[0]).indexOf("%")
                ? (yOrigin / 100) * matrixArray.height
                : yOrigin))),
          smooth || (!1 !== smooth && cache.smooth)
            ? ((cache.xOffset =
                xOffsetOld +
                ((tx = xOrigin - xOriginOld) * a +
                  (ty = yOrigin - yOriginOld) * c) -
                tx),
              (cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty))
            : (cache.xOffset = cache.yOffset = 0),
          (cache.xOrigin = xOrigin),
          (cache.yOrigin = yOrigin),
          (cache.smooth = !!smooth),
          (cache.origin = origin),
          (cache.originIsAbsolute = !!originIsAbsolute),
          (target.style[_transformOriginProp] = "0px 0px"),
          pluginToAddPropTweensTo &&
            (_addNonTweeningPT(
              pluginToAddPropTweensTo,
              cache,
              "xOrigin",
              xOriginOld,
              xOrigin
            ),
            _addNonTweeningPT(
              pluginToAddPropTweensTo,
              cache,
              "yOrigin",
              yOriginOld,
              yOrigin
            ),
            _addNonTweeningPT(
              pluginToAddPropTweensTo,
              cache,
              "xOffset",
              xOffsetOld,
              cache.xOffset
            ),
            _addNonTweeningPT(
              pluginToAddPropTweensTo,
              cache,
              "yOffset",
              yOffsetOld,
              cache.yOffset
            )),
          target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
      }
      function _addPxTranslate(target, start, value) {
        var unit = getUnit(start);
        return (
          _round(
            parseFloat(start) +
              parseFloat(_convertToUnit(target, "x", value + "px", unit))
          ) + unit
        );
      }
      function _addRotationalPropTween(
        plugin,
        target,
        property,
        startNum,
        endValue
      ) {
        var isString = _isString(endValue),
          change =
            parseFloat(endValue) *
              (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1) -
            startNum,
          finalValue = startNum + change + "deg";
        return (
          isString &&
            ("short" === (isString = endValue.split("_")[1]) &&
              (change %= 360) !== change % 180 &&
              (change += change < 0 ? 360 : -360),
            "cw" === isString && change < 0
              ? (change = ((change + 36e9) % 360) - 360 * ~~(change / 360))
              : "ccw" === isString &&
                0 < change &&
                (change = ((change - 36e9) % 360) - 360 * ~~(change / 360))),
          (plugin._pt = endValue =
            new PropTween(
              plugin._pt,
              target,
              property,
              startNum,
              change,
              _renderPropWithEnd
            )),
          (endValue.e = finalValue),
          (endValue.u = "deg"),
          plugin._props.push(property),
          endValue
        );
      }
      function _assign(target, source) {
        for (var p in source) target[p] = source[p];
        return target;
      }
      function _addRawTransformPTs(plugin, transforms, target) {
        var endCache,
          p,
          startValue,
          startNum,
          endValue,
          endUnit,
          startCache = _assign({}, target._gsap),
          style = target.style;
        for (p in (startCache.svg
          ? ((startValue = target.getAttribute("transform")),
            target.setAttribute("transform", ""),
            (style[_transformProp] = transforms),
            (endCache = _parseTransform(target, 1)),
            _removeProperty(target, _transformProp),
            target.setAttribute("transform", startValue))
          : ((startValue = getComputedStyle(target)[_transformProp]),
            (style[_transformProp] = transforms),
            (endCache = _parseTransform(target, 1)),
            (style[_transformProp] = startValue)),
        _transformProps))
          (startValue = startCache[p]) !== (endValue = endCache[p]) &&
            "perspective,force3D,transformOrigin,svgOrigin".indexOf(p) < 0 &&
            ((startNum =
              getUnit(startValue) !== (endUnit = getUnit(endValue))
                ? _convertToUnit(target, p, startValue, endUnit)
                : parseFloat(startValue)),
            (endValue = parseFloat(endValue)),
            (plugin._pt = new PropTween(
              plugin._pt,
              endCache,
              p,
              startNum,
              endValue - startNum,
              _renderCSSProp
            )),
            (plugin._pt.u = endUnit || 0),
            plugin._props.push(p));
        _assign(endCache, startCache);
      }
      var _overwritingTween,
        _forceAllPropTweens,
        CSSPlugin_win,
        CSSPlugin_doc,
        _docElement,
        _pluginInitted,
        _tempDiv,
        _recentSetterPlugin,
        CSSPlugin_reverting,
        _supports3D,
        all,
        GSCache = function GSCache(target, harness) {
          (this.id = _gsID++),
            ((target._gsap = this).target = target),
            (this.harness = harness),
            (this.get = harness ? harness.get : _getProperty),
            (this.set = harness ? harness.getSetter : _getSetter);
        },
        Animation = (function () {
          function Animation(vars) {
            (this.vars = vars),
              (this._delay = +vars.delay || 0),
              (this._repeat = vars.repeat === 1 / 0 ? -2 : vars.repeat || 0) &&
                ((this._rDelay = vars.repeatDelay || 0),
                (this._yoyo = !!vars.yoyo || !!vars.yoyoEase)),
              (this._ts = 1),
              _setDuration(this, +vars.duration, 1, 1),
              (this.data = vars.data),
              _context && (this._ctx = _context).data.push(this),
              _tickerActive || _ticker.wake();
          }
          var _proto = Animation.prototype;
          return (
            (_proto.delay = function delay(value) {
              return value || 0 === value
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + value - this._delay),
                  (this._delay = value),
                  this)
                : this._delay;
            }),
            (_proto.duration = function duration(value) {
              return arguments.length
                ? this.totalDuration(
                    0 < this._repeat
                      ? value + (value + this._rDelay) * this._repeat
                      : value
                  )
                : this.totalDuration() && this._dur;
            }),
            (_proto.totalDuration = function totalDuration(value) {
              return arguments.length
                ? ((this._dirty = 0),
                  _setDuration(
                    this,
                    this._repeat < 0
                      ? value
                      : (value - this._repeat * this._rDelay) /
                          (this._repeat + 1)
                  ))
                : this._tDur;
            }),
            (_proto.totalTime = function totalTime(_totalTime, suppressEvents) {
              if ((_wake(), !arguments.length)) return this._tTime;
              var parent = this._dp;
              if (parent && parent.smoothChildTiming && this._ts) {
                for (
                  _alignPlayhead(this, _totalTime),
                    parent._dp &&
                      !parent.parent &&
                      _postAddChecks(parent, this);
                  parent && parent.parent;

                )
                  parent.parent._time !==
                    parent._start +
                      (0 <= parent._ts
                        ? parent._tTime / parent._ts
                        : (parent.totalDuration() - parent._tTime) /
                          -parent._ts) && parent.totalTime(parent._tTime, !0),
                    (parent = parent.parent);
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((0 < this._ts && _totalTime < this._tDur) ||
                    (this._ts < 0 && 0 < _totalTime) ||
                    (!this._tDur && !_totalTime)) &&
                  _addToTimeline(this._dp, this, this._start - this._delay);
              }
              return (
                (this._tTime !== _totalTime ||
                  (!this._dur && !suppressEvents) ||
                  (this._initted && Math.abs(this._zTime) === _tinyNum) ||
                  (!_totalTime &&
                    !this._initted &&
                    (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = _totalTime),
                  _lazySafeRender(this, _totalTime, suppressEvents)),
                this
              );
            }),
            (_proto.time = function time(value, suppressEvents) {
              return arguments.length
                ? this.totalTime(
                    Math.min(
                      this.totalDuration(),
                      value + _elapsedCycleDuration(this)
                    ) %
                      (this._dur + this._rDelay) || (value ? this._dur : 0),
                    suppressEvents
                  )
                : this._time;
            }),
            (_proto.totalProgress = function totalProgress(
              value,
              suppressEvents
            ) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * value, suppressEvents)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : 0 < this.rawTime()
                ? 1
                : 0;
            }),
            (_proto.progress = function progress(value, suppressEvents) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration()
                        ? value
                        : 1 - value) +
                      _elapsedCycleDuration(this),
                    suppressEvents
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : 0 < this.rawTime()
                ? 1
                : 0;
            }),
            (_proto.iteration = function iteration(value, suppressEvents) {
              var cycleDuration = this.duration() + this._rDelay;
              return arguments.length
                ? this.totalTime(
                    this._time + (value - 1) * cycleDuration,
                    suppressEvents
                  )
                : this._repeat
                ? _animationCycle(this._tTime, cycleDuration) + 1
                : 1;
            }),
            (_proto.timeScale = function timeScale(value, suppressEvents) {
              var tTime;
              return arguments.length
                ? this._rts === value
                  ? this
                  : ((tTime =
                      this.parent && this._ts
                        ? _parentToChildTotalTime(this.parent._time, this)
                        : this._tTime),
                    (this._rts = +value || 0),
                    (this._ts =
                      this._ps || value === -_tinyNum ? 0 : this._rts),
                    this.totalTime(
                      _clamp(-Math.abs(this._delay), this._tDur, tTime),
                      !1 !== suppressEvents
                    ),
                    _setEnd(this),
                    _recacheAncestors(this))
                : this._rts === -_tinyNum
                ? 0
                : this._rts;
            }),
            (_proto.paused = function paused(value) {
              return arguments.length
                ? (this._ps !== value &&
                    ((this._ps = value)
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (_wake(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            Math.abs(this._zTime) !== _tinyNum &&
                            (this._tTime -= _tinyNum)
                        ))),
                  this)
                : this._ps;
            }),
            (_proto.startTime = function startTime(value) {
              var parent;
              return arguments.length
                ? ((this._start = value),
                  !(parent = this.parent || this._dp) ||
                    (!parent._sort && this.parent) ||
                    _addToTimeline(parent, this, value - this._delay),
                  this)
                : this._start;
            }),
            (_proto.endTime = function endTime(includeRepeats) {
              return (
                this._start +
                (_isNotFalse(includeRepeats)
                  ? this.totalDuration()
                  : this.duration()) /
                  Math.abs(this._ts || 1)
              );
            }),
            (_proto.rawTime = function rawTime(wrapRepeats) {
              var parent = this.parent || this._dp;
              return parent
                ? wrapRepeats &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? _parentToChildTotalTime(parent.rawTime(wrapRepeats), this)
                  : this._tTime
                : this._tTime;
            }),
            (_proto.revert = function revert(config) {
              var prevIsReverting = _reverting;
              return (
                (_reverting = config =
                  void 0 === config ? _revertConfig : config),
                (this._initted || this._startAt) &&
                  (this.timeline && this.timeline.revert(config),
                  this.totalTime(-0.01, config.suppressEvents)),
                "nested" !== this.data && !1 !== config.kill && this.kill(),
                (_reverting = prevIsReverting),
                this
              );
            }),
            (_proto.globalTime = function globalTime(rawTime) {
              for (
                var animation = this,
                  time = arguments.length ? rawTime : animation.rawTime();
                animation;

              )
                (time =
                  animation._start + time / (Math.abs(animation._ts) || 1)),
                  (animation = animation._dp);
              return !this.parent && this._sat
                ? this._sat.globalTime(rawTime)
                : time;
            }),
            (_proto.repeat = function repeat(value) {
              return arguments.length
                ? ((this._repeat = value === 1 / 0 ? -2 : value),
                  _onUpdateTotalDuration(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat;
            }),
            (_proto.repeatDelay = function repeatDelay(value) {
              var time;
              return arguments.length
                ? ((time = this._time),
                  (this._rDelay = value),
                  _onUpdateTotalDuration(this),
                  time ? this.time(time) : this)
                : this._rDelay;
            }),
            (_proto.yoyo = function yoyo(value) {
              return arguments.length
                ? ((this._yoyo = value), this)
                : this._yoyo;
            }),
            (_proto.seek = function seek(position, suppressEvents) {
              return this.totalTime(
                _parsePosition(this, position),
                _isNotFalse(suppressEvents)
              );
            }),
            (_proto.restart = function restart(includeDelay, suppressEvents) {
              return this.play().totalTime(
                includeDelay ? -this._delay : 0,
                _isNotFalse(suppressEvents)
              );
            }),
            (_proto.play = function play(from, suppressEvents) {
              return (
                null != from && this.seek(from, suppressEvents),
                this.reversed(!1).paused(!1)
              );
            }),
            (_proto.reverse = function reverse(from, suppressEvents) {
              return (
                null != from &&
                  this.seek(from || this.totalDuration(), suppressEvents),
                this.reversed(!0).paused(!1)
              );
            }),
            (_proto.pause = function pause(atTime, suppressEvents) {
              return (
                null != atTime && this.seek(atTime, suppressEvents),
                this.paused(!0)
              );
            }),
            (_proto.resume = function resume() {
              return this.paused(!1);
            }),
            (_proto.reversed = function reversed(value) {
              return arguments.length
                ? (!!value !== this.reversed() &&
                    this.timeScale(-this._rts || (value ? -_tinyNum : 0)),
                  this)
                : this._rts < 0;
            }),
            (_proto.invalidate = function invalidate() {
              return (
                (this._initted = this._act = 0), (this._zTime = -_tinyNum), this
              );
            }),
            (_proto.isActive = function isActive() {
              var parent = this.parent || this._dp,
                start = this._start;
              return !(
                parent &&
                !(
                  this._ts &&
                  this._initted &&
                  parent.isActive() &&
                  (parent = parent.rawTime(!0)) >= start &&
                  parent < this.endTime(!0) - _tinyNum
                )
              );
            }),
            (_proto.eventCallback = function eventCallback(
              type,
              callback,
              params
            ) {
              var vars = this.vars;
              return 1 < arguments.length
                ? (callback
                    ? ((vars[type] = callback),
                      params && (vars[type + "Params"] = params),
                      "onUpdate" === type && (this._onUpdate = callback))
                    : delete vars[type],
                  this)
                : vars[type];
            }),
            (_proto.then = function then(onFulfilled) {
              var self = this;
              return new Promise(function (resolve) {
                function _resolve() {
                  var _then = self.then;
                  (self.then = null),
                    _isFunction(f) &&
                      (f = f(self)) &&
                      (f.then || f === self) &&
                      (self.then = _then),
                    resolve(f),
                    (self.then = _then);
                }
                var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough;
                (self._initted &&
                  1 === self.totalProgress() &&
                  0 <= self._ts) ||
                (!self._tTime && self._ts < 0)
                  ? _resolve()
                  : (self._prom = _resolve);
              });
            }),
            (_proto.kill = function kill() {
              _interrupt(this);
            }),
            Animation
          );
        })(),
        Timeline =
          (_setDefaults(Animation.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -_tinyNum,
            _prom: 0,
            _ps: !1,
            _rts: 1,
          }),
          (function (_Animation) {
            function Timeline(vars, position) {
              var _this;
              return (
                ((_this =
                  _Animation.call(this, (vars = void 0 === vars ? {} : vars)) ||
                  this).labels = {}),
                (_this.smoothChildTiming = !!vars.smoothChildTiming),
                (_this.autoRemoveChildren = !!vars.autoRemoveChildren),
                (_this._sort = _isNotFalse(vars.sortChildren)),
                _globalTimeline &&
                  _addToTimeline(
                    vars.parent || _globalTimeline,
                    _assertThisInitialized(_this),
                    position
                  ),
                vars.reversed && _this.reverse(),
                vars.paused && _this.paused(!0),
                vars.scrollTrigger &&
                  _scrollTrigger(
                    _assertThisInitialized(_this),
                    vars.scrollTrigger
                  ),
                _this
              );
            }
            _inheritsLoose(Timeline, _Animation);
            var _proto2 = Timeline.prototype;
            return (
              (_proto2.to = function to(targets, vars, position) {
                return _createTweenType(0, arguments, this), this;
              }),
              (_proto2.from = function from(targets, vars, position) {
                return _createTweenType(1, arguments, this), this;
              }),
              (_proto2.fromTo = function fromTo(
                targets,
                fromVars,
                toVars,
                position
              ) {
                return _createTweenType(2, arguments, this), this;
              }),
              (_proto2.set = function set(targets, vars, position) {
                return (
                  (vars.duration = 0),
                  (vars.parent = this),
                  _inheritDefaults(vars).repeatDelay || (vars.repeat = 0),
                  (vars.immediateRender = !!vars.immediateRender),
                  new Tween(targets, vars, _parsePosition(this, position), 1),
                  this
                );
              }),
              (_proto2.call = function call(callback, params, position) {
                return _addToTimeline(
                  this,
                  Tween.delayedCall(0, callback, params),
                  position
                );
              }),
              (_proto2.staggerTo = function staggerTo(
                targets,
                duration,
                vars,
                stagger,
                position,
                onCompleteAll,
                onCompleteAllParams
              ) {
                return (
                  (vars.duration = duration),
                  (vars.stagger = vars.stagger || stagger),
                  (vars.onComplete = onCompleteAll),
                  (vars.onCompleteParams = onCompleteAllParams),
                  (vars.parent = this),
                  new Tween(targets, vars, _parsePosition(this, position)),
                  this
                );
              }),
              (_proto2.staggerFrom = function staggerFrom(
                targets,
                duration,
                vars,
                stagger,
                position,
                onCompleteAll,
                onCompleteAllParams
              ) {
                return (
                  (vars.runBackwards = 1),
                  (_inheritDefaults(vars).immediateRender = _isNotFalse(
                    vars.immediateRender
                  )),
                  this.staggerTo(
                    targets,
                    duration,
                    vars,
                    stagger,
                    position,
                    onCompleteAll,
                    onCompleteAllParams
                  )
                );
              }),
              (_proto2.staggerFromTo = function staggerFromTo(
                targets,
                duration,
                fromVars,
                toVars,
                stagger,
                position,
                onCompleteAll,
                onCompleteAllParams
              ) {
                return (
                  (toVars.startAt = fromVars),
                  (_inheritDefaults(toVars).immediateRender = _isNotFalse(
                    toVars.immediateRender
                  )),
                  this.staggerTo(
                    targets,
                    duration,
                    toVars,
                    stagger,
                    position,
                    onCompleteAll,
                    onCompleteAllParams
                  )
                );
              }),
              (_proto2.render = function render(
                totalTime,
                suppressEvents,
                force
              ) {
                var time,
                  next,
                  iteration,
                  cycleDuration,
                  prevPaused,
                  pauseTween,
                  timeScale,
                  prevStart,
                  prevIteration,
                  isYoyo,
                  prevTime = this._time,
                  tDur = this._dirty ? this.totalDuration() : this._tDur,
                  dur = this._dur,
                  tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
                  crossingStart =
                    this._zTime < 0 != totalTime < 0 && (this._initted || !dur);
                if (
                  (tTime =
                    this !== _globalTimeline && tDur < tTime && 0 <= totalTime
                      ? tDur
                      : tTime) !== this._tTime ||
                  force ||
                  crossingStart
                ) {
                  if (
                    (prevTime !== this._time &&
                      dur &&
                      ((tTime += this._time - prevTime),
                      (totalTime += this._time - prevTime)),
                    (time = tTime),
                    (prevStart = this._start),
                    (prevPaused = !(timeScale = this._ts)),
                    crossingStart &&
                      (dur || (prevTime = this._zTime),
                      (!totalTime && suppressEvents) ||
                        (this._zTime = totalTime)),
                    this._repeat)
                  ) {
                    if (
                      ((crossingStart = this._yoyo),
                      (cycleDuration = dur + this._rDelay),
                      this._repeat < -1 && totalTime < 0)
                    )
                      return this.totalTime(
                        100 * cycleDuration + totalTime,
                        suppressEvents,
                        force
                      );
                    if (
                      ((time = _roundPrecise(tTime % cycleDuration)),
                      tTime === tDur
                        ? ((iteration = this._repeat), (time = dur))
                        : ((iteration = ~~(tTime / cycleDuration)) &&
                            iteration === tTime / cycleDuration &&
                            ((time = dur), iteration--),
                          dur < time && (time = dur)),
                      (prevIteration = _animationCycle(
                        this._tTime,
                        cycleDuration
                      )),
                      crossingStart &&
                        1 & iteration &&
                        ((time = dur - time), (isYoyo = 1)),
                      iteration !==
                        (prevIteration =
                          !prevTime &&
                          this._tTime &&
                          prevIteration !== iteration &&
                          this._tTime -
                            prevIteration * cycleDuration -
                            this._dur <=
                            0
                            ? iteration
                            : prevIteration) && !this._lock)
                    ) {
                      var rewinding = crossingStart && 1 & prevIteration,
                        crossingStart =
                          rewinding === (crossingStart && 1 & iteration),
                        prevTime = (rewinding =
                          iteration < prevIteration ? !rewinding : rewinding)
                          ? 0
                          : tTime % dur
                          ? dur
                          : tTime;
                      if (
                        ((this._lock = 1),
                        (this.render(
                          prevTime ||
                            (isYoyo
                              ? 0
                              : _roundPrecise(iteration * cycleDuration)),
                          suppressEvents,
                          !dur
                        )._lock = 0),
                        (this._tTime = tTime),
                        !suppressEvents &&
                          this.parent &&
                          _callback(this, "onRepeat"),
                        this.vars.repeatRefresh &&
                          !isYoyo &&
                          (this.invalidate()._lock = 1),
                        (prevTime && prevTime !== this._time) ||
                          prevPaused != !this._ts ||
                          (this.vars.onRepeat && !this.parent && !this._act))
                      )
                        return this;
                      if (
                        ((dur = this._dur),
                        (tDur = this._tDur),
                        crossingStart &&
                          ((this._lock = 2),
                          this.render((prevTime = rewinding ? dur : -1e-4), !0),
                          this.vars.repeatRefresh) &&
                          !isYoyo &&
                          this.invalidate(),
                        (this._lock = 0),
                        !this._ts && !prevPaused)
                      )
                        return this;
                      _propagateYoyoEase(this, isYoyo);
                    }
                  }
                  if (
                    (this._hasPause &&
                      !this._forcing &&
                      this._lock < 2 &&
                      (pauseTween = _findNextPauseTween(
                        this,
                        _roundPrecise(prevTime),
                        _roundPrecise(time)
                      )) &&
                      (tTime -= time - (time = pauseTween._start)),
                    (this._tTime = tTime),
                    (this._time = time),
                    (this._act = !timeScale),
                    this._initted ||
                      ((this._onUpdate = this.vars.onUpdate),
                      (this._initted = 1),
                      (this._zTime = totalTime),
                      (prevTime = 0)),
                    !prevTime &&
                      time &&
                      !suppressEvents &&
                      !iteration &&
                      (_callback(this, "onStart"), this._tTime !== tTime))
                  )
                    return this;
                  if (prevTime <= time && 0 <= totalTime)
                    for (child = this._first; child; ) {
                      if (
                        ((next = child._next),
                        (child._act || time >= child._start) &&
                          child._ts &&
                          pauseTween !== child)
                      ) {
                        if (child.parent !== this)
                          return this.render(totalTime, suppressEvents, force);
                        if (
                          (child.render(
                            0 < child._ts
                              ? (time - child._start) * child._ts
                              : (child._dirty
                                  ? child.totalDuration()
                                  : child._tDur) +
                                  (time - child._start) * child._ts,
                            suppressEvents,
                            force
                          ),
                          time !== this._time || (!this._ts && !prevPaused))
                        ) {
                          (pauseTween = 0),
                            next && (tTime += this._zTime = -_tinyNum);
                          break;
                        }
                      }
                      child = next;
                    }
                  else
                    for (
                      var child = this._last,
                        adjustedTime = totalTime < 0 ? totalTime : time;
                      child;

                    ) {
                      if (
                        ((next = child._prev),
                        (child._act || adjustedTime <= child._end) &&
                          child._ts &&
                          pauseTween !== child)
                      ) {
                        if (child.parent !== this)
                          return this.render(totalTime, suppressEvents, force);
                        if (
                          (child.render(
                            0 < child._ts
                              ? (adjustedTime - child._start) * child._ts
                              : (child._dirty
                                  ? child.totalDuration()
                                  : child._tDur) +
                                  (adjustedTime - child._start) * child._ts,
                            suppressEvents,
                            force ||
                              (_reverting && (child._initted || child._startAt))
                          ),
                          time !== this._time || (!this._ts && !prevPaused))
                        ) {
                          (pauseTween = 0),
                            next &&
                              (tTime += this._zTime =
                                adjustedTime ? -_tinyNum : _tinyNum);
                          break;
                        }
                      }
                      child = next;
                    }
                  if (
                    pauseTween &&
                    !suppressEvents &&
                    (this.pause(),
                    (pauseTween.render(
                      prevTime <= time ? 0 : -_tinyNum
                    )._zTime = prevTime <= time ? 1 : -1),
                    this._ts)
                  )
                    return (
                      (this._start = prevStart),
                      _setEnd(this),
                      this.render(totalTime, suppressEvents, force)
                    );
                  this._onUpdate &&
                    !suppressEvents &&
                    _callback(this, "onUpdate", !0),
                    !(
                      (tTime === tDur && this._tTime >= this.totalDuration()) ||
                      (!tTime && prevTime)
                    ) ||
                      (prevStart !== this._start &&
                        Math.abs(timeScale) === Math.abs(this._ts)) ||
                      this._lock ||
                      ((!totalTime && dur) ||
                        !(
                          (tTime === tDur && 0 < this._ts) ||
                          (!tTime && this._ts < 0)
                        ) ||
                        _removeFromParent(this, 1),
                      suppressEvents) ||
                      (totalTime < 0 && !prevTime) ||
                      (!tTime && !prevTime && tDur) ||
                      (_callback(
                        this,
                        tTime === tDur && 0 <= totalTime
                          ? "onComplete"
                          : "onReverseComplete",
                        !0
                      ),
                      !this._prom) ||
                      (tTime < tDur && 0 < this.timeScale()) ||
                      this._prom();
                }
                return this;
              }),
              (_proto2.add = function add(child, position) {
                var _this2 = this;
                if (
                  (_isNumber(position) ||
                    (position = _parsePosition(this, position, child)),
                  !(child instanceof Animation))
                ) {
                  if (_isArray(child))
                    return (
                      child.forEach(function (obj) {
                        return _this2.add(obj, position);
                      }),
                      this
                    );
                  if (_isString(child)) return this.addLabel(child, position);
                  if (!_isFunction(child)) return this;
                  child = Tween.delayedCall(0, child);
                }
                return this !== child
                  ? _addToTimeline(this, child, position)
                  : this;
              }),
              (_proto2.getChildren = function getChildren(
                nested,
                tweens,
                timelines,
                ignoreBeforeTime
              ) {
                void 0 === nested && (nested = !0),
                  void 0 === tweens && (tweens = !0),
                  void 0 === timelines && (timelines = !0),
                  void 0 === ignoreBeforeTime && (ignoreBeforeTime = -_bigNum);
                for (var a = [], child = this._first; child; )
                  child._start >= ignoreBeforeTime &&
                    (child instanceof Tween
                      ? tweens && a.push(child)
                      : (timelines && a.push(child),
                        nested &&
                          a.push.apply(
                            a,
                            child.getChildren(!0, tweens, timelines)
                          ))),
                    (child = child._next);
                return a;
              }),
              (_proto2.getById = function getById(id) {
                for (
                  var animations = this.getChildren(1, 1, 1),
                    i = animations.length;
                  i--;

                )
                  if (animations[i].vars.id === id) return animations[i];
              }),
              (_proto2.remove = function remove(child) {
                return _isString(child)
                  ? this.removeLabel(child)
                  : _isFunction(child)
                  ? this.killTweensOf(child)
                  : (_removeLinkedListItem(this, child),
                    child === this._recent && (this._recent = this._last),
                    _uncache(this));
              }),
              (_proto2.totalTime = function totalTime(
                _totalTime2,
                suppressEvents
              ) {
                return arguments.length
                  ? ((this._forcing = 1),
                    !this._dp &&
                      this._ts &&
                      (this._start = _roundPrecise(
                        _ticker.time -
                          (0 < this._ts
                            ? _totalTime2 / this._ts
                            : (this.totalDuration() - _totalTime2) / -this._ts)
                      )),
                    _Animation.prototype.totalTime.call(
                      this,
                      _totalTime2,
                      suppressEvents
                    ),
                    (this._forcing = 0),
                    this)
                  : this._tTime;
              }),
              (_proto2.addLabel = function addLabel(label, position) {
                return (
                  (this.labels[label] = _parsePosition(this, position)), this
                );
              }),
              (_proto2.removeLabel = function removeLabel(label) {
                return delete this.labels[label], this;
              }),
              (_proto2.addPause = function addPause(
                position,
                callback,
                params
              ) {
                callback = Tween.delayedCall(0, callback || _emptyFunc, params);
                return (
                  (callback.data = "isPause"),
                  (this._hasPause = 1),
                  _addToTimeline(this, callback, _parsePosition(this, position))
                );
              }),
              (_proto2.removePause = function removePause(position) {
                var child = this._first;
                for (position = _parsePosition(this, position); child; )
                  child._start === position &&
                    "isPause" === child.data &&
                    _removeFromParent(child),
                    (child = child._next);
              }),
              (_proto2.killTweensOf = function killTweensOf(
                targets,
                props,
                onlyActive
              ) {
                for (
                  var tweens = this.getTweensOf(targets, onlyActive),
                    i = tweens.length;
                  i--;

                )
                  _overwritingTween !== tweens[i] &&
                    tweens[i].kill(targets, props);
                return this;
              }),
              (_proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                for (
                  var children,
                    a = [],
                    parsedTargets = toArray(targets),
                    child = this._first,
                    isGlobalTime = _isNumber(onlyActive);
                  child;

                )
                  child instanceof Tween
                    ? _arrayContainsAny(child._targets, parsedTargets) &&
                      (isGlobalTime
                        ? (!_overwritingTween ||
                            (child._initted && child._ts)) &&
                          child.globalTime(0) <= onlyActive &&
                          child.globalTime(child.totalDuration()) > onlyActive
                        : !onlyActive || child.isActive()) &&
                      a.push(child)
                    : (children = child.getTweensOf(parsedTargets, onlyActive))
                        .length && a.push.apply(a, children),
                    (child = child._next);
                return a;
              }),
              (_proto2.tweenTo = function tweenTo(position, vars) {
                vars = vars || {};
                var initted,
                  tl = this,
                  endTime = _parsePosition(tl, position),
                  position = vars,
                  startAt = position.startAt,
                  _onStart = position.onStart,
                  onStartParams = position.onStartParams,
                  position = position.immediateRender,
                  tween = Tween.to(
                    tl,
                    _setDefaults(
                      {
                        ease: vars.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: endTime,
                        overwrite: "auto",
                        duration:
                          vars.duration ||
                          Math.abs(
                            (endTime -
                              (startAt && "time" in startAt
                                ? startAt.time
                                : tl._time)) /
                              tl.timeScale()
                          ) ||
                          _tinyNum,
                        onStart: function onStart() {
                          var duration;
                          tl.pause(),
                            initted ||
                              ((duration =
                                vars.duration ||
                                Math.abs(
                                  (endTime -
                                    (startAt && "time" in startAt
                                      ? startAt.time
                                      : tl._time)) /
                                    tl.timeScale()
                                )),
                              tween._dur !== duration &&
                                _setDuration(tween, duration, 0, 1).render(
                                  tween._time,
                                  !0,
                                  !0
                                ),
                              (initted = 1)),
                            _onStart &&
                              _onStart.apply(tween, onStartParams || []);
                        },
                      },
                      vars
                    )
                  );
                return position ? tween.render(0) : tween;
              }),
              (_proto2.tweenFromTo = function tweenFromTo(
                fromPosition,
                toPosition,
                vars
              ) {
                return this.tweenTo(
                  toPosition,
                  _setDefaults(
                    { startAt: { time: _parsePosition(this, fromPosition) } },
                    vars
                  )
                );
              }),
              (_proto2.recent = function recent() {
                return this._recent;
              }),
              (_proto2.nextLabel = function nextLabel(afterTime) {
                return (
                  void 0 === afterTime && (afterTime = this._time),
                  _getLabelInDirection(this, _parsePosition(this, afterTime))
                );
              }),
              (_proto2.previousLabel = function previousLabel(beforeTime) {
                return (
                  void 0 === beforeTime && (beforeTime = this._time),
                  _getLabelInDirection(
                    this,
                    _parsePosition(this, beforeTime),
                    1
                  )
                );
              }),
              (_proto2.currentLabel = function currentLabel(value) {
                return arguments.length
                  ? this.seek(value, !0)
                  : this.previousLabel(this._time + _tinyNum);
              }),
              (_proto2.shiftChildren = function shiftChildren(
                amount,
                adjustLabels,
                ignoreBeforeTime
              ) {
                void 0 === ignoreBeforeTime && (ignoreBeforeTime = 0);
                for (var p, child = this._first, labels = this.labels; child; )
                  child._start >= ignoreBeforeTime &&
                    ((child._start += amount), (child._end += amount)),
                    (child = child._next);
                if (adjustLabels)
                  for (p in labels)
                    labels[p] >= ignoreBeforeTime && (labels[p] += amount);
                return _uncache(this);
              }),
              (_proto2.invalidate = function invalidate(soft) {
                var child = this._first;
                for (this._lock = 0; child; )
                  child.invalidate(soft), (child = child._next);
                return _Animation.prototype.invalidate.call(this, soft);
              }),
              (_proto2.clear = function clear(includeLabels) {
                void 0 === includeLabels && (includeLabels = !0);
                for (var next, child = this._first; child; )
                  (next = child._next), this.remove(child), (child = next);
                return (
                  this._dp && (this._time = this._tTime = this._pTime = 0),
                  includeLabels && (this.labels = {}),
                  _uncache(this)
                );
              }),
              (_proto2.totalDuration = function totalDuration(value) {
                var prev,
                  start,
                  parent,
                  max = 0,
                  child = this._last,
                  prevStart = _bigNum;
                if (arguments.length)
                  return this.timeScale(
                    (this._repeat < 0
                      ? this.duration()
                      : this.totalDuration()) /
                      (this.reversed() ? -value : value)
                  );
                if (this._dirty) {
                  for (parent = this.parent; child; )
                    (prev = child._prev),
                      child._dirty && child.totalDuration(),
                      prevStart < (start = child._start) &&
                      this._sort &&
                      child._ts &&
                      !this._lock
                        ? ((this._lock = 1),
                          (_addToTimeline(
                            this,
                            child,
                            start - child._delay,
                            1
                          )._lock = 0))
                        : (prevStart = start),
                      start < 0 &&
                        child._ts &&
                        ((max -= start),
                        ((!parent && !this._dp) ||
                          (parent && parent.smoothChildTiming)) &&
                          ((this._start += start / this._ts),
                          (this._time -= start),
                          (this._tTime -= start)),
                        this.shiftChildren(-start, !1, -1 / 0),
                        (prevStart = 0)),
                      child._end > max && child._ts && (max = child._end),
                      (child = prev);
                  _setDuration(
                    this,
                    this === _globalTimeline && this._time > max
                      ? this._time
                      : max,
                    1,
                    1
                  ),
                    (this._dirty = 0);
                }
                return this._tDur;
              }),
              (Timeline.updateRoot = function updateRoot(time) {
                if (
                  (_globalTimeline._ts &&
                    (_lazySafeRender(
                      _globalTimeline,
                      _parentToChildTotalTime(time, _globalTimeline)
                    ),
                    (_lastRenderedFrame = _ticker.frame)),
                  _ticker.frame >= _nextGCFrame)
                ) {
                  _nextGCFrame += _config.autoSleep || 120;
                  var child = _globalTimeline._first;
                  if (
                    (!child || !child._ts) &&
                    _config.autoSleep &&
                    _ticker._listeners.length < 2
                  ) {
                    for (; child && !child._ts; ) child = child._next;
                    child || _ticker.sleep();
                  }
                }
              }),
              Timeline
            );
          })(Animation)),
        _addPropTween =
          (_setDefaults(Timeline.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0,
          }),
          function _addPropTween(
            target,
            prop,
            start,
            end,
            index,
            targets,
            modifier,
            stringFilter,
            funcParam,
            optional
          ) {
            _isFunction(end) && (end = end(index || 0, target, targets));
            var pt,
              index = target[prop],
              targets =
                "get" !== start
                  ? start
                  : _isFunction(index)
                  ? funcParam
                    ? target[
                        prop.indexOf("set") ||
                        !_isFunction(target["get" + prop.substr(3)])
                          ? prop
                          : "get" + prop.substr(3)
                      ](funcParam)
                    : target[prop]()
                  : index,
              start = _isFunction(index)
                ? funcParam
                  ? _setterFuncWithParam
                  : _setterFunc
                : _setterPlain;
            if (
              (!_isString(end) ||
                "=" !==
                  (end = ~end.indexOf("random(")
                    ? _replaceRandom(end)
                    : end).charAt(1) ||
                (!(pt =
                  _parseRelative(targets, end) + (getUnit(targets) || 0)) &&
                  0 !== pt) ||
                (end = pt),
              !optional || targets !== end || _forceAllPropTweens)
            )
              return isNaN(targets * end) || "" === end
                ? (index || prop in target || _missingPlugin(prop, end),
                  _addComplexStringPropTween.call(
                    this,
                    target,
                    prop,
                    targets,
                    end,
                    start,
                    stringFilter || _config.stringFilter,
                    funcParam
                  ))
                : ((pt = new PropTween(
                    this._pt,
                    target,
                    prop,
                    +targets || 0,
                    end - (targets || 0),
                    "boolean" == typeof index ? _renderBoolean : _renderPlain,
                    0,
                    start
                  )),
                  funcParam && (pt.fp = funcParam),
                  modifier && pt.modifier(modifier, this, target),
                  (this._pt = pt));
          }),
        _processVars = function _processVars(
          vars,
          index,
          target,
          targets,
          tween
        ) {
          if (
            (_isFunction(vars) &&
              (vars = _parseFuncOrString(vars, tween, index, target, targets)),
            !_isObject(vars) ||
              (vars.style && vars.nodeType) ||
              _isArray(vars) ||
              _isTypedArray(vars))
          )
            return _isString(vars)
              ? _parseFuncOrString(vars, tween, index, target, targets)
              : vars;
          var p,
            copy = {};
          for (p in vars)
            copy[p] = _parseFuncOrString(
              vars[p],
              tween,
              index,
              target,
              targets
            );
          return copy;
        },
        _initTween = function _initTween(tween, time, tTime) {
          var cleanVars,
            i,
            p,
            pt,
            target,
            hasPriority,
            gsData,
            harness,
            plugin,
            ptLookup,
            index,
            harnessVars,
            overwritten,
            vars = tween.vars,
            ease = vars.ease,
            startAt = vars.startAt,
            immediateRender = vars.immediateRender,
            lazy = vars.lazy,
            onUpdate = vars.onUpdate,
            runBackwards = vars.runBackwards,
            yoyoEase = vars.yoyoEase,
            keyframes = vars.keyframes,
            autoRevert = vars.autoRevert,
            dur = tween._dur,
            prevStartAt = tween._startAt,
            targets = tween._targets,
            parent = tween.parent,
            fullTargets =
              parent && "nested" === parent.data
                ? parent.vars.targets
                : targets,
            autoOverwrite = "auto" === tween._overwrite && !_suppressOverwrites,
            tl = tween.timeline;
          if (
            ((tween._ease = _parseEase(
              (ease = !tl || (keyframes && ease) ? ease : "none"),
              _defaults.ease
            )),
            (tween._yEase = yoyoEase
              ? _invertEase(
                  _parseEase(!0 === yoyoEase ? ease : yoyoEase, _defaults.ease)
                )
              : 0),
            yoyoEase &&
              tween._yoyo &&
              !tween._repeat &&
              ((yoyoEase = tween._yEase),
              (tween._yEase = tween._ease),
              (tween._ease = yoyoEase)),
            (tween._from = !tl && !!vars.runBackwards),
            !tl || (keyframes && !vars.stagger))
          ) {
            if (
              ((harnessVars =
                (harness = targets[0] ? _getCache(targets[0]).harness : 0) &&
                vars[harness.prop]),
              (cleanVars = _copyExcluding(vars, _reservedProps)),
              prevStartAt &&
                (prevStartAt._zTime < 0 && prevStartAt.progress(1),
                time < 0 && runBackwards && immediateRender && !autoRevert
                  ? prevStartAt.render(-1, !0)
                  : prevStartAt.revert(
                      runBackwards && dur
                        ? _revertConfigNoKill
                        : _startAtRevertConfig
                    ),
                (prevStartAt._lazy = 0)),
              startAt)
            ) {
              if (
                (_removeFromParent(
                  (tween._startAt = Tween.set(
                    targets,
                    _setDefaults(
                      {
                        data: "isStart",
                        overwrite: !1,
                        parent: parent,
                        immediateRender: !0,
                        lazy: !prevStartAt && _isNotFalse(lazy),
                        startAt: null,
                        delay: 0,
                        onUpdate:
                          onUpdate &&
                          function () {
                            return _callback(tween, "onUpdate");
                          },
                        stagger: 0,
                      },
                      startAt
                    )
                  ))
                ),
                (tween._startAt._dp = 0),
                (tween._startAt._sat = tween),
                time < 0 &&
                  (_reverting || (!immediateRender && !autoRevert)) &&
                  tween._startAt.revert(_revertConfigNoKill),
                immediateRender && dur && time <= 0 && tTime <= 0)
              )
                return void (time && (tween._zTime = time));
            } else if (runBackwards && dur && !prevStartAt)
              if (
                ((p = _setDefaults(
                  {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy:
                      (immediateRender = time ? !1 : immediateRender) &&
                      !prevStartAt &&
                      _isNotFalse(lazy),
                    immediateRender: immediateRender,
                    stagger: 0,
                    parent: parent,
                  },
                  cleanVars
                )),
                harnessVars && (p[harness.prop] = harnessVars),
                _removeFromParent((tween._startAt = Tween.set(targets, p))),
                (tween._startAt._dp = 0),
                (tween._startAt._sat = tween),
                time < 0 &&
                  (_reverting
                    ? tween._startAt.revert(_revertConfigNoKill)
                    : tween._startAt.render(-1, !0)),
                (tween._zTime = time),
                immediateRender)
              ) {
                if (!time) return;
              } else _initTween(tween._startAt, _tinyNum, _tinyNum);
            for (
              tween._pt = tween._ptCache = 0,
                lazy = (dur && _isNotFalse(lazy)) || (lazy && !dur),
                i = 0;
              i < targets.length;
              i++
            ) {
              if (
                ((gsData =
                  (target = targets[i])._gsap || _harness(targets)[i]._gsap),
                (tween._ptLookup[i] = ptLookup = {}),
                _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(),
                (index =
                  fullTargets === targets ? i : fullTargets.indexOf(target)),
                harness &&
                  !1 !==
                    (plugin = new harness()).init(
                      target,
                      harnessVars || cleanVars,
                      tween,
                      index,
                      fullTargets
                    ) &&
                  ((tween._pt = pt =
                    new PropTween(
                      tween._pt,
                      target,
                      plugin.name,
                      0,
                      1,
                      plugin.render,
                      plugin,
                      0,
                      plugin.priority
                    )),
                  plugin._props.forEach(function (name) {
                    ptLookup[name] = pt;
                  }),
                  plugin.priority) &&
                  (hasPriority = 1),
                !harness || harnessVars)
              )
                for (p in cleanVars)
                  _plugins[p] &&
                  (plugin = _checkPlugin(
                    p,
                    cleanVars,
                    tween,
                    index,
                    target,
                    fullTargets
                  ))
                    ? plugin.priority && (hasPriority = 1)
                    : (ptLookup[p] = pt =
                        _addPropTween.call(
                          tween,
                          target,
                          p,
                          "get",
                          cleanVars[p],
                          index,
                          fullTargets,
                          0,
                          vars.stringFilter
                        ));
              tween._op && tween._op[i] && tween.kill(target, tween._op[i]),
                autoOverwrite &&
                  tween._pt &&
                  ((_overwritingTween = tween),
                  _globalTimeline.killTweensOf(
                    target,
                    ptLookup,
                    tween.globalTime(time)
                  ),
                  (overwritten = !tween.parent),
                  (_overwritingTween = 0)),
                tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
            }
            hasPriority && _sortPropTweensByPriority(tween),
              tween._onInit && tween._onInit(tween);
          }
          (tween._onUpdate = onUpdate),
            (tween._initted = (!tween._op || tween._pt) && !overwritten),
            keyframes && time <= 0 && tl.render(_bigNum, !0, !0);
        },
        _staggerTweenProps =
          _callbackNames +
          "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        _staggerPropsToSkip = {},
        Tween =
          (_forEachName(
            _staggerTweenProps +
              ",id,stagger,delay,duration,paused,scrollTrigger",
            function (name) {
              return (_staggerPropsToSkip[name] = 1);
            }
          ),
          (function (_Animation2) {
            function Tween(targets, vars, position, skipInherit) {
              "number" == typeof vars &&
                ((position.duration = vars),
                (vars = position),
                (position = null));
              var _this3,
                tl,
                i,
                copy,
                l,
                p,
                curTarget,
                staggerFunc,
                staggerVarsToMerge,
                skipInherit = (_this3 =
                  _Animation2.call(
                    this,
                    skipInherit ? vars : _inheritDefaults(vars)
                  ) || this).vars,
                duration = skipInherit.duration,
                delay = skipInherit.delay,
                immediateRender = skipInherit.immediateRender,
                stagger = skipInherit.stagger,
                overwrite = skipInherit.overwrite,
                keyframes = skipInherit.keyframes,
                defaults = skipInherit.defaults,
                scrollTrigger = skipInherit.scrollTrigger,
                yoyoEase = skipInherit.yoyoEase,
                skipInherit = vars.parent || _globalTimeline,
                parsedTargets = (
                  _isArray(targets) || _isTypedArray(targets)
                    ? _isNumber(targets[0])
                    : "length" in vars
                )
                  ? [targets]
                  : toArray(targets);
              if (
                ((_this3._targets = parsedTargets.length
                  ? _harness(parsedTargets)
                  : _warn(
                      "GSAP target " + targets + " not found. https://gsap.com",
                      !_config.nullTargetWarn
                    ) || []),
                (_this3._ptLookup = []),
                (_this3._overwrite = overwrite),
                keyframes ||
                  stagger ||
                  _isFuncOrString(duration) ||
                  _isFuncOrString(delay))
              ) {
                if (
                  ((vars = _this3.vars),
                  (tl = _this3.timeline =
                    new Timeline({
                      data: "nested",
                      defaults: defaults || {},
                      targets:
                        skipInherit && "nested" === skipInherit.data
                          ? skipInherit.vars.targets
                          : parsedTargets,
                    })).kill(),
                  (tl.parent = tl._dp = _assertThisInitialized(_this3)),
                  (tl._start = 0),
                  stagger ||
                    _isFuncOrString(duration) ||
                    _isFuncOrString(delay))
                ) {
                  if (
                    ((l = parsedTargets.length),
                    (staggerFunc = stagger && distribute(stagger)),
                    _isObject(stagger))
                  )
                    for (p in stagger)
                      ~_staggerTweenProps.indexOf(p) &&
                        ((staggerVarsToMerge = staggerVarsToMerge || {})[p] =
                          stagger[p]);
                  for (i = 0; i < l; i++)
                    ((copy = _copyExcluding(
                      vars,
                      _staggerPropsToSkip
                    )).stagger = 0),
                      yoyoEase && (copy.yoyoEase = yoyoEase),
                      staggerVarsToMerge && _merge(copy, staggerVarsToMerge),
                      (curTarget = parsedTargets[i]),
                      (copy.duration = +_parseFuncOrString(
                        duration,
                        _assertThisInitialized(_this3),
                        i,
                        curTarget,
                        parsedTargets
                      )),
                      (copy.delay =
                        (+_parseFuncOrString(
                          delay,
                          _assertThisInitialized(_this3),
                          i,
                          curTarget,
                          parsedTargets
                        ) || 0) - _this3._delay),
                      !stagger &&
                        1 === l &&
                        copy.delay &&
                        ((_this3._delay = delay = copy.delay),
                        (_this3._start += delay),
                        (copy.delay = 0)),
                      tl.to(
                        curTarget,
                        copy,
                        staggerFunc
                          ? staggerFunc(i, curTarget, parsedTargets)
                          : 0
                      ),
                      (tl._ease = _easeMap.none);
                  tl.duration()
                    ? (duration = delay = 0)
                    : (_this3.timeline = 0);
                } else if (keyframes) {
                  _inheritDefaults(
                    _setDefaults(tl.vars.defaults, { ease: "none" })
                  ),
                    (tl._ease = _parseEase(
                      keyframes.ease || vars.ease || "none"
                    ));
                  var a,
                    kf,
                    v,
                    time = 0;
                  if (_isArray(keyframes))
                    keyframes.forEach(function (frame) {
                      return tl.to(parsedTargets, frame, ">");
                    }),
                      tl.duration();
                  else {
                    for (p in ((copy = {}), keyframes))
                      "ease" !== p &&
                        "easeEach" !== p &&
                        _parseKeyframe(
                          p,
                          keyframes[p],
                          copy,
                          keyframes.easeEach
                        );
                    for (p in copy)
                      for (
                        a = copy[p].sort(function (a, b) {
                          return a.t - b.t;
                        }),
                          i = time = 0;
                        i < a.length;
                        i++
                      )
                        ((v = {
                          ease: (kf = a[i]).e,
                          duration:
                            ((kf.t - (i ? a[i - 1].t : 0)) / 100) * duration,
                        })[p] = kf.v),
                          tl.to(parsedTargets, v, time),
                          (time += v.duration);
                    tl.duration() < duration &&
                      tl.to({}, { duration: duration - tl.duration() });
                  }
                }
                duration || _this3.duration((duration = tl.duration()));
              } else _this3.timeline = 0;
              return (
                !0 !== overwrite ||
                  _suppressOverwrites ||
                  ((_overwritingTween = _assertThisInitialized(_this3)),
                  _globalTimeline.killTweensOf(parsedTargets),
                  (_overwritingTween = 0)),
                _addToTimeline(
                  skipInherit,
                  _assertThisInitialized(_this3),
                  position
                ),
                vars.reversed && _this3.reverse(),
                vars.paused && _this3.paused(!0),
                (immediateRender ||
                  (!duration &&
                    !keyframes &&
                    _this3._start === _roundPrecise(skipInherit._time) &&
                    _isNotFalse(immediateRender) &&
                    _hasNoPausedAncestors(_assertThisInitialized(_this3)) &&
                    "nested" !== skipInherit.data)) &&
                  ((_this3._tTime = -_tinyNum),
                  _this3.render(Math.max(0, -delay) || 0)),
                scrollTrigger &&
                  _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger),
                _this3
              );
            }
            _inheritsLoose(Tween, _Animation2);
            var _proto3 = Tween.prototype;
            return (
              (_proto3.render = function render(
                totalTime,
                suppressEvents,
                force
              ) {
                var time,
                  pt,
                  iteration,
                  cycleDuration,
                  prevIteration,
                  isYoyo,
                  ratio,
                  timeline,
                  yoyoEase,
                  prevTime = this._time,
                  tDur = this._tDur,
                  dur = this._dur,
                  isNegative = totalTime < 0,
                  tTime =
                    tDur - _tinyNum < totalTime && !isNegative
                      ? tDur
                      : totalTime < _tinyNum
                      ? 0
                      : totalTime;
                if (dur) {
                  if (
                    tTime !== this._tTime ||
                    !totalTime ||
                    force ||
                    (!this._initted && this._tTime) ||
                    (this._startAt && this._zTime < 0 != isNegative)
                  ) {
                    if (
                      ((time = tTime), (timeline = this.timeline), this._repeat)
                    ) {
                      if (
                        ((cycleDuration = dur + this._rDelay),
                        this._repeat < -1 && isNegative)
                      )
                        return this.totalTime(
                          100 * cycleDuration + totalTime,
                          suppressEvents,
                          force
                        );
                      if (
                        ((time = _roundPrecise(tTime % cycleDuration)),
                        tTime === tDur
                          ? ((iteration = this._repeat), (time = dur))
                          : ((iteration = ~~(tTime / cycleDuration)) &&
                              iteration ===
                                _roundPrecise(tTime / cycleDuration) &&
                              ((time = dur), iteration--),
                            dur < time && (time = dur)),
                        (isYoyo = this._yoyo && 1 & iteration) &&
                          ((yoyoEase = this._yEase), (time = dur - time)),
                        (prevIteration = _animationCycle(
                          this._tTime,
                          cycleDuration
                        )),
                        time === prevTime &&
                          !force &&
                          this._initted &&
                          iteration === prevIteration)
                      )
                        return (this._tTime = tTime), this;
                      iteration !== prevIteration &&
                        (timeline &&
                          this._yEase &&
                          _propagateYoyoEase(timeline, isYoyo),
                        this.vars.repeatRefresh) &&
                        !isYoyo &&
                        !this._lock &&
                        this._time !== cycleDuration &&
                        this._initted &&
                        ((this._lock = force = 1),
                        (this.render(
                          _roundPrecise(cycleDuration * iteration),
                          !0
                        ).invalidate()._lock = 0));
                    }
                    if (!this._initted) {
                      if (
                        _attemptInitTween(
                          this,
                          isNegative ? totalTime : time,
                          force,
                          suppressEvents,
                          tTime
                        )
                      )
                        return (this._tTime = 0), this;
                      if (
                        !(
                          prevTime === this._time ||
                          (force &&
                            this.vars.repeatRefresh &&
                            iteration !== prevIteration)
                        )
                      )
                        return this;
                      if (dur !== this._dur)
                        return this.render(totalTime, suppressEvents, force);
                    }
                    if (
                      ((this._tTime = tTime),
                      (this._time = time),
                      !this._act &&
                        this._ts &&
                        ((this._act = 1), (this._lazy = 0)),
                      (this.ratio = ratio =
                        (yoyoEase || this._ease)(time / dur)),
                      this._from && (this.ratio = ratio = 1 - ratio),
                      time &&
                        !prevTime &&
                        !suppressEvents &&
                        !iteration &&
                        (_callback(this, "onStart"), this._tTime !== tTime))
                    )
                      return this;
                    for (pt = this._pt; pt; )
                      pt.r(ratio, pt.d), (pt = pt._next);
                    (timeline &&
                      timeline.render(
                        totalTime < 0
                          ? totalTime
                          : timeline._dur * timeline._ease(time / this._dur),
                        suppressEvents,
                        force
                      )) ||
                      (this._startAt && (this._zTime = totalTime)),
                      this._onUpdate &&
                        !suppressEvents &&
                        (isNegative &&
                          _rewindStartAt(this, totalTime, 0, force),
                        _callback(this, "onUpdate")),
                      this._repeat &&
                        iteration !== prevIteration &&
                        this.vars.onRepeat &&
                        !suppressEvents &&
                        this.parent &&
                        _callback(this, "onRepeat"),
                      (tTime !== this._tDur && tTime) ||
                        this._tTime !== tTime ||
                        (isNegative &&
                          !this._onUpdate &&
                          _rewindStartAt(this, totalTime, 0, !0),
                        (!totalTime && dur) ||
                          !(
                            (tTime === this._tDur && 0 < this._ts) ||
                            (!tTime && this._ts < 0)
                          ) ||
                          _removeFromParent(this, 1),
                        suppressEvents) ||
                        (isNegative && !prevTime) ||
                        !(tTime || prevTime || isYoyo) ||
                        (_callback(
                          this,
                          tTime === tDur ? "onComplete" : "onReverseComplete",
                          !0
                        ),
                        !this._prom) ||
                        (tTime < tDur && 0 < this.timeScale()) ||
                        this._prom();
                  }
                } else
                  _renderZeroDurationTween(
                    this,
                    totalTime,
                    suppressEvents,
                    force
                  );
                return this;
              }),
              (_proto3.targets = function targets() {
                return this._targets;
              }),
              (_proto3.invalidate = function invalidate(soft) {
                return (
                  (soft && this.vars.runBackwards) || (this._startAt = 0),
                  (this._pt =
                    this._op =
                    this._onUpdate =
                    this._lazy =
                    this.ratio =
                      0),
                  (this._ptLookup = []),
                  this.timeline && this.timeline.invalidate(soft),
                  _Animation2.prototype.invalidate.call(this, soft)
                );
              }),
              (_proto3.resetTo = function resetTo(
                property,
                value,
                start,
                startIsRelative,
                skipRecursion
              ) {
                _tickerActive || _ticker.wake(), this._ts || this.play();
                var ratio,
                  time = Math.min(
                    this._dur,
                    (this._dp._time - this._start) * this._ts
                  );
                return (
                  this._initted || _initTween(this, time),
                  (ratio = this._ease(time / this._dur)),
                  _updatePropTweens(
                    this,
                    property,
                    value,
                    start,
                    startIsRelative,
                    ratio,
                    time,
                    skipRecursion
                  )
                    ? this.resetTo(property, value, start, startIsRelative, 1)
                    : (_alignPlayhead(this, 0),
                      this.parent ||
                        _addLinkedListItem(
                          this._dp,
                          this,
                          "_first",
                          "_last",
                          this._dp._sort ? "_start" : 0
                        ),
                      this.render(0))
                );
              }),
              (_proto3.kill = function kill(targets, vars) {
                if (
                  (void 0 === vars && (vars = "all"),
                  !(targets || (vars && "all" !== vars)))
                )
                  return (
                    (this._lazy = this._pt = 0),
                    this.parent ? _interrupt(this) : this
                  );
                if (this.timeline)
                  (tDur = this.timeline.totalDuration()),
                    this.timeline.killTweensOf(
                      targets,
                      vars,
                      _overwritingTween &&
                        !0 !== _overwritingTween.vars.overwrite
                    )._first || _interrupt(this),
                    this.parent &&
                      tDur !== this.timeline.totalDuration() &&
                      _setDuration(
                        this,
                        (this._dur * this.timeline._tDur) / tDur,
                        0,
                        1
                      );
                else {
                  var overwrittenProps,
                    curLookup,
                    curOverwriteProps,
                    props,
                    p,
                    pt,
                    i,
                    parsedTargets = this._targets,
                    killingTargets = targets ? toArray(targets) : parsedTargets,
                    propTweenLookup = this._ptLookup,
                    tDur = this._pt;
                  if (
                    (!vars || "all" === vars) &&
                    _arraysMatch(parsedTargets, killingTargets)
                  )
                    return "all" === vars && (this._pt = 0), _interrupt(this);
                  for (
                    overwrittenProps = this._op = this._op || [],
                      "all" !== vars &&
                        (_isString(vars) &&
                          ((p = {}),
                          _forEachName(vars, function (name) {
                            return (p[name] = 1);
                          }),
                          (vars = p)),
                        (vars = _addAliasesToVars(parsedTargets, vars))),
                      i = parsedTargets.length;
                    i--;

                  )
                    if (~killingTargets.indexOf(parsedTargets[i]))
                      for (p in ((curLookup = propTweenLookup[i]),
                      "all" === vars
                        ? ((overwrittenProps[i] = vars),
                          (props = curLookup),
                          (curOverwriteProps = {}))
                        : ((curOverwriteProps = overwrittenProps[i] =
                            overwrittenProps[i] || {}),
                          (props = vars)),
                      props))
                        (pt = curLookup && curLookup[p]) &&
                          (("kill" in pt.d && !0 !== pt.d.kill(p)) ||
                            _removeLinkedListItem(this, pt, "_pt"),
                          delete curLookup[p]),
                          "all" !== curOverwriteProps &&
                            (curOverwriteProps[p] = 1);
                  this._initted && !this._pt && tDur && _interrupt(this);
                }
                return this;
              }),
              (Tween.to = function to(targets, vars) {
                return new Tween(targets, vars, arguments[2]);
              }),
              (Tween.from = function from(targets, vars) {
                return _createTweenType(1, arguments);
              }),
              (Tween.delayedCall = function delayedCall(
                delay,
                callback,
                params,
                scope
              ) {
                return new Tween(callback, 0, {
                  immediateRender: !1,
                  lazy: !1,
                  overwrite: !1,
                  delay: delay,
                  onComplete: callback,
                  onReverseComplete: callback,
                  onCompleteParams: params,
                  onReverseCompleteParams: params,
                  callbackScope: scope,
                });
              }),
              (Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                return _createTweenType(2, arguments);
              }),
              (Tween.set = function set(targets, vars) {
                return (
                  (vars.duration = 0),
                  vars.repeatDelay || (vars.repeat = 0),
                  new Tween(targets, vars)
                );
              }),
              (Tween.killTweensOf = function killTweensOf(
                targets,
                props,
                onlyActive
              ) {
                return _globalTimeline.killTweensOf(targets, props, onlyActive);
              }),
              Tween
            );
          })(Animation)),
        _setterPlain =
          (_setDefaults(Tween.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0,
          }),
          _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
            Tween[name] = function () {
              var tl = new Timeline(),
                params = _slice.call(arguments, 0);
              return (
                params.splice("staggerFromTo" === name ? 5 : 4, 0, 0),
                tl[name].apply(tl, params)
              );
            };
          }),
          function _setterPlain(target, property, value) {
            return (target[property] = value);
          }),
        _setterFunc = function _setterFunc(target, property, value) {
          return target[property](value);
        },
        _setterFuncWithParam = function _setterFuncWithParam(
          target,
          property,
          value,
          data
        ) {
          return target[property](data.fp, value);
        },
        _getSetter = function _getSetter(target, property) {
          return _isFunction(target[property])
            ? _setterFunc
            : _isUndefined(target[property]) && target.setAttribute
            ? _setterAttribute
            : _setterPlain;
        },
        _renderPlain = function _renderPlain(ratio, data) {
          return data.set(
            data.t,
            data.p,
            Math.round(1e6 * (data.s + data.c * ratio)) / 1e6,
            data
          );
        },
        _renderBoolean = function _renderBoolean(ratio, data) {
          return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
        },
        _renderComplexString = function _renderComplexString(ratio, data) {
          var pt = data._pt,
            s = "";
          if (!ratio && data.b) s = data.b;
          else if (1 === ratio && data.e) s = data.e;
          else {
            for (; pt; )
              (s =
                pt.p +
                (pt.m
                  ? pt.m(pt.s + pt.c * ratio)
                  : Math.round(1e4 * (pt.s + pt.c * ratio)) / 1e4) +
                s),
                (pt = pt._next);
            s += data.c;
          }
          data.set(data.t, data.p, s, data);
        },
        _renderPropTweens = function _renderPropTweens(ratio, data) {
          for (var pt = data._pt; pt; ) pt.r(ratio, pt.d), (pt = pt._next);
        },
        _addPluginModifier = function _addPluginModifier(
          modifier,
          tween,
          target,
          property
        ) {
          for (var next, pt = this._pt; pt; )
            (next = pt._next),
              pt.p === property && pt.modifier(modifier, tween, target),
              (pt = next);
        },
        _killPropTweensOf = function _killPropTweensOf(property) {
          for (var hasNonDependentRemaining, next, pt = this._pt; pt; )
            (next = pt._next),
              (pt.p === property && !pt.op) || pt.op === property
                ? _removeLinkedListItem(this, pt, "_pt")
                : pt.dep || (hasNonDependentRemaining = 1),
              (pt = next);
          return !hasNonDependentRemaining;
        },
        _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
          for (var next, pt2, first, last, pt = parent._pt; pt; ) {
            for (next = pt._next, pt2 = first; pt2 && pt2.pr > pt.pr; )
              pt2 = pt2._next;
            (pt._prev = pt2 ? pt2._prev : last)
              ? (pt._prev._next = pt)
              : (first = pt),
              (pt._next = pt2) ? (pt2._prev = pt) : (last = pt),
              (pt = next);
          }
          parent._pt = first;
        },
        PropTween = (function () {
          function PropTween(
            next,
            target,
            prop,
            start,
            change,
            renderer,
            data,
            setter,
            priority
          ) {
            (this.t = target),
              (this.s = start),
              (this.c = change),
              (this.p = prop),
              (this.r = renderer || _renderPlain),
              (this.d = data || this),
              (this.set = setter || _setterPlain),
              (this.pr = priority || 0),
              (this._next = next) && (next._prev = this);
          }
          return (
            (PropTween.prototype.modifier = function modifier(
              func,
              tween,
              target
            ) {
              (this.mSet = this.mSet || this.set),
                (this.set = _setterWithModifier),
                (this.m = func),
                (this.mt = target),
                (this.tween = tween);
            }),
            PropTween
          );
        })(),
        _media =
          (_forEachName(
            _callbackNames +
              "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
            function (name) {
              return (_reservedProps[name] = 1);
            }
          ),
          (_globals.TweenMax = _globals.TweenLite = Tween),
          (_globals.TimelineLite = _globals.TimelineMax = Timeline),
          (_globalTimeline = new Timeline({
            sortChildren: !1,
            defaults: _defaults,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0,
          })),
          (_config.stringFilter = _colorStringFilter),
          []),
        _listeners = {},
        _emptyArray = [],
        _lastMediaTime = 0,
        _contextID = 0,
        Context = (function () {
          function Context(func, scope) {
            (this.selector = scope && selector(scope)),
              (this.data = []),
              (this._r = []),
              (this.isReverted = !1),
              (this.id = _contextID++),
              func && this.add(func);
          }
          var _proto5 = Context.prototype;
          return (
            (_proto5.add = function add(name, func, scope) {
              _isFunction(name) &&
                ((scope = func), (func = name), (name = _isFunction));
              function f() {
                var result,
                  prev = _context,
                  prevSelector = self.selector;
                return (
                  prev && prev !== self && prev.data.push(self),
                  scope && (self.selector = selector(scope)),
                  (_context = self),
                  (result = func.apply(self, arguments)),
                  _isFunction(result) && self._r.push(result),
                  (_context = prev),
                  (self.selector = prevSelector),
                  (self.isReverted = !1),
                  result
                );
              }
              var self = this;
              return (
                (self.last = f),
                name === _isFunction
                  ? f(self, function (func) {
                      return self.add(null, func);
                    })
                  : name
                  ? (self[name] = f)
                  : f
              );
            }),
            (_proto5.ignore = function ignore(func) {
              var prev = _context;
              (_context = null), func(this), (_context = prev);
            }),
            (_proto5.getTweens = function getTweens() {
              var a = [];
              return (
                this.data.forEach(function (e) {
                  return e instanceof Context
                    ? a.push.apply(a, e.getTweens())
                    : e instanceof Tween &&
                        !(e.parent && "nested" === e.parent.data) &&
                        a.push(e);
                }),
                a
              );
            }),
            (_proto5.clear = function clear() {
              this._r.length = this.data.length = 0;
            }),
            (_proto5.kill = function kill(revert, matchMedia) {
              var _this4 = this;
              if (
                (revert
                  ? (function () {
                      for (
                        var t,
                          tweens = _this4.getTweens(),
                          i = _this4.data.length;
                        i--;

                      )
                        "isFlip" === (t = _this4.data[i]).data &&
                          (t.revert(),
                          t.getChildren(!0, !0, !1).forEach(function (tween) {
                            return tweens.splice(tweens.indexOf(tween), 1);
                          }));
                      for (
                        tweens
                          .map(function (t) {
                            return {
                              g:
                                t._dur ||
                                t._delay ||
                                (t._sat && !t._sat.vars.immediateRender)
                                  ? t.globalTime(0)
                                  : -1 / 0,
                              t: t,
                            };
                          })
                          .sort(function (a, b) {
                            return b.g - a.g || -1 / 0;
                          })
                          .forEach(function (o) {
                            return o.t.revert(revert);
                          }),
                          i = _this4.data.length;
                        i--;

                      )
                        (t = _this4.data[i]) instanceof Timeline
                          ? "nested" !== t.data &&
                            (t.scrollTrigger && t.scrollTrigger.revert(),
                            t.kill())
                          : t instanceof Tween || !t.revert || t.revert(revert);
                      _this4._r.forEach(function (f) {
                        return f(revert, _this4);
                      }),
                        (_this4.isReverted = !0);
                    })()
                  : this.data.forEach(function (e) {
                      return e.kill && e.kill();
                    }),
                this.clear(),
                matchMedia)
              )
                for (var i = _media.length; i--; )
                  _media[i].id === this.id && _media.splice(i, 1);
            }),
            (_proto5.revert = function revert(config) {
              this.kill(config || {});
            }),
            Context
          );
        })(),
        MatchMedia = (function () {
          function MatchMedia(scope) {
            (this.contexts = []),
              (this.scope = scope),
              _context && _context.data.push(this);
          }
          var _proto6 = MatchMedia.prototype;
          return (
            (_proto6.add = function add(conditions, func, scope) {
              _isObject(conditions) || (conditions = { matches: conditions });
              var mq,
                p,
                active,
                context = new Context(0, scope || this.scope),
                cond = (context.conditions = {});
              for (p in (_context &&
                !context.selector &&
                (context.selector = _context.selector),
              this.contexts.push(context),
              (func = context.add("onMatch", func)),
              (context.queries = conditions)))
                "all" === p
                  ? (active = 1)
                  : (mq = _win.matchMedia(conditions[p])) &&
                    (_media.indexOf(context) < 0 && _media.push(context),
                    (cond[p] = mq.matches) && (active = 1),
                    mq.addListener
                      ? mq.addListener(_onMediaChange)
                      : mq.addEventListener("change", _onMediaChange));
              return (
                active &&
                  func(context, function (f) {
                    return context.add(null, f);
                  }),
                this
              );
            }),
            (_proto6.revert = function revert(config) {
              this.kill(config || {});
            }),
            (_proto6.kill = function kill(revert) {
              this.contexts.forEach(function (c) {
                return c.kill(revert, !0);
              });
            }),
            MatchMedia
          );
        })(),
        _gsap = {
          registerPlugin: function registerPlugin() {
            for (
              var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
              _key2 < _len2;
              _key2++
            )
              args[_key2] = arguments[_key2];
            args.forEach(_createPlugin);
          },
          timeline: function timeline(vars) {
            return new Timeline(vars);
          },
          getTweensOf: function getTweensOf(targets, onlyActive) {
            return _globalTimeline.getTweensOf(targets, onlyActive);
          },
          getProperty: function getProperty(target, property, unit, uncache) {
            _isString(target) && (target = toArray(target)[0]);
            var getter = _getCache(target || {}).get,
              format = unit ? _passThrough : _numericIfPossible;
            return (
              "native" === unit && (unit = ""),
              target &&
                (property
                  ? format(
                      (
                        (_plugins[property] && _plugins[property].get) ||
                        getter
                      )(target, property, unit, uncache)
                    )
                  : function (property, unit, uncache) {
                      return format(
                        (
                          (_plugins[property] && _plugins[property].get) ||
                          getter
                        )(target, property, unit, uncache)
                      );
                    })
            );
          },
          quickSetter: function quickSetter(target, property, unit) {
            var setters, l;
            if (1 < (target = toArray(target)).length)
              return (
                (setters = target.map(function (t) {
                  return gsap.quickSetter(t, property, unit);
                })),
                (l = setters.length),
                function (value) {
                  for (var i = l; i--; ) setters[i](value);
                }
              );
            target = target[0] || {};
            var Plugin = _plugins[property],
              cache = _getCache(target),
              p =
                (cache.harness && (cache.harness.aliases || {})[property]) ||
                property,
              setter = Plugin
                ? function (value) {
                    var p = new Plugin();
                    (_quickTween._pt = 0),
                      p.init(
                        target,
                        unit ? value + unit : value,
                        _quickTween,
                        0,
                        [target]
                      ),
                      p.render(1, p),
                      _quickTween._pt && _renderPropTweens(1, _quickTween);
                  }
                : cache.set(target, p);
            return Plugin
              ? setter
              : function (value) {
                  return setter(
                    target,
                    p,
                    unit ? value + unit : value,
                    cache,
                    1
                  );
                };
          },
          quickTo: function quickTo(target, property, vars) {
            function func(value, start, startIsRelative) {
              return tween.resetTo(property, value, start, startIsRelative);
            }
            var tween = gsap.to(
              target,
              _merge(
                (((target = {})[property] = "+=0.1"),
                (target.paused = !0),
                target),
                vars || {}
              )
            );
            return (func.tween = tween), func;
          },
          isTweening: function isTweening(targets) {
            return 0 < _globalTimeline.getTweensOf(targets, !0).length;
          },
          defaults: function defaults(value) {
            return (
              value &&
                value.ease &&
                (value.ease = _parseEase(value.ease, _defaults.ease)),
              _mergeDeep(_defaults, value || {})
            );
          },
          config: function config(value) {
            return _mergeDeep(_config, value || {});
          },
          registerEffect: function registerEffect(_ref3) {
            var name = _ref3.name,
              effect = _ref3.effect,
              plugins = _ref3.plugins,
              defaults = _ref3.defaults,
              _ref3 = _ref3.extendTimeline;
            (plugins || "").split(",").forEach(function (pluginName) {
              return (
                pluginName &&
                !_plugins[pluginName] &&
                !_globals[pluginName] &&
                _warn(name + " effect requires " + pluginName + " plugin.")
              );
            }),
              (_effects[name] = function (targets, vars, tl) {
                return effect(
                  toArray(targets),
                  _setDefaults(vars || {}, defaults),
                  tl
                );
              }),
              _ref3 &&
                (Timeline.prototype[name] = function (targets, vars, position) {
                  return this.add(
                    _effects[name](
                      targets,
                      _isObject(vars) ? vars : (position = vars) && {},
                      this
                    ),
                    position
                  );
                });
          },
          registerEase: function registerEase(name, ease) {
            _easeMap[name] = _parseEase(ease);
          },
          parseEase: function parseEase(ease, defaultEase) {
            return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
          },
          getById: function getById(id) {
            return _globalTimeline.getById(id);
          },
          exportRoot: function exportRoot(vars, includeDelayedCalls) {
            var child,
              next,
              tl = new Timeline((vars = void 0 === vars ? {} : vars));
            for (
              tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming),
                _globalTimeline.remove(tl),
                tl._dp = 0,
                tl._time = tl._tTime = _globalTimeline._time,
                child = _globalTimeline._first;
              child;

            )
              (next = child._next),
                (!includeDelayedCalls &&
                  !child._dur &&
                  child instanceof Tween &&
                  child.vars.onComplete === child._targets[0]) ||
                  _addToTimeline(tl, child, child._start - child._delay),
                (child = next);
            return _addToTimeline(_globalTimeline, tl, 0), tl;
          },
          context: function context(func, scope) {
            return func ? new Context(func, scope) : _context;
          },
          matchMedia: function matchMedia(scope) {
            return new MatchMedia(scope);
          },
          matchMediaRefresh: function matchMediaRefresh() {
            return (
              _media.forEach(function (c) {
                var found,
                  p,
                  cond = c.conditions;
                for (p in cond) cond[p] && ((cond[p] = !1), (found = 1));
                found && c.revert();
              }) || _onMediaChange()
            );
          },
          addEventListener: function addEventListener(type, callback) {
            type = _listeners[type] || (_listeners[type] = []);
            ~type.indexOf(callback) || type.push(callback);
          },
          removeEventListener: function removeEventListener(type, callback) {
            (type = _listeners[type]),
              (callback = type && type.indexOf(callback));
            0 <= callback && type.splice(callback, 1);
          },
          utils: {
            wrap: wrap,
            wrapYoyo: wrapYoyo,
            distribute: distribute,
            random: random,
            snap: snap,
            normalize: normalize,
            getUnit: getUnit,
            clamp: clamp,
            splitColor: splitColor,
            toArray: toArray,
            selector: selector,
            mapRange: mapRange,
            pipe: pipe,
            unitize: unitize,
            interpolate: interpolate,
            shuffle: shuffle,
          },
          install: _install,
          effects: _effects,
          ticker: _ticker,
          updateRoot: Timeline.updateRoot,
          plugins: _plugins,
          globalTimeline: _globalTimeline,
          core: {
            PropTween: PropTween,
            globals: _addGlobal,
            Tween: Tween,
            Timeline: Timeline,
            Animation: Animation,
            getCache: _getCache,
            _removeLinkedListItem: _removeLinkedListItem,
            reverting: function reverting() {
              return _reverting;
            },
            context: function context(toAdd) {
              return (
                toAdd &&
                  _context &&
                  (_context.data.push(toAdd), (toAdd._ctx = _context)),
                _context
              );
            },
            suppressOverwrites: function suppressOverwrites(value) {
              return (_suppressOverwrites = value);
            },
          },
        },
        _getPluginPropTween =
          (_forEachName(
            "to,from,fromTo,delayedCall,set,killTweensOf",
            function (name) {
              return (_gsap[name] = Tween[name]);
            }
          ),
          _ticker.add(Timeline.updateRoot),
          (_quickTween = _gsap.to({}, { duration: 0 })),
          function _getPluginPropTween(plugin, prop) {
            for (
              var pt = plugin._pt;
              pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop;

            )
              pt = pt._next;
            return pt;
          }),
        gsap =
          _gsap.registerPlugin(
            {
              name: "attr",
              init: function init(target, vars, tween, index, targets) {
                var p, pt, v;
                for (p in ((this.tween = tween), vars))
                  (v = target.getAttribute(p) || ""),
                    ((pt = this.add(
                      target,
                      "setAttribute",
                      (v || 0) + "",
                      vars[p],
                      index,
                      targets,
                      0,
                      0,
                      p
                    )).op = p),
                    (pt.b = v),
                    this._props.push(p);
              },
              render: function render(ratio, data) {
                for (var pt = data._pt; pt; )
                  _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d),
                    (pt = pt._next);
              },
            },
            {
              name: "endArray",
              init: function init(target, value) {
                for (var i = value.length; i--; )
                  this.add(
                    target,
                    i,
                    target[i] || 0,
                    value[i],
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                  );
              },
            },
            _buildModifierPlugin("roundProps", _roundModifier),
            _buildModifierPlugin("modifiers"),
            _buildModifierPlugin("snap", snap)
          ) || _gsap,
        CSSPlugin_windowExists =
          ((Tween.version = Timeline.version = gsap.version = "3.12.5"),
          (_coreReady = 1),
          _windowExists() && _wake(),
          _easeMap.Power0,
          _easeMap.Power1,
          _easeMap.Power2,
          _easeMap.Power3,
          _easeMap.Power4,
          _easeMap.Linear,
          _easeMap.Quad,
          _easeMap.Cubic,
          _easeMap.Quart,
          _easeMap.Quint,
          _easeMap.Strong,
          _easeMap.Elastic,
          _easeMap.Back,
          _easeMap.SteppedEase,
          _easeMap.Bounce,
          _easeMap.Sine,
          _easeMap.Expo,
          _easeMap.Circ,
          function _windowExists() {
            return "undefined" != typeof window;
          }),
        _transformProps = {},
        _RAD2DEG = 180 / Math.PI,
        _DEG2RAD = Math.PI / 180,
        _atan2 = Math.atan2,
        _capsExp = /([A-Z])/g,
        _horizontalExp = /(left|right|width|margin|padding|x)/i,
        _complexExp = /[\s,\(]\S/,
        _propertyAliases = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity",
        },
        _transformProp = "transform",
        _transformOriginProp = _transformProp + "Origin",
        _removeIndependentTransforms = function _removeIndependentTransforms(
          style
        ) {
          style.translate &&
            (style.removeProperty("translate"),
            style.removeProperty("scale"),
            style.removeProperty("rotate"));
        },
        _createElement = function _createElement(type, ns) {
          ns = CSSPlugin_doc.createElementNS
            ? CSSPlugin_doc.createElementNS(
                (ns || "http://www.w3.org/1999/xhtml").replace(
                  /^https/,
                  "http"
                ),
                type
              )
            : CSSPlugin_doc.createElement(type);
          return ns && ns.style ? ns : CSSPlugin_doc.createElement(type);
        },
        _getComputedProperty = function _getComputedProperty(
          target,
          property,
          skipPrefixFallback
        ) {
          var cs = getComputedStyle(target);
          return (
            cs[property] ||
            cs.getPropertyValue(
              property.replace(_capsExp, "-$1").toLowerCase()
            ) ||
            cs.getPropertyValue(property) ||
            (!skipPrefixFallback &&
              _getComputedProperty(
                target,
                _checkPropPrefix(property) || property,
                1
              )) ||
            ""
          );
        },
        _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
        _checkPropPrefix = function _checkPropPrefix(
          property,
          element,
          preferPrefix
        ) {
          var s = (element || _tempDiv).style,
            i = 5;
          if (property in s && !preferPrefix) return property;
          for (
            property = property.charAt(0).toUpperCase() + property.substr(1);
            i-- && !(_prefixes[i] + property in s);

          );
          return i < 0
            ? null
            : (3 === i ? "ms" : 0 <= i ? _prefixes[i] : "") + property;
        },
        _getBBox = function _getBBox(target) {
          var bounds;
          try {
            bounds = target.getBBox();
          } catch (error) {
            bounds = _getBBoxHack.call(target, !0);
          }
          return !(bounds =
            (bounds && (bounds.width || bounds.height)) ||
            target.getBBox === _getBBoxHack
              ? bounds
              : _getBBoxHack.call(target, !0)) ||
            bounds.width ||
            bounds.x ||
            bounds.y
            ? bounds
            : {
                x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
                y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0,
              };
        },
        _isSVG = function _isSVG(e) {
          return !(
            !e.getCTM ||
            (e.parentNode && !e.ownerSVGElement) ||
            !_getBBox(e)
          );
        },
        _removeProperty = function _removeProperty(target, property) {
          var first2Chars;
          property &&
            ((target = target.style),
            property in _transformProps &&
              property !== _transformOriginProp &&
              (property = _transformProp),
            target.removeProperty
              ? (("ms" !== (first2Chars = property.substr(0, 2)) &&
                  "webkit" !== property.substr(0, 6)) ||
                  (property = "-" + property),
                target.removeProperty(
                  "--" === first2Chars
                    ? property
                    : property.replace(_capsExp, "-$1").toLowerCase()
                ))
              : target.removeAttribute(property));
        },
        _addNonTweeningPT = function _addNonTweeningPT(
          plugin,
          target,
          property,
          beginning,
          end,
          onlySetAtEnd
        ) {
          target = new PropTween(
            plugin._pt,
            target,
            property,
            0,
            1,
            onlySetAtEnd
              ? _renderNonTweeningValueOnlyAtEnd
              : _renderNonTweeningValue
          );
          return (
            ((plugin._pt = target).b = beginning),
            (target.e = end),
            plugin._props.push(property),
            target
          );
        },
        _nonConvertibleUnits = { deg: 1, rad: 1, turn: 1 },
        _nonStandardLayouts = { grid: 1, flex: 1 },
        _convertToUnit = function _convertToUnit(
          target,
          property,
          value,
          unit
        ) {
          var px,
            cache,
            curValue = parseFloat(value) || 0,
            curUnit =
              (value + "").trim().substr((curValue + "").length) || "px",
            style = _tempDiv.style,
            horizontal = _horizontalExp.test(property),
            isRootSVG = "svg" === target.tagName.toLowerCase(),
            measureProperty =
              (isRootSVG ? "client" : "offset") +
              (horizontal ? "Width" : "Height"),
            toPixels = "px" === unit,
            toPercent = "%" === unit;
          return unit === curUnit ||
            !curValue ||
            _nonConvertibleUnits[unit] ||
            _nonConvertibleUnits[curUnit]
            ? curValue
            : ("px" === curUnit ||
                toPixels ||
                (curValue = _convertToUnit(target, property, value, "px")),
              (value = target.getCTM && _isSVG(target)),
              (!toPercent && "%" !== curUnit) ||
              (!_transformProps[property] && !~property.indexOf("adius"))
                ? ((style[horizontal ? "width" : "height"] =
                    100 + (toPixels ? curUnit : unit)),
                  (isRootSVG =
                    ~property.indexOf("adius") ||
                    ("em" === unit && target.appendChild && !isRootSVG)
                      ? target
                      : target.parentNode),
                  (cache = (isRootSVG =
                    (isRootSVG = value
                      ? (target.ownerSVGElement || {}).parentNode
                      : isRootSVG) &&
                    isRootSVG !== CSSPlugin_doc &&
                    isRootSVG.appendChild
                      ? isRootSVG
                      : CSSPlugin_doc.body)._gsap) &&
                  toPercent &&
                  cache.width &&
                  horizontal &&
                  cache.time === _ticker.time &&
                  !cache.uncache
                    ? _round((curValue / cache.width) * 100)
                    : (!toPercent ||
                      ("height" !== property && "width" !== property)
                        ? ((!toPercent && "%" !== curUnit) ||
                            _nonStandardLayouts[
                              _getComputedProperty(isRootSVG, "display")
                            ] ||
                            (style.position = _getComputedProperty(
                              target,
                              "position"
                            )),
                          isRootSVG === target && (style.position = "static"),
                          isRootSVG.appendChild(_tempDiv),
                          (px = _tempDiv[measureProperty]),
                          isRootSVG.removeChild(_tempDiv),
                          (style.position = "absolute"))
                        : ((curUnit = target.style[property]),
                          (target.style[property] = 100 + unit),
                          (px = target[measureProperty]),
                          curUnit
                            ? (target.style[property] = curUnit)
                            : _removeProperty(target, property)),
                      horizontal &&
                        toPercent &&
                        (((cache = _getCache(isRootSVG)).time = _ticker.time),
                        (cache.width = isRootSVG[measureProperty])),
                      _round(
                        toPixels
                          ? (px * curValue) / 100
                          : px && curValue
                          ? (100 / px) * curValue
                          : 0
                      )))
                : ((px = value
                    ? target.getBBox()[horizontal ? "width" : "height"]
                    : target[measureProperty]),
                  _round(
                    toPercent ? (curValue / px) * 100 : (curValue / 100) * px
                  )));
        },
        _get = function _get(target, property, unit, uncache) {
          var value;
          return (
            _pluginInitted || _initCore(),
            property in _propertyAliases &&
              "transform" !== property &&
              ~(property = _propertyAliases[property]).indexOf(",") &&
              (property = property.split(",")[0]),
            _transformProps[property] && "transform" !== property
              ? ((value = _parseTransform(target, uncache)),
                (value =
                  "transformOrigin" !== property
                    ? value[property]
                    : value.svg
                    ? value.origin
                    : _firstTwoOnly(
                        _getComputedProperty(target, _transformOriginProp)
                      ) +
                      " " +
                      value.zOrigin +
                      "px"))
              : ((value = target.style[property]) &&
                  "auto" !== value &&
                  !uncache &&
                  !~(value + "").indexOf("calc(")) ||
                (value =
                  (_specialProps[property] &&
                    _specialProps[property](target, property, unit)) ||
                  _getComputedProperty(target, property) ||
                  _getProperty(target, property) ||
                  ("opacity" === property ? 1 : 0)),
            unit && !~(value + "").trim().indexOf(" ")
              ? _convertToUnit(target, property, value, unit) + unit
              : value
          );
        },
        _keywordToPercent = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%",
        },
        _specialProps = {
          clearProps: function clearProps(
            plugin,
            target,
            property,
            endValue,
            tween
          ) {
            if ("isFromStart" !== tween.data)
              return (
                ((target = plugin._pt =
                  new PropTween(
                    plugin._pt,
                    target,
                    property,
                    0,
                    0,
                    _renderClearProps
                  )).u = endValue),
                (target.pr = -10),
                (target.tween = tween),
                plugin._props.push(property),
                1
              );
          },
        },
        _identity2DMatrix = [1, 0, 0, 1, 0, 0],
        _rotationalProperties = {},
        _getComputedTransformMatrixAsArray =
          function _getComputedTransformMatrixAsArray(target) {
            target = _getComputedProperty(target, _transformProp);
            return _isNullTransform(target)
              ? _identity2DMatrix
              : target.substr(7).match(_numExp).map(_round);
          },
        _getMatrix = function _getMatrix(target, force2D) {
          var nextSibling,
            temp,
            addedToDOM,
            cache = target._gsap || _getCache(target),
            style = target.style,
            matrix = _getComputedTransformMatrixAsArray(target);
          return cache.svg && target.getAttribute("transform")
            ? "1,0,0,1,0,0" ===
              (matrix = [
                (temp = target.transform.baseVal.consolidate().matrix).a,
                temp.b,
                temp.c,
                temp.d,
                temp.e,
                temp.f,
              ]).join(",")
              ? _identity2DMatrix
              : matrix
            : (matrix !== _identity2DMatrix ||
                target.offsetParent ||
                target === _docElement ||
                cache.svg ||
                ((temp = style.display),
                (style.display = "block"),
                ((cache = target.parentNode) && target.offsetParent) ||
                  ((addedToDOM = 1),
                  (nextSibling = target.nextElementSibling),
                  _docElement.appendChild(target)),
                (matrix = _getComputedTransformMatrixAsArray(target)),
                temp
                  ? (style.display = temp)
                  : _removeProperty(target, "display"),
                addedToDOM &&
                  (nextSibling
                    ? cache.insertBefore(target, nextSibling)
                    : cache
                    ? cache.appendChild(target)
                    : _docElement.removeChild(target))),
              force2D && 6 < matrix.length
                ? [
                    matrix[0],
                    matrix[1],
                    matrix[4],
                    matrix[5],
                    matrix[12],
                    matrix[13],
                  ]
                : matrix);
        },
        _parseTransform = function _parseTransform(target, uncache) {
          var style,
            invertedScaleX,
            origin,
            y,
            z,
            scaleY,
            rotation,
            rotationX,
            rotationY,
            skewX,
            perspective,
            cs,
            cos,
            sin,
            a,
            b,
            c,
            d,
            a12,
            a22,
            t1,
            t2,
            t3,
            a13,
            a23,
            a33,
            yOrigin,
            a43,
            xOrigin,
            x,
            scaleX,
            cache = target._gsap || new GSCache(target);
          return (
            ("x" in cache && !uncache && !cache.uncache) ||
              ((style = target.style),
              (invertedScaleX = cache.scaleX < 0),
              (cs = getComputedStyle(target)),
              (origin =
                _getComputedProperty(target, _transformOriginProp) || "0"),
              (x =
                y =
                z =
                rotation =
                rotationX =
                rotationY =
                skewX =
                perspective =
                  0),
              (scaleX = scaleY = 1),
              (cache.svg = !(!target.getCTM || !_isSVG(target))),
              cs.translate &&
                (("none" === cs.translate &&
                  "none" === cs.scale &&
                  "none" === cs.rotate) ||
                  (style[_transformProp] =
                    ("none" !== cs.translate
                      ? "translate3d(" +
                        (cs.translate + " 0 0")
                          .split(" ")
                          .slice(0, 3)
                          .join(", ") +
                        ") "
                      : "") +
                    ("none" !== cs.rotate ? "rotate(" + cs.rotate + ") " : "") +
                    ("none" !== cs.scale
                      ? "scale(" + cs.scale.split(" ").join(",") + ") "
                      : "") +
                    ("none" !== cs[_transformProp] ? cs[_transformProp] : "")),
                (style.scale = style.rotate = style.translate = "none")),
              (cs = _getMatrix(target, cache.svg)),
              cache.svg &&
                ((t1 = cache.uncache
                  ? ((t2 = target.getBBox()),
                    (origin =
                      cache.xOrigin -
                      t2.x +
                      "px " +
                      (cache.yOrigin - t2.y) +
                      "px"),
                    "")
                  : !uncache && target.getAttribute("data-svg-origin")),
                _applySVGOrigin(
                  target,
                  t1 || origin,
                  !!t1 || cache.originIsAbsolute,
                  !1 !== cache.smooth,
                  cs
                )),
              (xOrigin = cache.xOrigin || 0),
              (yOrigin = cache.yOrigin || 0),
              cs !== _identity2DMatrix &&
                ((a = cs[0]),
                (b = cs[1]),
                (c = cs[2]),
                (d = cs[3]),
                (x = a12 = cs[4]),
                (y = a22 = cs[5]),
                6 === cs.length
                  ? ((scaleX = Math.sqrt(a * a + b * b)),
                    (scaleY = Math.sqrt(d * d + c * c)),
                    (rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0),
                    (skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0) &&
                      (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD))),
                    cache.svg &&
                      ((x -= xOrigin - (xOrigin * a + yOrigin * c)),
                      (y -= yOrigin - (xOrigin * b + yOrigin * d))))
                  : ((xOrigin = cs[6]),
                    (yOrigin = cs[7]),
                    (a13 = cs[8]),
                    (a23 = cs[9]),
                    (a33 = cs[10]),
                    (a43 = cs[11]),
                    (x = cs[12]),
                    (y = cs[13]),
                    (z = cs[14]),
                    (rotationX = (cs = _atan2(xOrigin, a33)) * _RAD2DEG),
                    cs &&
                      ((t1 =
                        a12 * (cos = Math.cos(-cs)) +
                        a13 * (sin = Math.sin(-cs))),
                      (t2 = a22 * cos + a23 * sin),
                      (t3 = xOrigin * cos + a33 * sin),
                      (a13 = a12 * -sin + a13 * cos),
                      (a23 = a22 * -sin + a23 * cos),
                      (a33 = xOrigin * -sin + a33 * cos),
                      (a43 = yOrigin * -sin + a43 * cos),
                      (a12 = t1),
                      (a22 = t2),
                      (xOrigin = t3)),
                    (rotationY = (cs = _atan2(-c, a33)) * _RAD2DEG),
                    cs &&
                      ((cos = Math.cos(-cs)),
                      (a43 = d * (sin = Math.sin(-cs)) + a43 * cos),
                      (a = t1 = a * cos - a13 * sin),
                      (b = t2 = b * cos - a23 * sin),
                      (c = t3 = c * cos - a33 * sin)),
                    (rotation = (cs = _atan2(b, a)) * _RAD2DEG),
                    cs &&
                      ((t1 =
                        a * (cos = Math.cos(cs)) + b * (sin = Math.sin(cs))),
                      (t2 = a12 * cos + a22 * sin),
                      (b = b * cos - a * sin),
                      (a22 = a22 * cos - a12 * sin),
                      (a = t1),
                      (a12 = t2)),
                    rotationX &&
                      359.9 < Math.abs(rotationX) + Math.abs(rotation) &&
                      ((rotationX = rotation = 0),
                      (rotationY = 180 - rotationY)),
                    (scaleX = _round(Math.sqrt(a * a + b * b + c * c))),
                    (scaleY = _round(Math.sqrt(a22 * a22 + xOrigin * xOrigin))),
                    (cs = _atan2(a12, a22)),
                    (skewX = 2e-4 < Math.abs(cs) ? cs * _RAD2DEG : 0),
                    (perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0)),
                cache.svg) &&
                ((t1 = target.getAttribute("transform")),
                (cache.forceCSS =
                  target.setAttribute("transform", "") ||
                  !_isNullTransform(
                    _getComputedProperty(target, _transformProp)
                  )),
                t1) &&
                target.setAttribute("transform", t1),
              90 < Math.abs(skewX) &&
                Math.abs(skewX) < 270 &&
                (invertedScaleX
                  ? ((scaleX *= -1),
                    (skewX += rotation <= 0 ? 180 : -180),
                    (rotation += rotation <= 0 ? 180 : -180))
                  : ((scaleY *= -1), (skewX += skewX <= 0 ? 180 : -180))),
              (uncache = uncache || cache.uncache),
              (cache.x =
                x -
                ((cache.xPercent =
                  x &&
                  ((!uncache && cache.xPercent) ||
                    (Math.round(target.offsetWidth / 2) === Math.round(-x)
                      ? -50
                      : 0)))
                  ? (target.offsetWidth * cache.xPercent) / 100
                  : 0) +
                "px"),
              (cache.y =
                y -
                ((cache.yPercent =
                  y &&
                  ((!uncache && cache.yPercent) ||
                    (Math.round(target.offsetHeight / 2) === Math.round(-y)
                      ? -50
                      : 0)))
                  ? (target.offsetHeight * cache.yPercent) / 100
                  : 0) +
                "px"),
              (cache.z = z + "px"),
              (cache.scaleX = _round(scaleX)),
              (cache.scaleY = _round(scaleY)),
              (cache.rotation = _round(rotation) + "deg"),
              (cache.rotationX = _round(rotationX) + "deg"),
              (cache.rotationY = _round(rotationY) + "deg"),
              (cache.skewX = skewX + "deg"),
              (cache.skewY = "0deg"),
              (cache.transformPerspective = perspective + "px"),
              (cache.zOrigin =
                parseFloat(origin.split(" ")[2]) ||
                (!uncache && cache.zOrigin) ||
                0) && (style[_transformOriginProp] = _firstTwoOnly(origin)),
              (cache.xOffset = cache.yOffset = 0),
              (cache.force3D = _config.force3D),
              (cache.renderTransform = cache.svg
                ? _renderSVGTransforms
                : _supports3D
                ? _renderCSSTransforms
                : _renderNon3DTransforms),
              (cache.uncache = 0)),
            cache
          );
        },
        _firstTwoOnly = function _firstTwoOnly(value) {
          return (value = value.split(" "))[0] + " " + value[1];
        },
        _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
          (cache.z = "0px"),
            (cache.rotationY = cache.rotationX = "0deg"),
            (cache.force3D = 0),
            _renderCSSTransforms(ratio, cache);
        },
        _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
          var a13,
            a33,
            cos,
            cache = cache || this,
            xPercent = cache.xPercent,
            yPercent = cache.yPercent,
            x = cache.x,
            y = cache.y,
            z = cache.z,
            rotation = cache.rotation,
            rotationY = cache.rotationY,
            rotationX = cache.rotationX,
            skewX = cache.skewX,
            skewY = cache.skewY,
            scaleX = cache.scaleX,
            scaleY = cache.scaleY,
            transformPerspective = cache.transformPerspective,
            force3D = cache.force3D,
            target = cache.target,
            cache = cache.zOrigin,
            transforms = "",
            ratio =
              ("auto" === force3D && ratio && 1 !== ratio) || !0 === force3D;
          !cache ||
            ("0deg" === rotationX && "0deg" === rotationY) ||
            ((force3D = parseFloat(rotationY) * _DEG2RAD),
            (a13 = Math.sin(force3D)),
            (a33 = Math.cos(force3D)),
            (force3D = parseFloat(rotationX) * _DEG2RAD),
            (cos = Math.cos(force3D)),
            (x = _addPxTranslate(target, x, a13 * cos * -cache)),
            (y = _addPxTranslate(target, y, -Math.sin(force3D) * -cache)),
            (z = _addPxTranslate(target, z, a33 * cos * -cache + cache))),
            "0px" !== transformPerspective &&
              (transforms += "perspective(" + transformPerspective + ") "),
            (xPercent || yPercent) &&
              (transforms +=
                "translate(" + xPercent + "%, " + yPercent + "%) "),
            (!ratio && "0px" === x && "0px" === y && "0px" === z) ||
              (transforms +=
                "0px" !== z || ratio
                  ? "translate3d(" + x + ", " + y + ", " + z + ") "
                  : "translate(" + x + ", " + y + ") "),
            "0deg" !== rotation && (transforms += "rotate(" + rotation + ") "),
            "0deg" !== rotationY &&
              (transforms += "rotateY(" + rotationY + ") "),
            "0deg" !== rotationX &&
              (transforms += "rotateX(" + rotationX + ") "),
            ("0deg" === skewX && "0deg" === skewY) ||
              (transforms += "skew(" + skewX + ", " + skewY + ") "),
            (1 === scaleX && 1 === scaleY) ||
              (transforms += "scale(" + scaleX + ", " + scaleY + ") "),
            (target.style[_transformProp] = transforms || "translate(0, 0)");
        },
        _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
          var a11,
            a21,
            a12,
            a22,
            temp,
            cache = cache || this,
            xPercent = cache.xPercent,
            yPercent = cache.yPercent,
            x = cache.x,
            y = cache.y,
            rotation = cache.rotation,
            skewX = cache.skewX,
            skewY = cache.skewY,
            scaleX = cache.scaleX,
            scaleY = cache.scaleY,
            target = cache.target,
            xOrigin = cache.xOrigin,
            yOrigin = cache.yOrigin,
            xOffset = cache.xOffset,
            yOffset = cache.yOffset,
            cache = cache.forceCSS,
            tx = parseFloat(x),
            ty = parseFloat(y),
            rotation = parseFloat(rotation),
            skewX = parseFloat(skewX);
          (skewY = parseFloat(skewY)) &&
            ((skewX += skewY = parseFloat(skewY)), (rotation += skewY)),
            rotation || skewX
              ? ((rotation *= _DEG2RAD),
                (skewX *= _DEG2RAD),
                (a11 = Math.cos(rotation) * scaleX),
                (a21 = Math.sin(rotation) * scaleX),
                (a12 = Math.sin(rotation - skewX) * -scaleY),
                (a22 = Math.cos(rotation - skewX) * scaleY),
                skewX &&
                  ((skewY *= _DEG2RAD),
                  (temp = Math.tan(skewX - skewY)),
                  (a12 *= temp = Math.sqrt(1 + temp * temp)),
                  (a22 *= temp),
                  skewY) &&
                  ((temp = Math.tan(skewY)),
                  (a11 *= temp = Math.sqrt(1 + temp * temp)),
                  (a21 *= temp)),
                (a11 = _round(a11)),
                (a21 = _round(a21)),
                (a12 = _round(a12)),
                (a22 = _round(a22)))
              : ((a11 = scaleX), (a22 = scaleY), (a21 = a12 = 0)),
            ((tx && !~(x + "").indexOf("px")) ||
              (ty && !~(y + "").indexOf("px"))) &&
              ((tx = _convertToUnit(target, "x", x, "px")),
              (ty = _convertToUnit(target, "y", y, "px"))),
            (xOrigin || yOrigin || xOffset || yOffset) &&
              ((tx = _round(
                tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset
              )),
              (ty = _round(
                ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset
              ))),
            (xPercent || yPercent) &&
              ((temp = target.getBBox()),
              (tx = _round(tx + (xPercent / 100) * temp.width)),
              (ty = _round(ty + (yPercent / 100) * temp.height))),
            target.setAttribute(
              "transform",
              (temp =
                "matrix(" +
                a11 +
                "," +
                a21 +
                "," +
                a12 +
                "," +
                a22 +
                "," +
                tx +
                "," +
                ty +
                ")")
            ),
            cache && (target.style[_transformProp] = temp);
        },
        CSSPlugin =
          (_forEachName("padding,margin,Width,Radius", function (name, index) {
            var t = "Top",
              r = "Right",
              b = "Bottom",
              l = "Left",
              props = (
                index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]
              ).map(function (side) {
                return index < 2 ? name + side : "border" + side + name;
              });
            _specialProps[1 < index ? "border" + name : name] = function (
              plugin,
              target,
              property,
              endValue,
              tween
            ) {
              var a, vars;
              if (arguments.length < 4)
                return (
                  (a = props.map(function (prop) {
                    return _get(plugin, prop, property);
                  })),
                  5 === (vars = a.join(" ")).split(a[0]).length ? a[0] : vars
                );
              (a = (endValue + "").split(" ")),
                (vars = {}),
                props.forEach(function (prop, i) {
                  return (vars[prop] = a[i] = a[i] || a[((i - 1) / 2) | 0]);
                }),
                plugin.init(target, vars, tween);
            };
          }),
          {
            name: "css",
            register: _initCore,
            targetTest: function targetTest(target) {
              return target.style && target.nodeType;
            },
            init: function init(target, vars, tween, index, targets) {
              var startValue,
                endValue,
                endNum,
                specialProp,
                p,
                startUnit,
                endUnit,
                type,
                isTransformRelated,
                transformPropTween,
                cache,
                smooth,
                hasPriority,
                inlineProps,
                props = this._props,
                style = target.style,
                startAt = tween.vars.startAt;
              for (p in (_pluginInitted || _initCore(),
              (this.styles = this.styles || _getStyleSaver(target)),
              (inlineProps = this.styles.props),
              (this.tween = tween),
              vars))
                if (
                  "autoRound" !== p &&
                  ((endValue = vars[p]),
                  !_plugins[p] ||
                    !_checkPlugin(p, vars, tween, index, target, targets))
                )
                  if (
                    ((specialProp = _specialProps[p]),
                    "string" ===
                      (type =
                        "function" === (type = typeof endValue)
                          ? typeof (endValue = endValue.call(
                              tween,
                              index,
                              target,
                              targets
                            ))
                          : type) &&
                      ~endValue.indexOf("random(") &&
                      (endValue = _replaceRandom(endValue)),
                    specialProp)
                  )
                    specialProp(this, target, p, endValue, tween) &&
                      (hasPriority = 1);
                  else if ("--" === p.substr(0, 2))
                    (startValue = (
                      getComputedStyle(target).getPropertyValue(p) + ""
                    ).trim()),
                      (endValue += ""),
                      (_colorExp.lastIndex = 0),
                      _colorExp.test(startValue) ||
                        ((startUnit = getUnit(startValue)),
                        (endUnit = getUnit(endValue))),
                      endUnit
                        ? startUnit !== endUnit &&
                          (startValue =
                            _convertToUnit(target, p, startValue, endUnit) +
                            endUnit)
                        : startUnit && (endValue += startUnit),
                      this.add(
                        style,
                        "setProperty",
                        startValue,
                        endValue,
                        index,
                        targets,
                        0,
                        0,
                        p
                      ),
                      props.push(p),
                      inlineProps.push(p, 0, style[p]);
                  else if ("undefined" !== type) {
                    if (
                      ((!(startAt && p in startAt) ||
                        ((startValue =
                          "function" == typeof startAt[p]
                            ? startAt[p].call(tween, index, target, targets)
                            : startAt[p]),
                        _isString(startValue) &&
                          ~startValue.indexOf("random(") &&
                          (startValue = _replaceRandom(startValue)),
                        getUnit(startValue + "") ||
                          "auto" === startValue ||
                          (startValue +=
                            _config.units[p] || getUnit(_get(target, p)) || ""),
                        "=" === (startValue + "").charAt(1))) &&
                        (startValue = _get(target, p)),
                      (specialProp = parseFloat(startValue)),
                      (type =
                        "string" === type &&
                        "=" === endValue.charAt(1) &&
                        endValue.substr(0, 2)) &&
                        (endValue = endValue.substr(2)),
                      (endNum = parseFloat(endValue)),
                      (isTransformRelated =
                        (p =
                          p in _propertyAliases &&
                          ("autoAlpha" === p &&
                            (1 === specialProp &&
                              "hidden" === _get(target, "visibility") &&
                              endNum &&
                              (specialProp = 0),
                            inlineProps.push("visibility", 0, style.visibility),
                            _addNonTweeningPT(
                              this,
                              style,
                              "visibility",
                              specialProp ? "inherit" : "hidden",
                              endNum ? "inherit" : "hidden",
                              !endNum
                            )),
                          "scale" !== p) &&
                          "transform" !== p &&
                          ~(p = _propertyAliases[p]).indexOf(",")
                            ? p.split(",")[0]
                            : p) in _transformProps))
                    )
                      if (
                        (this.styles.save(p),
                        transformPropTween ||
                          (((cache = target._gsap).renderTransform &&
                            !vars.parseTransform) ||
                            _parseTransform(target, vars.parseTransform),
                          (smooth = !1 !== vars.smoothOrigin && cache.smooth),
                          ((transformPropTween = this._pt =
                            new PropTween(
                              this._pt,
                              style,
                              _transformProp,
                              0,
                              1,
                              cache.renderTransform,
                              cache,
                              0,
                              -1
                            )).dep = 1)),
                        "scale" === p)
                      )
                        (this._pt = new PropTween(
                          this._pt,
                          cache,
                          "scaleY",
                          cache.scaleY,
                          (type
                            ? _parseRelative(cache.scaleY, type + endNum)
                            : endNum) - cache.scaleY || 0,
                          _renderCSSProp
                        )),
                          (this._pt.u = 0),
                          props.push("scaleY", p),
                          (p += "X");
                      else {
                        if ("transformOrigin" === p) {
                          inlineProps.push(
                            _transformOriginProp,
                            0,
                            style[_transformOriginProp]
                          ),
                            (endValue =
                              _convertKeywordsToPercentages(endValue)),
                            cache.svg
                              ? _applySVGOrigin(
                                  target,
                                  endValue,
                                  0,
                                  smooth,
                                  0,
                                  this
                                )
                              : ((endUnit =
                                  parseFloat(endValue.split(" ")[2]) || 0) !==
                                  cache.zOrigin &&
                                  _addNonTweeningPT(
                                    this,
                                    cache,
                                    "zOrigin",
                                    cache.zOrigin,
                                    endUnit
                                  ),
                                _addNonTweeningPT(
                                  this,
                                  style,
                                  p,
                                  _firstTwoOnly(startValue),
                                  _firstTwoOnly(endValue)
                                ));
                          continue;
                        }
                        if ("svgOrigin" === p) {
                          _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                          continue;
                        }
                        if (p in _rotationalProperties) {
                          _addRotationalPropTween(
                            this,
                            cache,
                            p,
                            specialProp,
                            type
                              ? _parseRelative(specialProp, type + endValue)
                              : endValue
                          );
                          continue;
                        }
                        if ("smoothOrigin" === p) {
                          _addNonTweeningPT(
                            this,
                            cache,
                            "smooth",
                            cache.smooth,
                            endValue
                          );
                          continue;
                        }
                        if ("force3D" === p) {
                          cache[p] = endValue;
                          continue;
                        }
                        if ("transform" === p) {
                          _addRawTransformPTs(this, endValue, target);
                          continue;
                        }
                      }
                    else p in style || (p = _checkPropPrefix(p) || p);
                    if (
                      isTransformRelated ||
                      ((endNum || 0 === endNum) &&
                        (specialProp || 0 === specialProp) &&
                        !_complexExp.test(endValue) &&
                        p in style)
                    )
                      (endNum = endNum || 0),
                        (startUnit = (startValue + "").substr(
                          (specialProp + "").length
                        )) !==
                          (endUnit =
                            getUnit(endValue) ||
                            (p in _config.units
                              ? _config.units[p]
                              : startUnit)) &&
                          (specialProp = _convertToUnit(
                            target,
                            p,
                            startValue,
                            endUnit
                          )),
                        (this._pt = new PropTween(
                          this._pt,
                          isTransformRelated ? cache : style,
                          p,
                          specialProp,
                          (type
                            ? _parseRelative(specialProp, type + endNum)
                            : endNum) - specialProp,
                          isTransformRelated ||
                          ("px" !== endUnit && "zIndex" !== p) ||
                          !1 === vars.autoRound
                            ? _renderCSSProp
                            : _renderRoundedCSSProp
                        )),
                        (this._pt.u = endUnit || 0),
                        startUnit !== endUnit &&
                          "%" !== endUnit &&
                          ((this._pt.b = startValue),
                          (this._pt.r = _renderCSSPropWithBeginning));
                    else if (p in style)
                      _tweenComplexCSSString.call(
                        this,
                        target,
                        p,
                        startValue,
                        type ? type + endValue : endValue
                      );
                    else if (p in target)
                      this.add(
                        target,
                        p,
                        startValue || target[p],
                        type ? type + endValue : endValue,
                        index,
                        targets
                      );
                    else if ("parseTransform" !== p) {
                      _missingPlugin(p, endValue);
                      continue;
                    }
                    isTransformRelated ||
                      (p in style
                        ? inlineProps.push(p, 0, style[p])
                        : inlineProps.push(p, 1, startValue || target[p])),
                      props.push(p);
                  }
              hasPriority && _sortPropTweensByPriority(this);
            },
            render: function render(ratio, data) {
              if (data.tween._time || !CSSPlugin_reverting())
                for (var pt = data._pt; pt; )
                  pt.r(ratio, pt.d), (pt = pt._next);
              else data.styles.revert();
            },
            get: _get,
            aliases: _propertyAliases,
            getSetter: function getSetter(target, property, plugin) {
              var p = _propertyAliases[property];
              return (property = p && p.indexOf(",") < 0 ? p : property) in
                _transformProps &&
                property !== _transformOriginProp &&
                (target._gsap.x || _get(target, "x"))
                ? plugin && _recentSetterPlugin === plugin
                  ? "scale" === property
                    ? _setterScale
                    : _setterTransform
                  : (_recentSetterPlugin = plugin || {}) &&
                    ("scale" === property
                      ? _setterScaleWithRender
                      : _setterTransformWithRender)
                : target.style && !_isUndefined(target.style[property])
                ? _setterCSSStyle
                : ~property.indexOf("-")
                ? _setterCSSProp
                : _getSetter(target, property);
            },
            core: { _removeProperty: _removeProperty, _getMatrix: _getMatrix },
          });
      (gsap.utils.checkPrefix = _checkPropPrefix),
        (gsap.core.getStyleSaver = _getStyleSaver),
        (all = _forEachName(
          "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," +
            (rotation = "rotation,rotationX,rotationY,skewX,skewY") +
            ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
          function (name) {
            _transformProps[name] = 1;
          }
        )),
        _forEachName(rotation, function (name) {
          (_config.units[name] = "deg"), (_rotationalProperties[name] = 1);
        }),
        (_propertyAliases[all[13]] =
          "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + rotation),
        _forEachName(
          "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
          function (name) {
            name = name.split(":");
            _propertyAliases[name[1]] = all[name[0]];
          }
        ),
        _forEachName(
          "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
          function (name) {
            _config.units[name] = "px";
          }
        ),
        gsap.registerPlugin(CSSPlugin);
      var TweenMaxWithCSS = (gsap.registerPlugin(CSSPlugin) || gsap).core.Tween,
        rotation = __webpack_require__(2688),
        s = ({ condition: e, wrapper: t, children: r }) => (e ? t(r) : r),
        u = ({ effects: t, id: r }) =>
          0 === t.length
            ? null
            : react.createElement(
                "filter",
                { id: r },
                t.map((t, r) =>
                  react.createElement("feColorMatrix", {
                    key: r,
                    type: "matrix",
                    values: t,
                  })
                )
              );
      const m = {
          position: "relative",
          isolation: "isolate",
          display: "block",
          color: "white",
          fontFamily: "inherit",
        },
        f = {
          position: "relative",
          width: "100%",
          visibility: "hidden",
          display: "block",
        },
        d = {
          position: "absolute",
          top: "0",
          left: "0",
          width: "100%",
          height: "100%",
          zIndex: 5,
        },
        h = (0, react.forwardRef)(
          (
            {
              src: n,
              alt: o,
              blur: h = 15,
              radiusScale: g = 1,
              fixedRadius: p = null,
              canReveal: E = !0,
              autoReveal: v = !1,
              persistReveal: y = !1,
              onClick: x = () => {},
              effects: b = [],
              imageLayerEffects: w = [],
              blurLayerEffects: R = [],
              circleInTransition: $ = "elastic.out(1, 0.3)",
              circleInDuration: k = 0.5,
              circleOutTransition: M = "expo.out",
              circleOutDuration: C = 0.2,
              zoom: O = 1,
            },
            T
          ) => {
            const I = (0, react.useId)(),
              L = "xray-circle-" + I,
              D = "blur-filter-" + I,
              q = "effects-filter-" + I,
              z = "image-effects-filter-" + I,
              B = "blur-effects-filter-" + I,
              S = `url(#${L})`,
              _ = `url(#${D})`,
              F = `url(#${q})`,
              H = `url(#${z})`,
              N = `url(#${B})`,
              P = Math.max(1, O),
              X = T || (0, react.useRef)(null),
              Y = null === p,
              [G, A] = (0, react.useState)(Y ? 50 : p),
              [K, U] = (0, react.useState)(null),
              [W, j] = (0, react.useState)(!1),
              [J, Q] = (0, react.useState)(!1),
              [V, Z] = (0, react.useState)(!1),
              ee = (e) => {
                (!e && y) || Q(e);
              },
              te = (0, react.useMemo)(
                () =>
                  !(
                    !E ||
                    v ||
                    !W ||
                    V ||
                    (X.current &&
                      X.current.matches &&
                      X.current.matches(":hover"))
                  ),
                [W, V]
              ),
              re = () => {
                var e;
                X.current &&
                  Y &&
                  ((e = Math.min(
                    X.current.clientWidth,
                    X.current.clientHeight
                  )),
                  A(((0.5 * e) / 2) * g));
              },
              [ne, ie] =
                (((n, i) => {
                  const [l, c] = (0, react.useState)(!1);
                  (0, react.useEffect)(() => {
                    l && re();
                  }, [...n, l]);
                  n = new Image();
                  (n.src = i), (n.onload = () => c(!0));
                })([X.current, g], n),
                (0, react.useEffect)(() => {
                  const e = () => {
                    re(), X.current && U(X.current.getBoundingClientRect());
                  };
                  return (
                    window.addEventListener("resize", e),
                    () => {
                      window.removeEventListener("resize", e);
                    }
                  );
                }, []),
                (0, react.useEffect)(() => {
                  X.current &&
                    X.current.matches &&
                    (Z(X.current.matches(":hover")),
                    U(X.current.getBoundingClientRect()));
                }, [X]),
                (0, react.useState)(-1e3)),
              [le, ce] = (0, react.useState)(-1e3),
              [ae, , oe] = (() => {
                const [r, n] = (0, react.useState)(0),
                  [i, l] = (0, react.useState)(null);
                return [
                  r,
                  (e) => {
                    i && (i.kill(), l(null)), n(e);
                  },
                  (e, t = 0.5, c = "elastic.out(1, 0.3)") => {
                    i && i.kill();
                    const o = { val: r },
                      s = TweenMaxWithCSS.to(o, t, {
                        val: e,
                        ease: c,
                        onUpdate: () => n(o.val),
                      });
                    l(s);
                  },
                ];
              })();
            return react.createElement(
              "div",
              {
                className: "xray",
                onMouseMove: (e) => {
                  console.log("Mouse move", e, ne, le);
                  e = e.nativeEvent;
                  ie(e.offsetX), ce(e.offsetY), Z(!0), v || ee(!1);
                },
                onMouseEnter: () => {
                  G && (oe(G, k, $), Z(!0), v || ee(!1));
                },
                onMouseLeave: () => {
                  oe(0, C, M), Z(!1);
                },
                onTouchStart: (e) => {
                  0 !== e.touches.length &&
                    K &&
                    G &&
                    ((e = e.touches[0]),
                    oe(G, k, $),
                    ie(e.clientX - K.left),
                    ce(e.clientY - K.top),
                    Z(!0),
                    ee(!1));
                },
                onTouchEnd: () => {
                  oe(0, C, M), Z(!1);
                },
                onTouchMove: (e) => {
                  0 !== e.touches.length &&
                    K &&
                    ((e = e.touches[0]),
                    ie(e.clientX - K.left),
                    ce(e.clientY - K.top),
                    Z(!0),
                    ee(!1));
                },
                onFocus: () => {
                  j(!0), v && ee(!0);
                },
                onBlur: () => {
                  j(!1), ee(!1);
                },
                onKeyDown: (e) => {
                  W && te && 32 === e.keyCode && ee(!J);
                },
                onClick: x,
                ref: X,
                tabIndex: 0,
                role: "img",
                "aria-label": o,
                style: m,
              },
              react.createElement("img", {
                className: "xray__image",
                src: n,
                alt: o,
                style: f,
              }),
              react.createElement(
                "svg",
                { className: "xray__svg", style: d },
                react.createElement(
                  "defs",
                  null,
                  react.createElement(
                    "clipPath",
                    { id: L },
                    react.createElement("circle", { cx: ne, cy: le, r: ae }),
                    J &&
                      react.createElement("rect", {
                        x: "0",
                        y: "0",
                        width: "100%",
                        height: "100%",
                      })
                  ),
                  react.createElement(
                    "filter",
                    { id: D },
                    react.createElement("feGaussianBlur", {
                      in: "SourceGraphic",
                      stdDeviation: h,
                    })
                  ),
                  react.createElement(u, { id: q, effects: b }),
                  react.createElement(u, { id: z, effects: w }),
                  react.createElement(u, { id: B, effects: R })
                ),
                react.createElement(
                  s,
                  {
                    condition: 0 < b.length,
                    wrapper: (t) => react.createElement("g", { filter: F }, t),
                  },
                  react.createElement(
                    react.Fragment,
                    null,
                    react.createElement(
                      s,
                      {
                        condition: 0 < R.length,
                        wrapper: (t) =>
                          react.createElement("g", { filter: N }, t),
                      },
                      react.createElement("image", {
                        xlinkHref: n,
                        filter: _,
                        x: "0",
                        y: "0",
                        width: "100%",
                      })
                    ),
                    react.createElement(
                      s,
                      {
                        condition: 0 < w.length,
                        wrapper: (t) =>
                          react.createElement("g", { filter: H }, t),
                      },
                      react.createElement(
                        "g",
                        { clipPath: S },
                        react.createElement("image", {
                          xlinkHref: n,
                          x: "0",
                          y: "0",
                          width: "100%",
                          style: {
                            transform: `scale(${J ? 1 : P})`,
                            transformOrigin: `${ne}px ${le}px`,
                          },
                        })
                      )
                    )
                  )
                ),
                W &&
                  !J &&
                  te &&
                  react.createElement(
                    "text",
                    {
                      x: "50%",
                      y: "50%",
                      dominantBaseline: "middle",
                      textAnchor: "middle",
                      fill: "currentColor",
                    },
                    "Press 'Space' to reveal"
                  )
              )
            );
          }
        );
      h.propTypes = {
        src: rotation.string.isRequired,
        alt: rotation.string.isRequired,
        blur: rotation.number,
        radiusScale: rotation.number,
        fixedRadius: rotation.number,
        canReveal: rotation.bool,
        autoReveal: rotation.bool,
        persistReveal: rotation.bool,
        onClick: rotation.func,
        effects: rotation.arrayOf(rotation.string.isRequired),
        imageLayerEffects: rotation.arrayOf(rotation.string.isRequired),
        blurLayerEffects: rotation.arrayOf(rotation.string.isRequired),
        circleInTransition: rotation.string,
        circleInDuration: rotation.number,
        circleOutTransition: rotation.string,
        circleOutDuration: rotation.number,
        zoom: rotation.number,
      };
    },
    4045: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Br: () =>
          function isIosAndRedirectable() {
            if (!navigator) return !1;
            var userAgent = navigator.userAgent.toLowerCase(),
              isIos =
                userAgent.includes("iphone") || userAgent.includes("ipad"),
              userAgent = userAgent.includes("safari");
            return isIos && userAgent;
          },
        Ce: () => BaseWalletAdapter,
        Ok: () => WalletReadyState,
        qG: () =>
          function scopePollingDetectionStrategy(detect) {
            if (
              "undefined" != typeof window &&
              "undefined" != typeof document
            ) {
              const disposers = [],
                interval = setInterval(detectAndDispose, 1e3);
              function detectAndDispose() {
                if (detect()) for (const dispose of disposers) dispose();
              }
              disposers.push(() => clearInterval(interval)),
                "loading" === document.readyState &&
                  (document.addEventListener(
                    "DOMContentLoaded",
                    detectAndDispose,
                    { once: !0 }
                  ),
                  disposers.push(() =>
                    document.removeEventListener(
                      "DOMContentLoaded",
                      detectAndDispose
                    )
                  )),
                "complete" !== document.readyState &&
                  (window.addEventListener("load", detectAndDispose, {
                    once: !0,
                  }),
                  disposers.push(() =>
                    window.removeEventListener("load", detectAndDispose)
                  )),
                detectAndDispose();
            }
          },
      });
      var WalletReadyState,
        __webpack_exports__ = __webpack_require__(792),
        _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2631);
      !(function (WalletReadyState) {
        (WalletReadyState.Installed = "Installed"),
          (WalletReadyState.NotDetected = "NotDetected"),
          (WalletReadyState.Loadable = "Loadable"),
          (WalletReadyState.Unsupported = "Unsupported");
      })((WalletReadyState = WalletReadyState || {}));
      class BaseWalletAdapter extends __webpack_exports__ {
        get connected() {
          return !!this.publicKey;
        }
        async autoConnect() {
          await this.connect();
        }
        async prepareTransaction(transaction, connection, options = {}) {
          var publicKey = this.publicKey;
          if (publicKey)
            return (
              (transaction.feePayer = transaction.feePayer || publicKey),
              (transaction.recentBlockhash =
                transaction.recentBlockhash ||
                (
                  await connection.getLatestBlockhash({
                    commitment: options.preflightCommitment,
                    minContextSlot: options.minContextSlot,
                  })
                ).blockhash),
              transaction
            );
          throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.kW();
        }
      }
    },
    2631: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        AE: () => WalletNotReadyError,
        Ez: () => WalletConfigError,
        K3: () => WalletSignMessageError,
        Kd: () => WalletPublicKeyError,
        PQ: () => WalletDisconnectedError,
        Sz: () => WalletLoadError,
        UF: () => WalletSendTransactionError,
        Y6: () => WalletConnectionError,
        Y8: () => WalletDisconnectionError,
        fk: () => WalletAccountError,
        kW: () => WalletNotConnectedError,
        m7: () => WalletError,
        o7: () => WalletSignInError,
        z4: () => WalletSignTransactionError,
      });
      class WalletError extends Error {
        constructor(message, error) {
          super(message), (this.error = error);
        }
      }
      class WalletNotReadyError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletNotReadyError");
        }
      }
      class WalletLoadError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletLoadError");
        }
      }
      class WalletConfigError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletConfigError");
        }
      }
      class WalletConnectionError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletConnectionError");
        }
      }
      class WalletDisconnectedError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletDisconnectedError");
        }
      }
      class WalletDisconnectionError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletDisconnectionError");
        }
      }
      class WalletAccountError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletAccountError");
        }
      }
      class WalletPublicKeyError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletPublicKeyError");
        }
      }
      (class extends WalletError {});
      class WalletNotConnectedError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletNotConnectedError");
        }
      }
      class WalletSendTransactionError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletSendTransactionError");
        }
      }
      class WalletSignTransactionError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletSignTransactionError");
        }
      }
      class WalletSignMessageError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletSignMessageError");
        }
      }
      class WalletSignInError extends WalletError {
        constructor() {
          super(...arguments), (this.name = "WalletSignInError");
        }
      }
      (class extends WalletError {});
      (class extends WalletError {});
      (class extends WalletError {});
    },
    1594: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        DE: () => BaseMessageSignerWalletAdapter,
        Kl: () => BaseSignerWalletAdapter,
        Xl: () => BaseSignInMessageSignerWalletAdapter,
      });
      var __webpack_exports__ = __webpack_require__(4045),
        _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2631),
        _transaction_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(7158);
      class BaseSignerWalletAdapter extends __webpack_exports__.Ce {
        async sendTransaction(transaction, connection, options = {}) {
          let emit = !0;
          try {
            if (
              (0, _transaction_js__WEBPACK_IMPORTED_MODULE_1__.Y)(transaction)
            ) {
              if (!this.supportedTransactionVersions)
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UF(
                  "Sending versioned transactions isn't supported by this wallet"
                );
              if (!this.supportedTransactionVersions.has(transaction.version))
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UF(
                  `Sending transaction version ${transaction.version} isn't supported by this wallet`
                );
              try {
                var rawTransaction = (transaction = await this.signTransaction(
                  transaction
                )).serialize();
                return await connection.sendRawTransaction(
                  rawTransaction,
                  options
                );
              } catch (error) {
                if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.z4)
                  throw ((emit = !1), error);
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UF(
                  error?.message,
                  error
                );
              }
            } else
              try {
                const { signers, ...sendOptions } = options,
                  rawTransaction =
                    ((transaction = await this.prepareTransaction(
                      transaction,
                      connection,
                      sendOptions
                    )),
                    signers?.length && transaction.partialSign(...signers),
                    (transaction = await this.signTransaction(
                      transaction
                    )).serialize());
                return await connection.sendRawTransaction(
                  rawTransaction,
                  sendOptions
                );
              } catch (error) {
                if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.z4)
                  throw ((emit = !1), error);
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.UF(
                  error?.message,
                  error
                );
              }
          } catch (error) {
            throw (emit && this.emit("error", error), error);
          }
        }
        async signAllTransactions(transactions) {
          for (const transaction of transactions)
            if (
              (0, _transaction_js__WEBPACK_IMPORTED_MODULE_1__.Y)(transaction)
            ) {
              if (!this.supportedTransactionVersions)
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.z4(
                  "Signing versioned transactions isn't supported by this wallet"
                );
              if (!this.supportedTransactionVersions.has(transaction.version))
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.z4(
                  `Signing transaction version ${transaction.version} isn't supported by this wallet`
                );
            }
          var signedTransactions = [];
          for (const transaction of transactions)
            signedTransactions.push(await this.signTransaction(transaction));
          return signedTransactions;
        }
      }
      class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}
      class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {}
    },
    7158: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Y: () =>
          function isVersionedTransaction(transaction) {
            return "version" in transaction;
          },
      });
    },
    143: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      var WalletAdapterNetwork;
      __webpack_require__.d(__webpack_exports__, {
        B: () => WalletAdapterNetwork,
      }),
        (function (WalletAdapterNetwork) {
          (WalletAdapterNetwork.Mainnet = "mainnet-beta"),
            (WalletAdapterNetwork.Testnet = "testnet"),
            (WalletAdapterNetwork.Devnet = "devnet");
        })((WalletAdapterNetwork = WalletAdapterNetwork || {}));
    },
    7084: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        G: () => LedgerWalletAdapter,
      });
      var __webpack_exports__ = __webpack_require__(1594),
        adapter = __webpack_require__(4045),
        errors = __webpack_require__(2631),
        Transport = __webpack_require__(9720),
        esm_transaction = __webpack_require__(7158),
        index_browser_esm = __webpack_require__(8769);
      const BIP32_HARDENED_BIT = (1 << 31) >>> 0;
      function harden(n) {
        return (n | BIP32_HARDENED_BIT) >>> 0;
      }
      const P2_EXTEND = 1,
        P2_MORE = 2,
        MAX_PAYLOAD = 255,
        LEDGER_CLA = 224;
      async function send(transport, instruction, p1, data) {
        let p2 = 0,
          offset = 0;
        if (data.length > MAX_PAYLOAD)
          for (; data.length - offset > MAX_PAYLOAD; ) {
            const buffer = data.slice(offset, offset + MAX_PAYLOAD),
              response = await transport.send(
                LEDGER_CLA,
                instruction,
                p1,
                p2 | P2_MORE,
                buffer
              );
            if (2 !== response.length)
              throw new Transport._3(Transport.vi.INCORRECT_DATA);
            (p2 |= P2_EXTEND), (offset += MAX_PAYLOAD);
          }
        const buffer = data.slice(offset),
          response = await transport.send(
            LEDGER_CLA,
            instruction,
            p1,
            p2,
            buffer
          );
        return response.slice(0, response.length - 2);
      }
      class LedgerWalletAdapter extends __webpack_exports__.Kl {
        constructor(config = {}) {
          super(),
            (this.name = "Ledger"),
            (this.url = "https://ledger.com"),
            (this.icon =
              "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzUgMzUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiI+PHBhdGggZD0ibTIzLjU4OCAwaC0xNnYyMS41ODNoMjEuNnYtMTZhNS41ODUgNS41ODUgMCAwIDAgLTUuNi01LjU4M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5KSIvPjxwYXRoIGQ9Im04LjM0MiAwaC0yLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCAtNS41ODUgNS41ODV2Mi43NTdoOC4zNDJ6Ii8+PHBhdGggZD0ibTAgNy41OWg4LjM0MnY4LjM0MmgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDUuNzM5KSIvPjxwYXRoIGQ9Im0xNS4xOCAyMy40NTFoMi43NTdhNS41ODUgNS41ODUgMCAwIDAgNS41ODUtNS42di0yLjY3MWgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMS40NzggMTEuNDc4KSIvPjxwYXRoIGQ9Im03LjU5IDE1LjE4aDguMzQydjguMzQyaC04LjM0MnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5IDExLjQ3OCkiLz48cGF0aCBkPSJtMCAxNS4xOHYyLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCA1LjU4NSA1LjU4NWgyLjc1N3YtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDExLjQ3OCkiLz48L2c+PC9zdmc+"),
            (this.supportedTransactionVersions = new Set(["legacy", 0])),
            (this._readyState =
              "undefined" != typeof window &&
              "undefined" != typeof document &&
              "undefined" != typeof navigator &&
              navigator.hid
                ? adapter.Ok.Loadable
                : adapter.Ok.Unsupported),
            (this._disconnected = () => {
              var transport = this._transport;
              transport &&
                (transport.off("disconnect", this._disconnected),
                (this._transport = null),
                (this._publicKey = null),
                this.emit("error", new errors.PQ()),
                this.emit("disconnect"));
            }),
            (this._derivationPath =
              config.derivationPath ||
              (function getDerivationPath(account, change) {
                var length =
                    void 0 !== account ? (void 0 === change ? 3 : 4) : 2,
                  derivationPath = Buffer.alloc(1 + 4 * length),
                  length = derivationPath.writeUInt8(length, 0),
                  length = derivationPath.writeUInt32BE(harden(44), length);
                return (
                  (length = derivationPath.writeUInt32BE(harden(501), length)),
                  void 0 !== account &&
                    ((length = derivationPath.writeUInt32BE(
                      harden(account),
                      length
                    )),
                    void 0 !== change) &&
                    derivationPath.writeUInt32BE(harden(change), length),
                  derivationPath
                );
              })(0, 0)),
            (this._connecting = !1),
            (this._transport = null),
            (this._publicKey = null);
        }
        get publicKey() {
          return this._publicKey;
        }
        get connecting() {
          return this._connecting;
        }
        get readyState() {
          return this._readyState;
        }
        async connect() {
          try {
            if (!this.connected && !this.connecting) {
              if (this._readyState !== adapter.Ok.Loadable)
                throw new errors.AE();
              this._connecting = !0;
              let TransportWebHIDClass;
              try {
                TransportWebHIDClass = (
                  await Promise.all([
                    __webpack_require__.e(449),
                    __webpack_require__.e(409),
                  ]).then(__webpack_require__.bind(__webpack_require__, 9409))
                ).default;
              } catch (error) {
                throw new errors.Sz(error?.message, error);
              }
              let transport;
              try {
                transport = await TransportWebHIDClass.create();
              } catch (error) {
                throw new errors.Y6(error?.message, error);
              }
              let publicKey;
              try {
                publicKey = await (async function getPublicKey(
                  transport,
                  derivationPath
                ) {
                  return (
                    (transport = await send(transport, 5, 0, derivationPath)),
                    new index_browser_esm.J3(transport)
                  );
                })(transport, this._derivationPath);
              } catch (error) {
                throw new errors.Kd(error?.message, error);
              }
              transport.on("disconnect", this._disconnected),
                (this._transport = transport),
                (this._publicKey = publicKey),
                this.emit("connect", publicKey);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          } finally {
            this._connecting = !1;
          }
        }
        async disconnect() {
          var transport = this._transport;
          if (transport) {
            transport.off("disconnect", this._disconnected),
              (this._transport = null),
              (this._publicKey = null);
            try {
              await transport.close();
            } catch (error) {
              this.emit("error", new errors.Y8(error?.message, error));
            }
          }
          this.emit("disconnect");
        }
        async signTransaction(transaction) {
          try {
            var transport = this._transport,
              publicKey = this._publicKey;
            if (!transport || !publicKey) throw new errors.kW();
            try {
              var signature = await (async function signTransaction(
                transport,
                transaction,
                derivationPath
              ) {
                var paths = Buffer.alloc(1),
                  transaction =
                    (paths.writeUInt8(1, 0),
                    (0, esm_transaction.Y)(transaction)
                      ? transaction.message.serialize()
                      : transaction.serializeMessage());
                return send(
                  transport,
                  6,
                  1,
                  Buffer.concat([paths, derivationPath, transaction])
                );
              })(transport, transaction, this._derivationPath);
              transaction.addSignature(publicKey, signature);
            } catch (error) {
              throw new errors.z4(error?.message, error);
            }
            return transaction;
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
      }
    },
    5767: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        c: () => PhantomWalletAdapter,
      });
      var __webpack_exports__ = __webpack_require__(1594),
        _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(4045),
        _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(2631),
        _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(7158),
        _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(8769);
      class PhantomWalletAdapter extends __webpack_exports__.DE {
        constructor(config = 0) {
          super(),
            (this.name = "Phantom"),
            (this.url = "https://phantom.app"),
            (this.icon =
              "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg=="),
            (this.supportedTransactionVersions = new Set(["legacy", 0])),
            (this._readyState =
              "undefined" == typeof window || "undefined" == typeof document
                ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                    .Unsupported
                : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                    .NotDetected),
            (this._disconnected = () => {
              var wallet = this._wallet;
              wallet &&
                (wallet.off("disconnect", this._disconnected),
                wallet.off("accountChanged", this._accountChanged),
                (this._wallet = null),
                (this._publicKey = null),
                this.emit(
                  "error",
                  new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.PQ()
                ),
                this.emit("disconnect"));
            }),
            (this._accountChanged = (newPublicKey) => {
              var publicKey = this._publicKey;
              if (publicKey) {
                try {
                  newPublicKey =
                    new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.J3(
                      newPublicKey.toBytes()
                    );
                } catch (error) {
                  return void this.emit(
                    "error",
                    new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Kd(
                      error?.message,
                      error
                    )
                  );
                }
                publicKey.equals(newPublicKey) ||
                  ((this._publicKey = newPublicKey),
                  this.emit("connect", newPublicKey));
              }
            }),
            (this._connecting = !1),
            (this._wallet = null),
            (this._publicKey = null),
            this._readyState !==
              _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                .Unsupported &&
              ((0,
              _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Br)()
                ? ((this._readyState =
                    _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok.Loadable),
                  this.emit("readyStateChange", this._readyState))
                : (0,
                  _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.qG)(
                    () =>
                      !(
                        (!window.phantom?.solana?.isPhantom &&
                          !window.solana?.isPhantom) ||
                        ((this._readyState =
                          _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok.Installed),
                        this.emit("readyStateChange", this._readyState),
                        0)
                      )
                  ));
        }
        get publicKey() {
          return this._publicKey;
        }
        get connecting() {
          return this._connecting;
        }
        get readyState() {
          return this._readyState;
        }
        async autoConnect() {
          this.readyState ===
            _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
              .Installed && (await this.connect());
        }
        async connect() {
          try {
            var url, ref;
            if (!this.connected && !this.connecting)
              if (
                this.readyState ===
                _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                  .Loadable
              )
                (url = encodeURIComponent(window.location.href)),
                  (ref = encodeURIComponent(window.location.origin)),
                  (window.location.href =
                    `https://phantom.app/ul/browse/${url}?ref=` + ref);
              else {
                if (
                  this.readyState !==
                  _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                    .Installed
                )
                  throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.AE();
                this._connecting = !0;
                var wallet = window.phantom?.solana || window.solana;
                if (!wallet.isConnected)
                  try {
                    await wallet.connect();
                  } catch (error) {
                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Y6(
                      error?.message,
                      error
                    );
                  }
                if (!wallet.publicKey)
                  throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.fk();
                let publicKey;
                try {
                  publicKey =
                    new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.J3(
                      wallet.publicKey.toBytes()
                    );
                } catch (error) {
                  throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Kd(
                    error?.message,
                    error
                  );
                }
                wallet.on("disconnect", this._disconnected),
                  wallet.on("accountChanged", this._accountChanged),
                  (this._wallet = wallet),
                  (this._publicKey = publicKey),
                  this.emit("connect", publicKey);
              }
          } catch (error) {
            throw (this.emit("error", error), error);
          } finally {
            this._connecting = !1;
          }
        }
        async disconnect() {
          var wallet = this._wallet;
          if (wallet) {
            wallet.off("disconnect", this._disconnected),
              wallet.off("accountChanged", this._accountChanged),
              (this._wallet = null),
              (this._publicKey = null);
            try {
              await wallet.disconnect();
            } catch (error) {
              this.emit(
                "error",
                new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Y8(
                  error?.message,
                  error
                )
              );
            }
          }
          this.emit("disconnect");
        }
        async sendTransaction(transaction, connection, options = {}) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              const { signers, ...sendOptions } = options;
              (0, _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.Y)(
                transaction
              )
                ? signers?.length && transaction.sign(signers)
                : ((transaction = await this.prepareTransaction(
                    transaction,
                    connection,
                    sendOptions
                  )),
                  signers?.length && transaction.partialSign(...signers)),
                (sendOptions.preflightCommitment =
                  sendOptions.preflightCommitment || connection.commitment);
              var signature = (
                await wallet.signAndSendTransaction(transaction, sendOptions)
              )["signature"];
              return signature;
            } catch (error) {
              if (
                error instanceof
                _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.m7
              )
                throw error;
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.UF(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signTransaction(transaction) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              return (await wallet.signTransaction(transaction)) || transaction;
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.z4(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signAllTransactions(transactions) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              return (
                (await wallet.signAllTransactions(transactions)) || transactions
              );
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.z4(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signMessage(message) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              var signature = (await wallet.signMessage(message))["signature"];
              return signature;
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.K3(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
      }
    },
    6937: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        I: () => WalletModalProvider,
      });
      var react = __webpack_require__(3696),
        __webpack_exports__ = {
          setVisible(_open) {
            console.error(
              constructMissingProviderErrorMessage("call", "setVisible")
            );
          },
          visible: !1,
        };
      function constructMissingProviderErrorMessage(action, valueName) {
        return (
          "You have tried to " +
          ` ${action} "${valueName}"` +
          " on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext"
        );
      }
      Object.defineProperty(__webpack_exports__, "visible", {
        get() {
          return (
            console.error(
              constructMissingProviderErrorMessage("read", "visible")
            ),
            !1
          );
        },
      });
      const WalletModalContext = (0, react.createContext)(__webpack_exports__);
      var adapter = __webpack_require__(4045),
        useWallet = __webpack_require__(3712),
        react_dom = __webpack_require__(8325);
      const Collapse = ({ id, children, expanded = !1 }) => {
          const ref = (0, react.useRef)(null),
            instant = (0, react.useRef)(!0);
          return (
            (0, react.useLayoutEffect)(() => {
              if (expanded) {
                const node = ref.current;
                node &&
                  requestAnimationFrame(() => {
                    node.style.height = node.scrollHeight + "px";
                  });
              } else
                (() => {
                  const node = ref.current;
                  node &&
                    requestAnimationFrame(() => {
                      (node.style.height = node.offsetHeight + "px"),
                        (node.style.overflow = "hidden"),
                        requestAnimationFrame(() => {
                          node.style.height = "0";
                        });
                    });
                })();
            }, [expanded]),
            (0, react.useLayoutEffect)(() => {
              const node = ref.current;
              if (node)
                return (
                  instant.current && (handleComplete(), (instant.current = !1)),
                  node.addEventListener("transitionend", handleTransitionEnd),
                  () =>
                    node.removeEventListener(
                      "transitionend",
                      handleTransitionEnd
                    )
                );
              function handleComplete() {
                node &&
                  ((node.style.overflow = expanded ? "initial" : "hidden"),
                  expanded) &&
                  (node.style.height = "auto");
              }
              function handleTransitionEnd(event) {
                node &&
                  event.target === node &&
                  "height" === event.propertyName &&
                  handleComplete();
              }
            }, [expanded]),
            react.createElement(
              "div",
              {
                className: "wallet-adapter-collapse",
                id: id,
                ref: ref,
                role: "region",
                style: {
                  height: 0,
                  transition: instant.current
                    ? void 0
                    : "height 250ms ease-out",
                },
              },
              children
            )
          );
        },
        Button = (props) =>
          react.createElement(
            "button",
            {
              className: "wallet-adapter-button " + (props.className || ""),
              disabled: props.disabled,
              style: props.style,
              onClick: props.onClick,
              tabIndex: props.tabIndex || 0,
              type: "button",
            },
            props.startIcon &&
              react.createElement(
                "i",
                { className: "wallet-adapter-button-start-icon" },
                props.startIcon
              ),
            props.children,
            props.endIcon &&
              react.createElement(
                "i",
                { className: "wallet-adapter-button-end-icon" },
                props.endIcon
              )
          ),
        WalletIcon = ({ wallet, ...props }) =>
          wallet &&
          react.createElement("img", {
            src: wallet.adapter.icon,
            alt: wallet.adapter.name + " icon",
            ...props,
          }),
        WalletListItem = ({ handleClick, tabIndex, wallet }) =>
          react.createElement(
            "li",
            null,
            react.createElement(
              Button,
              {
                onClick: handleClick,
                startIcon: react.createElement(WalletIcon, { wallet: wallet }),
                tabIndex: tabIndex,
              },
              wallet.adapter.name,
              wallet.readyState === adapter.Ok.Installed &&
                react.createElement("span", null, "Detected")
            )
          ),
        WalletSVG = () =>
          react.createElement(
            "svg",
            {
              width: "97",
              height: "96",
              viewBox: "0 0 97 96",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
            },
            react.createElement("circle", {
              cx: "48.5",
              cy: "48",
              r: "48",
              fill: "url(#paint0_linear_880_5115)",
              fillOpacity: "0.1",
            }),
            react.createElement("circle", {
              cx: "48.5",
              cy: "48",
              r: "47",
              stroke: "url(#paint1_linear_880_5115)",
              strokeOpacity: "0.4",
              strokeWidth: "2",
            }),
            react.createElement(
              "g",
              { clipPath: "url(#clip0_880_5115)" },
              react.createElement("path", {
                d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
                fill: "url(#paint2_linear_880_5115)",
              }),
              react.createElement("path", {
                d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
                fill: "url(#paint3_linear_880_5115)",
              })
            ),
            react.createElement(
              "defs",
              null,
              react.createElement(
                "linearGradient",
                {
                  id: "paint0_linear_880_5115",
                  x1: "3.41664",
                  y1: "98.0933",
                  x2: "103.05",
                  y2: "8.42498",
                  gradientUnits: "userSpaceOnUse",
                },
                react.createElement("stop", { stopColor: "#9945FF" }),
                react.createElement("stop", {
                  offset: "0.14",
                  stopColor: "#8A53F4",
                }),
                react.createElement("stop", {
                  offset: "0.42",
                  stopColor: "#6377D6",
                }),
                react.createElement("stop", {
                  offset: "0.79",
                  stopColor: "#24B0A7",
                }),
                react.createElement("stop", {
                  offset: "0.99",
                  stopColor: "#00D18C",
                }),
                react.createElement("stop", {
                  offset: "1",
                  stopColor: "#00D18C",
                })
              ),
              react.createElement(
                "linearGradient",
                {
                  id: "paint1_linear_880_5115",
                  x1: "3.41664",
                  y1: "98.0933",
                  x2: "103.05",
                  y2: "8.42498",
                  gradientUnits: "userSpaceOnUse",
                },
                react.createElement("stop", { stopColor: "#9945FF" }),
                react.createElement("stop", {
                  offset: "0.14",
                  stopColor: "#8A53F4",
                }),
                react.createElement("stop", {
                  offset: "0.42",
                  stopColor: "#6377D6",
                }),
                react.createElement("stop", {
                  offset: "0.79",
                  stopColor: "#24B0A7",
                }),
                react.createElement("stop", {
                  offset: "0.99",
                  stopColor: "#00D18C",
                }),
                react.createElement("stop", {
                  offset: "1",
                  stopColor: "#00D18C",
                })
              ),
              react.createElement(
                "linearGradient",
                {
                  id: "paint2_linear_880_5115",
                  x1: "25.9583",
                  y1: "68.7101",
                  x2: "67.2337",
                  y2: "23.7879",
                  gradientUnits: "userSpaceOnUse",
                },
                react.createElement("stop", { stopColor: "#9945FF" }),
                react.createElement("stop", {
                  offset: "0.14",
                  stopColor: "#8A53F4",
                }),
                react.createElement("stop", {
                  offset: "0.42",
                  stopColor: "#6377D6",
                }),
                react.createElement("stop", {
                  offset: "0.79",
                  stopColor: "#24B0A7",
                }),
                react.createElement("stop", {
                  offset: "0.99",
                  stopColor: "#00D18C",
                }),
                react.createElement("stop", {
                  offset: "1",
                  stopColor: "#00D18C",
                })
              ),
              react.createElement(
                "linearGradient",
                {
                  id: "paint3_linear_880_5115",
                  x1: "58.3326",
                  y1: "49.4467",
                  x2: "61.0002",
                  y2: "45.4453",
                  gradientUnits: "userSpaceOnUse",
                },
                react.createElement("stop", { stopColor: "#9945FF" }),
                react.createElement("stop", {
                  offset: "0.14",
                  stopColor: "#8A53F4",
                }),
                react.createElement("stop", {
                  offset: "0.42",
                  stopColor: "#6377D6",
                }),
                react.createElement("stop", {
                  offset: "0.79",
                  stopColor: "#24B0A7",
                }),
                react.createElement("stop", {
                  offset: "0.99",
                  stopColor: "#00D18C",
                }),
                react.createElement("stop", {
                  offset: "1",
                  stopColor: "#00D18C",
                })
              ),
              react.createElement(
                "clipPath",
                { id: "clip0_880_5115" },
                react.createElement("rect", {
                  width: "48",
                  height: "48",
                  fill: "white",
                  transform: "translate(24.5 24)",
                })
              )
            )
          ),
        WalletModal = ({ className = "", container = "body" }) => {
          const ref = (0, react.useRef)(null),
            { wallets, select } = (0, useWallet.v)(),
            setVisible = (function useWalletModal() {
              return (0, react.useContext)(WalletModalContext);
            })()["setVisible"],
            [expanded, setExpanded] = (0, react.useState)(!1),
            [fadeIn, setFadeIn] = (0, react.useState)(!1),
            [portal, setPortal] = (0, react.useState)(null);
          var [listedWallets, collapsedWallets] = (0, react.useMemo)(() => {
            var installed = [],
              notInstalled = [];
            for (const wallet of wallets)
              (wallet.readyState === adapter.Ok.Installed
                ? installed
                : notInstalled
              ).push(wallet);
            return installed.length
              ? [installed, notInstalled]
              : [notInstalled, []];
          }, [wallets]);
          const hideModal = (0, react.useCallback)(() => {
              setFadeIn(!1), setTimeout(() => setVisible(!1), 150);
            }, [setVisible]),
            handleClose = (0, react.useCallback)(
              (event) => {
                event.preventDefault(), hideModal();
              },
              [hideModal]
            ),
            handleWalletClick = (0, react.useCallback)(
              (event, walletName) => {
                select(walletName), handleClose(event);
              },
              [select, handleClose]
            );
          var handleCollapseClick = (0, react.useCallback)(
            () => setExpanded(!expanded),
            [expanded]
          );
          const handleTabKey = (0, react.useCallback)(
            (event) => {
              var firstElement,
                node = ref.current;
              node &&
                ((firstElement = (node = node.querySelectorAll("button"))[0]),
                (node = node[node.length - 1]),
                event.shiftKey
                  ? document.activeElement === firstElement &&
                    (node.focus(), event.preventDefault())
                  : document.activeElement === node &&
                    (firstElement.focus(), event.preventDefault()));
            },
            [ref]
          );
          return (
            (0, react.useLayoutEffect)(() => {
              const handleKeyDown = (event) => {
                  "Escape" === event.key
                    ? hideModal()
                    : "Tab" === event.key && handleTabKey(event);
                },
                overflow = window.getComputedStyle(document.body)["overflow"];
              return (
                setTimeout(() => setFadeIn(!0), 0),
                (document.body.style.overflow = "hidden"),
                window.addEventListener("keydown", handleKeyDown, !1),
                () => {
                  (document.body.style.overflow = overflow),
                    window.removeEventListener("keydown", handleKeyDown, !1);
                }
              );
            }, [hideModal, handleTabKey]),
            (0, react.useLayoutEffect)(
              () => setPortal(document.querySelector(container)),
              [container]
            ),
            portal &&
              (0, react_dom.createPortal)(
                react.createElement(
                  "div",
                  {
                    "aria-labelledby": "wallet-adapter-modal-title",
                    "aria-modal": "true",
                    className:
                      `wallet-adapter-modal ${
                        fadeIn && "wallet-adapter-modal-fade-in"
                      } ` + className,
                    ref: ref,
                    role: "dialog",
                  },
                  react.createElement(
                    "div",
                    { className: "wallet-adapter-modal-container" },
                    react.createElement(
                      "div",
                      { className: "wallet-adapter-modal-wrapper" },
                      react.createElement(
                        "button",
                        {
                          onClick: handleClose,
                          className: "wallet-adapter-modal-button-close",
                        },
                        react.createElement(
                          "svg",
                          { width: "14", height: "14" },
                          react.createElement("path", {
                            d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z",
                          })
                        )
                      ),
                      listedWallets.length
                        ? react.createElement(
                            react.Fragment,
                            null,
                            react.createElement(
                              "h1",
                              { className: "wallet-adapter-modal-title" },
                              "Connect a wallet on Solana to continue"
                            ),
                            react.createElement(
                              "ul",
                              { className: "wallet-adapter-modal-list" },
                              listedWallets.map((wallet) =>
                                react.createElement(WalletListItem, {
                                  key: wallet.adapter.name,
                                  handleClick: (event) =>
                                    handleWalletClick(
                                      event,
                                      wallet.adapter.name
                                    ),
                                  wallet: wallet,
                                })
                              ),
                              collapsedWallets.length
                                ? react.createElement(
                                    Collapse,
                                    {
                                      expanded: expanded,
                                      id: "wallet-adapter-modal-collapse",
                                    },
                                    collapsedWallets.map((wallet) =>
                                      react.createElement(WalletListItem, {
                                        key: wallet.adapter.name,
                                        handleClick: (event) =>
                                          handleWalletClick(
                                            event,
                                            wallet.adapter.name
                                          ),
                                        tabIndex: expanded ? 0 : -1,
                                        wallet: wallet,
                                      })
                                    )
                                  )
                                : null
                            ),
                            collapsedWallets.length
                              ? react.createElement(
                                  "button",
                                  {
                                    className: "wallet-adapter-modal-list-more",
                                    onClick: handleCollapseClick,
                                    tabIndex: 0,
                                  },
                                  react.createElement(
                                    "span",
                                    null,
                                    expanded ? "Less " : "More ",
                                    "options"
                                  ),
                                  react.createElement(
                                    "svg",
                                    {
                                      width: "13",
                                      height: "7",
                                      viewBox: "0 0 13 7",
                                      xmlns: "http://www.w3.org/2000/svg",
                                      className: expanded
                                        ? "wallet-adapter-modal-list-more-icon-rotate"
                                        : "",
                                    },
                                    react.createElement("path", {
                                      d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z",
                                    })
                                  )
                                )
                              : null
                          )
                        : react.createElement(
                            react.Fragment,
                            null,
                            react.createElement(
                              "h1",
                              { className: "wallet-adapter-modal-title" },
                              "You'll need a wallet on Solana to continue"
                            ),
                            react.createElement(
                              "div",
                              { className: "wallet-adapter-modal-middle" },
                              react.createElement(WalletSVG, null)
                            ),
                            collapsedWallets.length
                              ? react.createElement(
                                  react.Fragment,
                                  null,
                                  react.createElement(
                                    "button",
                                    {
                                      className:
                                        "wallet-adapter-modal-list-more",
                                      onClick: handleCollapseClick,
                                      tabIndex: 0,
                                    },
                                    react.createElement(
                                      "span",
                                      null,
                                      expanded
                                        ? "Hide "
                                        : "Already have a wallet? View ",
                                      "options"
                                    ),
                                    react.createElement(
                                      "svg",
                                      {
                                        width: "13",
                                        height: "7",
                                        viewBox: "0 0 13 7",
                                        xmlns: "http://www.w3.org/2000/svg",
                                        className: expanded
                                          ? "wallet-adapter-modal-list-more-icon-rotate"
                                          : "",
                                      },
                                      react.createElement("path", {
                                        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z",
                                      })
                                    )
                                  ),
                                  react.createElement(
                                    Collapse,
                                    {
                                      expanded: expanded,
                                      id: "wallet-adapter-modal-collapse",
                                    },
                                    react.createElement(
                                      "ul",
                                      {
                                        className: "wallet-adapter-modal-list",
                                      },
                                      collapsedWallets.map((wallet) =>
                                        react.createElement(WalletListItem, {
                                          key: wallet.adapter.name,
                                          handleClick: (event) =>
                                            handleWalletClick(
                                              event,
                                              wallet.adapter.name
                                            ),
                                          tabIndex: expanded ? 0 : -1,
                                          wallet: wallet,
                                        })
                                      )
                                    )
                                  )
                                )
                              : null
                          )
                    )
                  ),
                  react.createElement("div", {
                    className: "wallet-adapter-modal-overlay",
                    onMouseDown: handleClose,
                  })
                ),
                portal
              )
          );
        },
        WalletModalProvider = ({ children, ...props }) => {
          var [visible, setVisible] = (0, react.useState)(!1);
          return react.createElement(
            WalletModalContext.Provider,
            { value: { visible: visible, setVisible: setVisible } },
            children,
            visible && react.createElement(WalletModal, { ...props })
          );
        };
    },
    4909: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        S: () => ConnectionProvider,
      });
      var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(8769),
        react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3696),
        _useConnection_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(1089);
      const ConnectionProvider = ({
        children,
        endpoint,
        config = { commitment: "confirmed" },
      }) => {
        var connection = (0, react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
          () =>
            new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Ng(
              endpoint,
              config
            ),
          [endpoint, config]
        );
        return react__WEBPACK_IMPORTED_MODULE_1__.createElement(
          _useConnection_js__WEBPACK_IMPORTED_MODULE_2__.E.Provider,
          { value: { connection: connection } },
          children
        );
      };
    },
    6640: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        r: () =>
          function WalletProvider({
            children,
            wallets: adapters,
            autoConnect,
            localStorageKey = "walletName",
            onError,
          }) {
            const connection = (0, useConnection.w)()["connection"],
              adaptersWithStandardAdapters =
                (function useStandardWalletAdapters(adapters) {
                  const warnings = useConstant(() => new Set()),
                    { get, on } = useConstant(() =>
                      (function DEPRECATED_getWallets() {
                        if (
                          !wallets &&
                          ((wallets = getWallets()),
                          "undefined" != typeof window)
                        ) {
                          var callbacks = window.navigator.wallets || [];
                          if (Array.isArray(callbacks)) {
                            const register = wallets["register"];
                            var push = (...callbacks) =>
                              callbacks.forEach((callback) =>
                                wallets_guard(() =>
                                  callback({ register: register })
                                )
                              );
                            try {
                              Object.defineProperty(
                                window.navigator,
                                "wallets",
                                { value: Object.freeze({ push: push }) }
                              );
                            } catch (error) {
                              return (
                                console.error(
                                  "window.navigator.wallets could not be set"
                                ),
                                wallets
                              );
                            }
                            push(...callbacks);
                          } else
                            console.error(
                              "window.navigator.wallets is not an array"
                            );
                        }
                        return wallets;
                      })()
                    ),
                    [standardAdapters, setStandardAdapters] = (0,
                    react.useState)(() => wrapWalletsWithAdapters(get())),
                    prevStandardAdapters =
                      ((0, react.useEffect)(() => {
                        const listeners = [
                          on("register", (...wallets) =>
                            setStandardAdapters((standardAdapters) => [
                              ...standardAdapters,
                              ...wrapWalletsWithAdapters(wallets),
                            ])
                          ),
                          on("unregister", (...wallets) =>
                            setStandardAdapters((standardAdapters) =>
                              standardAdapters.filter((standardAdapter) =>
                                wallets.some(
                                  (wallet) => wallet === standardAdapter.wallet
                                )
                              )
                            )
                          ),
                        ];
                        return () => listeners.forEach((off) => off());
                      }, [on]),
                      (function usePrevious(state) {
                        const ref = (0, react.useRef)();
                        return (
                          (0, react.useEffect)(() => {
                            ref.current = state;
                          }),
                          ref.current
                        );
                      })(standardAdapters));
                  return (
                    (0, react.useEffect)(() => {
                      if (prevStandardAdapters) {
                        const currentAdapters = new Set(standardAdapters);
                        new Set(
                          prevStandardAdapters.filter(
                            (previousAdapter) =>
                              !currentAdapters.has(previousAdapter)
                          )
                        ).forEach((adapter) => adapter.destroy());
                      }
                    }, [prevStandardAdapters, standardAdapters]),
                    (0, react.useEffect)(
                      () => () =>
                        standardAdapters.forEach((adapter) =>
                          adapter.destroy()
                        ),
                      []
                    ),
                    (0, react.useMemo)(
                      () => [
                        ...standardAdapters,
                        ...adapters.filter(
                          ({ name }) =>
                            !standardAdapters.some(
                              (standardAdapter) => standardAdapter.name === name
                            ) ||
                            (warnings.has(name) ||
                              (warnings.add(name),
                              console.warn(
                                name +
                                  ` was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`
                              )),
                            !1)
                        ),
                      ],
                      [standardAdapters, adapters, warnings]
                    )
                  );
                })(adapters),
              mobileWalletAdapter = (0, react.useMemo)(() => {
                return getIsMobile(adaptersWithStandardAdapters)
                  ? adaptersWithStandardAdapters.find(
                      (adapter) =>
                        adapter.name === SolanaMobileWalletAdapterWalletName
                    ) ||
                      new SolanaMobileWalletAdapter({
                        addressSelector:
                          (function createDefaultAddressSelector() {
                            return {
                              select(addresses) {
                                return lib_esm_awaiter(
                                  this,
                                  void 0,
                                  void 0,
                                  function* () {
                                    return addresses[0];
                                  }
                                );
                              },
                            };
                          })(),
                        appIdentity: {
                          uri: (function getUriForAppIdentity() {
                            var location = globalThis.location;
                            if (location)
                              return location.protocol + "//" + location.host;
                          })(),
                        },
                        authorizationResultCache:
                          (function createDefaultAuthorizationResultCache() {
                            let storage;
                            try {
                              storage = window.localStorage;
                            } catch (_a) {}
                            return {
                              clear() {
                                return lib_esm_awaiter(
                                  this,
                                  void 0,
                                  void 0,
                                  function* () {
                                    if (storage)
                                      try {
                                        storage.removeItem(CACHE_KEY);
                                      } catch (_a) {}
                                  }
                                );
                              },
                              get() {
                                return lib_esm_awaiter(
                                  this,
                                  void 0,
                                  void 0,
                                  function* () {
                                    if (storage)
                                      try {
                                        return (
                                          JSON.parse(
                                            storage.getItem(CACHE_KEY)
                                          ) || void 0
                                        );
                                      } catch (_a) {}
                                  }
                                );
                              },
                              set(authorizationResult) {
                                return lib_esm_awaiter(
                                  this,
                                  void 0,
                                  void 0,
                                  function* () {
                                    if (storage)
                                      try {
                                        storage.setItem(
                                          CACHE_KEY,
                                          JSON.stringify(authorizationResult)
                                        );
                                      } catch (_a) {}
                                  }
                                );
                              },
                            };
                          })(),
                        cluster: (function getInferredClusterFromEndpoint(
                          endpoint
                        ) {
                          if (!endpoint) return "mainnet-beta";
                          return /devnet/i.test(endpoint)
                            ? "devnet"
                            : /testnet/i.test(endpoint)
                            ? "testnet"
                            : "mainnet-beta";
                        })(connection?.rpcEndpoint),
                        onWalletNotFound:
                          (function createDefaultWalletNotFoundHandler() {
                            return defaultWalletNotFoundHandler;
                          })(),
                      })
                  : null;
              }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]),
              adaptersWithMobileWalletAdapter = (0, react.useMemo)(
                () =>
                  null == mobileWalletAdapter ||
                  -1 !==
                    adaptersWithStandardAdapters.indexOf(mobileWalletAdapter)
                    ? adaptersWithStandardAdapters
                    : [mobileWalletAdapter, ...adaptersWithStandardAdapters],
                [adaptersWithStandardAdapters, mobileWalletAdapter]
              ),
              [walletName, setWalletName] = (function useLocalStorage(
                key,
                defaultState
              ) {
                const state = (0, react.useState)(() => {
                    try {
                      var value = localStorage.getItem(key);
                      if (value) return JSON.parse(value);
                    } catch (error) {
                      "undefined" != typeof window && console.error(error);
                    }
                    return defaultState;
                  }),
                  value = state[0],
                  isFirstRenderRef = (0, react.useRef)(!0);
                return (
                  (0, react.useEffect)(() => {
                    if (isFirstRenderRef.current) isFirstRenderRef.current = !1;
                    else
                      try {
                        null === value
                          ? localStorage.removeItem(key)
                          : localStorage.setItem(key, JSON.stringify(value));
                      } catch (error) {
                        "undefined" != typeof window && console.error(error);
                      }
                  }, [value, key]),
                  state
                );
              })(
                localStorageKey,
                getIsMobile(adaptersWithStandardAdapters)
                  ? SolanaMobileWalletAdapterWalletName
                  : null
              ),
              adapter = (0, react.useMemo)(
                () =>
                  adaptersWithMobileWalletAdapter.find(
                    (a) => a.name === walletName
                  ) ?? null,
                [adaptersWithMobileWalletAdapter, walletName]
              ),
              changeWallet = (0, react.useCallback)(
                (nextWalletName) => {
                  walletName !== nextWalletName &&
                    (adapter &&
                      adapter.name !== SolanaMobileWalletAdapterWalletName &&
                      adapter.disconnect(),
                    setWalletName(nextWalletName));
                },
                [adapter, setWalletName, walletName]
              ),
              hasUserSelectedAWallet =
                ((0, react.useEffect)(() => {
                  if (adapter)
                    return (
                      adapter.on("disconnect", handleDisconnect),
                      () => {
                        adapter.off("disconnect", handleDisconnect);
                      }
                    );
                  function handleDisconnect() {
                    isUnloadingRef.current ||
                      (walletName === SolanaMobileWalletAdapterWalletName &&
                        getIsMobile(adaptersWithStandardAdapters)) ||
                      setWalletName(null);
                  }
                }, [
                  adapter,
                  adaptersWithStandardAdapters,
                  setWalletName,
                  walletName,
                ]),
                (0, react.useRef)(!1)),
              handleAutoConnectRequest = (0, react.useMemo)(() => {
                if (autoConnect && adapter)
                  return async () => {
                    (!0 !== autoConnect && !(await autoConnect(adapter))) ||
                      (hasUserSelectedAWallet.current
                        ? await adapter.connect()
                        : await adapter.autoConnect());
                  };
              }, [autoConnect, adapter]),
              isUnloadingRef = (0, react.useRef)(!1),
              handleConnectError =
                ((0, react.useEffect)(() => {
                  if (
                    walletName !== SolanaMobileWalletAdapterWalletName ||
                    !getIsMobile(adaptersWithStandardAdapters)
                  )
                    return (
                      window.addEventListener(
                        "beforeunload",
                        handleBeforeUnload
                      ),
                      () => {
                        window.removeEventListener(
                          "beforeunload",
                          handleBeforeUnload
                        );
                      }
                    );
                  function handleBeforeUnload() {
                    isUnloadingRef.current = !0;
                  }
                  isUnloadingRef.current = !1;
                }, [adaptersWithStandardAdapters, walletName]),
                (0, react.useCallback)(() => {
                  adapter &&
                    adapter.name !== SolanaMobileWalletAdapterWalletName &&
                    changeWallet(null);
                }, [adapter, changeWallet])),
              selectWallet = (0, react.useCallback)(
                (walletName) => {
                  (hasUserSelectedAWallet.current = !0),
                    changeWallet(walletName);
                },
                [changeWallet]
              );
            return react.createElement(
              WalletProviderBase,
              {
                wallets: adaptersWithMobileWalletAdapter,
                adapter: adapter,
                isUnloadingRef: isUnloadingRef,
                onAutoConnectRequest: handleAutoConnectRequest,
                onConnectError: handleConnectError,
                onError: onError,
                onSelectWallet: selectWallet,
              },
              children
            );
          },
      });
      var __webpack_exports__ = __webpack_require__(1594),
        esm_adapter = __webpack_require__(4045),
        errors = __webpack_require__(2631),
        index_browser_esm = __webpack_require__(8769);
      new RegExp(
        "^(?<domain>[^\\n]+?) wants you to sign in with your Solana account:\\n(?<address>[^\\n]+)(?:\\n|$)(?:\\n(?<statement>[\\S\\s]*?)(?:\\n|$))??(?:\\nURI: (?<uri>[^\\n]+))?(?:\\nVersion: (?<version>[^\\n]+))?(?:\\nChain ID: (?<chainId>[^\\n]+))?(?:\\nNonce: (?<nonce>[^\\n]+))?(?:\\nIssued At: (?<issuedAt>[^\\n]+))?(?:\\nExpiration Time: (?<expirationTime>[^\\n]+))?(?:\\nNot Before: (?<notBefore>[^\\n]+))?(?:\\nRequest ID: (?<requestId>[^\\n]+))?(?:\\nResources:(?<resources>(?:\\n- [^\\n]+)*))?\\n*$"
      );
      function createSignInMessageText(input) {
        let message =
          input.domain +
          ` wants you to sign in with your Solana account:
`;
        (message += "" + input.address),
          input.statement &&
            (message +=
              `

` + input.statement);
        var fields = [];
        if (
          (input.uri && fields.push("URI: " + input.uri),
          input.version && fields.push("Version: " + input.version),
          input.chainId && fields.push("Chain ID: " + input.chainId),
          input.nonce && fields.push("Nonce: " + input.nonce),
          input.issuedAt && fields.push("Issued At: " + input.issuedAt),
          input.expirationTime &&
            fields.push("Expiration Time: " + input.expirationTime),
          input.notBefore && fields.push("Not Before: " + input.notBefore),
          input.requestId && fields.push("Request ID: " + input.requestId),
          input.resources)
        ) {
          fields.push("Resources:");
          for (const resource of input.resources) fields.push("- " + resource);
        }
        return (
          fields.length &&
            (message +=
              `

` + fields.join("\n")),
          message
        );
      }
      const SolanaMobileWalletAdapterErrorCode = {
        ERROR_ASSOCIATION_PORT_OUT_OF_RANGE:
          "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
        ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
        ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
        ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
        ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
        ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
        ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION",
      };
      class SolanaMobileWalletAdapterError extends Error {
        constructor(...args) {
          var [args, message, data] = args;
          super(message),
            (this.code = args),
            (this.data = data),
            (this.name = "SolanaMobileWalletAdapterError");
        }
      }
      class SolanaMobileWalletAdapterProtocolError extends Error {
        constructor(...args) {
          var [args, code, message, data] = args;
          super(message),
            (this.code = code),
            (this.data = data),
            (this.jsonRpcMessageId = args),
            (this.name = "SolanaMobileWalletAdapterProtocolError");
        }
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        return new (P = P || Promise)(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : (function adopt(value) {
                  return value instanceof P
                    ? value
                    : new P(function (resolve) {
                        resolve(value);
                      });
                })(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function createSIWSMessageBase64(payload) {
        return (function encode(input) {
          return window.btoa(input);
        })(createSignInMessageText(payload));
      }
      const SolanaSignTransactions = "solana:signTransactions",
        SolanaCloneAuthorization = "solana:cloneAuthorization";
      function createMobileWalletProxy(
        protocolVersion,
        protocolRequestHandler
      ) {
        return new Proxy(
          {},
          {
            get(target, p) {
              return (
                null == target[p] &&
                  (target[p] = function (inputParams) {
                    return __awaiter(this, void 0, void 0, function* () {
                      var { method, params } =
                          (function handleMobileWalletRequest(
                            methodName,
                            methodParams,
                            protocolVersion
                          ) {
                            let params = methodParams,
                              method = methodName
                                .toString()
                                .replace(
                                  /[A-Z]/g,
                                  (letter) => "_" + letter.toLowerCase()
                                )
                                .toLowerCase();
                            switch (methodName) {
                              case "authorize": {
                                let chain = params["chain"];
                                if ("legacy" === protocolVersion) {
                                  switch (chain) {
                                    case "solana:testnet":
                                      chain = "testnet";
                                      break;
                                    case "solana:devnet":
                                      chain = "devnet";
                                      break;
                                    case "solana:mainnet":
                                      chain = "mainnet-beta";
                                      break;
                                    default:
                                      chain = params.cluster;
                                  }
                                  params.cluster = chain;
                                } else {
                                  switch (chain) {
                                    case "testnet":
                                    case "devnet":
                                      chain = "solana:" + chain;
                                      break;
                                    case "mainnet-beta":
                                      chain = "solana:mainnet";
                                  }
                                  params.chain = chain;
                                }
                              }
                              case "reauthorize":
                                var { auth_token, identity } = params;
                                auth_token &&
                                  ("legacy" === protocolVersion
                                    ? ((method = "reauthorize"),
                                      (params = {
                                        auth_token: auth_token,
                                        identity: identity,
                                      }))
                                    : (method = "authorize"));
                            }
                            return { method: method, params: params };
                          })(p, inputParams, protocolVersion),
                        result = yield protocolRequestHandler(method, params);
                      return (
                        "authorize" === method &&
                          params.sign_in_payload &&
                          !result.sign_in_result &&
                          (result.sign_in_result =
                            yield (function signInFallback(
                              signInPayload,
                              authorizationResult,
                              protocolRequestHandler
                            ) {
                              var _a;
                              return __awaiter(
                                this,
                                void 0,
                                void 0,
                                function* () {
                                  var domain =
                                      null != (_a = signInPayload.domain)
                                        ? _a
                                        : window.location.host,
                                    address =
                                      authorizationResult.accounts[0].address,
                                    domain = createSIWSMessageBase64(
                                      Object.assign(
                                        Object.assign({}, signInPayload),
                                        { domain: domain, address: address }
                                      )
                                    );
                                  return {
                                    address: address,
                                    signed_message: domain,
                                    signature: (yield protocolRequestHandler(
                                      "sign_messages",
                                      {
                                        addresses: [address],
                                        payloads: [domain],
                                      }
                                    )).signed_payloads[0].slice(domain.length),
                                  };
                                }
                              );
                            })(
                              params.sign_in_payload,
                              result,
                              protocolRequestHandler
                            )),
                        (function handleMobileWalletResponse(
                          method,
                          response,
                          protocolVersion
                        ) {
                          if ("getCapabilities" === method) {
                            var capabilities = response;
                            switch (protocolVersion) {
                              case "legacy":
                                var features = [SolanaSignTransactions];
                                return (
                                  !0 ===
                                    capabilities.supports_clone_authorization &&
                                    features.push(SolanaCloneAuthorization),
                                  Object.assign(
                                    Object.assign({}, capabilities),
                                    { features: features }
                                  )
                                );
                              case "v1":
                                return Object.assign(
                                  Object.assign({}, capabilities),
                                  {
                                    supports_sign_and_send_transactions: !0,
                                    supports_clone_authorization:
                                      capabilities.features.includes(
                                        SolanaCloneAuthorization
                                      ),
                                  }
                                );
                            }
                          }
                          return response;
                        })(p, result, protocolVersion)
                      );
                    });
                  }),
                target[p]
              );
            },
            defineProperty() {
              return !1;
            },
            deleteProperty() {
              return !1;
            },
          }
        );
      }
      const SEQUENCE_NUMBER_BYTES = 4;
      const ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;
      function encryptMessage(plaintext, sequenceNumber, sharedSecret) {
        return __awaiter(this, void 0, void 0, function* () {
          var sequenceNumberVector = (function createSequenceNumberVector(
              sequenceNumber
            ) {
              if (4294967296 <= sequenceNumber)
                throw new Error(
                  "Outbound sequence number overflow. The maximum sequence number is 32-bytes."
                );
              var byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);
              return (
                new DataView(byteArray).setUint32(0, sequenceNumber, !1),
                new Uint8Array(byteArray)
              );
            })(sequenceNumber),
            initializationVector = new Uint8Array(12),
            ciphertext =
              (crypto.getRandomValues(initializationVector),
              yield crypto.subtle.encrypt(
                getAlgorithmParams(sequenceNumberVector, initializationVector),
                sharedSecret,
                new TextEncoder().encode(plaintext)
              )),
            response = new Uint8Array(
              sequenceNumberVector.byteLength +
                initializationVector.byteLength +
                ciphertext.byteLength
            );
          return (
            response.set(new Uint8Array(sequenceNumberVector), 0),
            response.set(
              new Uint8Array(initializationVector),
              sequenceNumberVector.byteLength
            ),
            response.set(
              new Uint8Array(ciphertext),
              sequenceNumberVector.byteLength + initializationVector.byteLength
            ),
            response
          );
        });
      }
      function decryptMessage(message, sharedSecret) {
        return __awaiter(this, void 0, void 0, function* () {
          var sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES),
            initializationVector = message.slice(
              SEQUENCE_NUMBER_BYTES,
              SEQUENCE_NUMBER_BYTES + 12
            ),
            ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + 12),
            sequenceNumberVector = yield crypto.subtle.decrypt(
              getAlgorithmParams(sequenceNumberVector, initializationVector),
              sharedSecret,
              ciphertext
            );
          return (function getUtf8Decoder() {
            void 0 === _utf8Decoder &&
              (_utf8Decoder = new TextDecoder("utf-8"));
            return _utf8Decoder;
          })().decode(sequenceNumberVector);
        });
      }
      function getAlgorithmParams(sequenceNumber, initializationVector) {
        return {
          additionalData: sequenceNumber,
          iv: initializationVector,
          name: "AES-GCM",
          tagLength: 128,
        };
      }
      let _utf8Decoder;
      function assertAssociationPort(port) {
        if (port < 49152 || 65535 < port)
          throw new SolanaMobileWalletAdapterError(
            SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,
            `Association port number must be between 49152 and 65535. ${port} given.`,
            { port: port }
          );
        return port;
      }
      function getPathParts(pathString) {
        return pathString.replace(/(^\/+|\/+$)/g, "").split("/");
      }
      function getAssociateAndroidIntentURL(
        associationPublicKey,
        putativePort,
        associationURLBase,
        protocolVersions = ["v1"]
      ) {
        return __awaiter(this, void 0, void 0, function* () {
          var associationPort = assertAssociationPort(putativePort),
            encodedKey = (function arrayBufferToBase64String(buffer) {
              let binary = "";
              var bytes = new Uint8Array(buffer),
                len = bytes.byteLength;
              for (let ii = 0; ii < len; ii++)
                binary += String.fromCharCode(bytes[ii]);
              return window.btoa(binary);
            })(yield crypto.subtle.exportKey("raw", associationPublicKey));
          const url = (function getIntentURL(methodPathname, intentUrlBase) {
            let baseUrl = null;
            if (intentUrlBase) {
              try {
                baseUrl = new URL(intentUrlBase);
              } catch (_a) {}
              if (
                "https:" !==
                (null === baseUrl || void 0 === baseUrl
                  ? void 0
                  : baseUrl.protocol)
              )
                throw new SolanaMobileWalletAdapterError(
                  SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,
                  "Base URLs supplied by wallets must be valid `https` URLs"
                );
            }
            return (
              (baseUrl = baseUrl || new URL("solana-wallet:/")),
              (intentUrlBase = methodPathname.startsWith("/")
                ? methodPathname
                : [
                    ...getPathParts(baseUrl.pathname),
                    ...getPathParts(methodPathname),
                  ].join("/")),
              new URL(intentUrlBase, baseUrl)
            );
          })("v1/associate/local", associationURLBase);
          return (
            url.searchParams.set(
              "association",
              (function getStringWithURLUnsafeCharactersReplaced(
                unsafeBase64EncodedString
              ) {
                return unsafeBase64EncodedString.replace(
                  /[/+=]/g,
                  (m) => ({ "/": "_", "+": "-", "=": "." }[m])
                );
              })(encodedKey)
            ),
            url.searchParams.set("port", "" + associationPort),
            protocolVersions.forEach((version) => {
              url.searchParams.set("v", version);
            }),
            url
          );
        });
      }
      const Browser = { Firefox: 0, Other: 1 };
      let _frame = null;
      function startSession(associationPublicKey, associationURLBase) {
        return __awaiter(this, void 0, void 0, function* () {
          var randomAssociationPort = (function getRandomAssociationPort() {
              return assertAssociationPort(
                49152 + Math.floor(16384 * Math.random())
              );
            })(),
            associationUrl = yield getAssociateAndroidIntentURL(
              associationPublicKey,
              randomAssociationPort,
              associationURLBase
            );
          if ("https:" === associationUrl.protocol)
            window.location.assign(associationUrl);
          else
            try {
              var browser = (function getBrowser() {
                return -1 !== navigator.userAgent.indexOf("Firefox/")
                  ? Browser.Firefox
                  : Browser.Other;
              })();
              switch (browser) {
                case Browser.Firefox:
                  !(function launchUrlThroughHiddenFrame(url) {
                    null == _frame &&
                      (((_frame =
                        document.createElement("iframe")).style.display =
                        "none"),
                      document.body.appendChild(_frame)),
                      (_frame.contentWindow.location.href = url.toString());
                  })(associationUrl);
                  break;
                case Browser.Other:
                  var detectionPromise = (function getDetectionPromise() {
                    return new Promise((resolve, reject) => {
                      function cleanup() {
                        clearTimeout(timeoutId),
                          window.removeEventListener("blur", handleBlur);
                      }
                      function handleBlur() {
                        cleanup(), resolve();
                      }
                      window.addEventListener("blur", handleBlur);
                      const timeoutId = setTimeout(() => {
                        cleanup(), reject();
                      }, 2e3);
                    });
                  })();
                  window.location.assign(associationUrl),
                    yield detectionPromise;
              }
            } catch (e) {
              throw new SolanaMobileWalletAdapterError(
                SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND,
                "Found no installed wallet that supports the mobile wallet protocol."
              );
            }
          return randomAssociationPort;
        });
      }
      const WEBSOCKET_CONNECTION_CONFIG = {
          retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
          timeoutMs: 3e4,
        },
        WEBSOCKET_PROTOCOL = "com.solana.mobilewalletadapter.v1";
      function getSequenceNumberFromByteArray(byteArray) {
        return new DataView(byteArray).getUint32(0, !1);
      }
      function transact(callback, config) {
        return __awaiter(this, void 0, void 0, function* () {
          !(function assertSecureContext() {
            if ("undefined" == typeof window || !0 !== window.isSecureContext)
              throw new SolanaMobileWalletAdapterError(
                SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED,
                "The mobile wallet adapter protocol must be used in a secure context (`https`)."
              );
          })();
          const associationKeypair =
              yield (function generateAssociationKeypair() {
                return __awaiter(this, void 0, void 0, function* () {
                  return yield crypto.subtle.generateKey(
                    { name: "ECDSA", namedCurve: "P-256" },
                    !1,
                    ["sign"]
                  );
                });
              })(),
            sessionPort = yield startSession(
              associationKeypair.publicKey,
              null == config ? void 0 : config.baseUri
            ),
            websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;
          let connectionStartTime;
          const getNextRetryDelayMs = (() => {
            const schedule = [
              ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs,
            ];
            return () => (1 < schedule.length ? schedule.shift() : schedule[0]);
          })();
          let nextJsonRpcMessageId = 1,
            lastKnownInboundSequenceNumber = 0,
            state = { __type: "disconnected" };
          return new Promise((resolve, reject) => {
            let socket;
            const jsonRpcResponsePromises = {},
              handleOpen = () =>
                __awaiter(this, void 0, void 0, function* () {
                  var associationKeypair, ecdhKeypair;
                  "connecting" !== state.__type
                    ? console.warn(
                        "Expected adapter state to be `connecting` at the moment the websocket opens. " +
                          `Got \`${state.__type}\`.`
                      )
                    : ((associationKeypair = state.associationKeypair),
                      socket.removeEventListener("open", handleOpen),
                      (ecdhKeypair = yield (function generateECDHKeypair() {
                        return __awaiter(this, void 0, void 0, function* () {
                          return yield crypto.subtle.generateKey(
                            { name: "ECDH", namedCurve: "P-256" },
                            !1,
                            ["deriveKey", "deriveBits"]
                          );
                        });
                      })()),
                      socket.send(
                        yield (function createHelloReq(
                          ecdhPublicKey,
                          associationKeypairPrivateKey
                        ) {
                          return __awaiter(this, void 0, void 0, function* () {
                            var publicKeyBuffer = yield crypto.subtle.exportKey(
                                "raw",
                                ecdhPublicKey
                              ),
                              signatureBuffer = yield crypto.subtle.sign(
                                { hash: "SHA-256", name: "ECDSA" },
                                associationKeypairPrivateKey,
                                publicKeyBuffer
                              ),
                              response = new Uint8Array(
                                publicKeyBuffer.byteLength +
                                  signatureBuffer.byteLength
                              );
                            return (
                              response.set(new Uint8Array(publicKeyBuffer), 0),
                              response.set(
                                new Uint8Array(signatureBuffer),
                                publicKeyBuffer.byteLength
                              ),
                              response
                            );
                          });
                        })(ecdhKeypair.publicKey, associationKeypair.privateKey)
                      ),
                      (state = {
                        __type: "hello_req_sent",
                        associationPublicKey: associationKeypair.publicKey,
                        ecdhPrivateKey: ecdhKeypair.privateKey,
                      }));
                }),
              handleClose = (evt) => {
                evt.wasClean
                  ? (state = { __type: "disconnected" })
                  : reject(
                      new SolanaMobileWalletAdapterError(
                        SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED,
                        `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`,
                        { closeEvent: evt }
                      )
                    ),
                  disposeSocket();
              },
              handleError = (_evt) =>
                __awaiter(this, void 0, void 0, function* () {
                  disposeSocket(),
                    Date.now() - connectionStartTime >=
                    WEBSOCKET_CONNECTION_CONFIG.timeoutMs
                      ? reject(
                          new SolanaMobileWalletAdapterError(
                            SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT,
                            `Failed to connect to the wallet websocket on port ${sessionPort}.`
                          )
                        )
                      : (yield new Promise((resolve) => {
                          var retryDelayMs = getNextRetryDelayMs();
                          retryWaitTimeoutId = window.setTimeout(
                            resolve,
                            retryDelayMs
                          );
                        }),
                        attemptSocketConnection());
                }),
              handleMessage = (evt) =>
                __awaiter(this, void 0, void 0, function* () {
                  var responseBuffer = yield evt.data.arrayBuffer();
                  switch (state.__type) {
                    case "connected":
                      try {
                        var sequenceNumber = getSequenceNumberFromByteArray(
                          responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES)
                        );
                        if (
                          sequenceNumber !==
                          lastKnownInboundSequenceNumber + 1
                        )
                          throw new Error(
                            "Encrypted message has invalid sequence number"
                          );
                        lastKnownInboundSequenceNumber = sequenceNumber;
                        var jsonRpcMessage =
                            yield (function decryptJsonRpcMessage(
                              message,
                              sharedSecret
                            ) {
                              return __awaiter(
                                this,
                                void 0,
                                void 0,
                                function* () {
                                  var plaintext = yield decryptMessage(
                                      message,
                                      sharedSecret
                                    ),
                                    plaintext = JSON.parse(plaintext);
                                  if (
                                    Object.hasOwnProperty.call(
                                      plaintext,
                                      "error"
                                    )
                                  )
                                    throw new SolanaMobileWalletAdapterProtocolError(
                                      plaintext.id,
                                      plaintext.error.code,
                                      plaintext.error.message
                                    );
                                  return plaintext;
                                }
                              );
                            })(responseBuffer, state.sharedSecret),
                          responsePromise =
                            jsonRpcResponsePromises[jsonRpcMessage.id];
                        delete jsonRpcResponsePromises[jsonRpcMessage.id],
                          responsePromise.resolve(jsonRpcMessage.result);
                      } catch (e) {
                        if (
                          !(e instanceof SolanaMobileWalletAdapterProtocolError)
                        )
                          throw e;
                        {
                          const responsePromise =
                            jsonRpcResponsePromises[e.jsonRpcMessageId];
                          delete jsonRpcResponsePromises[e.jsonRpcMessageId],
                            responsePromise.reject(e);
                        }
                      }
                      break;
                    case "hello_req_sent": {
                      const sharedSecret = yield (function parseHelloRsp(
                          payloadBuffer,
                          associationPublicKey,
                          ecdhPrivateKey
                        ) {
                          return __awaiter(this, void 0, void 0, function* () {
                            var [associationPublicKeyBuffer, walletPublicKey] =
                                yield Promise.all([
                                  crypto.subtle.exportKey(
                                    "raw",
                                    associationPublicKey
                                  ),
                                  crypto.subtle.importKey(
                                    "raw",
                                    payloadBuffer.slice(
                                      0,
                                      ENCODED_PUBLIC_KEY_LENGTH_BYTES
                                    ),
                                    { name: "ECDH", namedCurve: "P-256" },
                                    !1,
                                    []
                                  ),
                                ]),
                              walletPublicKey = yield crypto.subtle.deriveBits(
                                { name: "ECDH", public: walletPublicKey },
                                ecdhPrivateKey,
                                256
                              ),
                              walletPublicKey = yield crypto.subtle.importKey(
                                "raw",
                                walletPublicKey,
                                "HKDF",
                                !1,
                                ["deriveKey"]
                              );
                            return yield crypto.subtle.deriveKey(
                              {
                                name: "HKDF",
                                hash: "SHA-256",
                                salt: new Uint8Array(
                                  associationPublicKeyBuffer
                                ),
                                info: new Uint8Array(),
                              },
                              walletPublicKey,
                              { name: "AES-GCM", length: 128 },
                              !1,
                              ["encrypt", "decrypt"]
                            );
                          });
                        })(
                          responseBuffer,
                          state.associationPublicKey,
                          state.ecdhPrivateKey
                        ),
                        sessionPropertiesBuffer = responseBuffer.slice(
                          ENCODED_PUBLIC_KEY_LENGTH_BYTES
                        );
                      (sequenceNumber =
                        0 !== sessionPropertiesBuffer.byteLength
                          ? yield __awaiter(this, void 0, void 0, function* () {
                              var sequenceNumber =
                                getSequenceNumberFromByteArray(
                                  sessionPropertiesBuffer.slice(
                                    0,
                                    SEQUENCE_NUMBER_BYTES
                                  )
                                );
                              if (
                                sequenceNumber !==
                                lastKnownInboundSequenceNumber + 1
                              )
                                throw new Error(
                                  "Encrypted message has invalid sequence number"
                                );
                              return (
                                (lastKnownInboundSequenceNumber =
                                  sequenceNumber),
                                (function parseSessionProps(
                                  message,
                                  sharedSecret
                                ) {
                                  return __awaiter(
                                    this,
                                    void 0,
                                    void 0,
                                    function* () {
                                      var plaintext = yield decryptMessage(
                                          message,
                                          sharedSecret
                                        ),
                                        jsonProperties = JSON.parse(plaintext);
                                      let protocolVersion = "legacy";
                                      if (
                                        Object.hasOwnProperty.call(
                                          jsonProperties,
                                          "v"
                                        )
                                      )
                                        switch (jsonProperties.v) {
                                          case 1:
                                          case "1":
                                          case "v1":
                                            protocolVersion = "v1";
                                            break;
                                          case "legacy":
                                            protocolVersion = "legacy";
                                            break;
                                          default:
                                            throw new SolanaMobileWalletAdapterError(
                                              SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION,
                                              "Unknown/unsupported protocol version: " +
                                                jsonProperties.v
                                            );
                                        }
                                      return {
                                        protocol_version: protocolVersion,
                                      };
                                    }
                                  );
                                })(sessionPropertiesBuffer, sharedSecret)
                              );
                            })
                          : { protocol_version: "legacy" }),
                        (responsePromise =
                          ((state = {
                            __type: "connected",
                            sharedSecret: sharedSecret,
                            sessionProperties: sequenceNumber,
                          }),
                          createMobileWalletProxy(
                            sequenceNumber.protocol_version,
                            (method, params) =>
                              __awaiter(this, void 0, void 0, function* () {
                                const id = nextJsonRpcMessageId++;
                                return (
                                  socket.send(
                                    yield (function encryptJsonRpcMessage(
                                      jsonRpcMessage,
                                      sharedSecret
                                    ) {
                                      return __awaiter(
                                        this,
                                        void 0,
                                        void 0,
                                        function* () {
                                          return encryptMessage(
                                            JSON.stringify(jsonRpcMessage),
                                            jsonRpcMessage.id,
                                            sharedSecret
                                          );
                                        }
                                      );
                                    })(
                                      {
                                        id: id,
                                        jsonrpc: "2.0",
                                        method: method,
                                        params: null != params ? params : {},
                                      },
                                      sharedSecret
                                    )
                                  ),
                                  new Promise((resolve, reject) => {
                                    jsonRpcResponsePromises[id] = {
                                      resolve(result) {
                                        switch (method) {
                                          case "authorize":
                                          case "reauthorize":
                                            var wallet_uri_base =
                                              result["wallet_uri_base"];
                                            if (null != wallet_uri_base)
                                              try {
                                                !(function assertSecureEndpointSpecificURI(
                                                  walletUriBase
                                                ) {
                                                  let url;
                                                  try {
                                                    url = new URL(
                                                      walletUriBase
                                                    );
                                                  } catch (_a) {
                                                    throw new SolanaMobileWalletAdapterError(
                                                      SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,
                                                      "Invalid base URL supplied by wallet"
                                                    );
                                                  }
                                                  if ("https:" !== url.protocol)
                                                    throw new SolanaMobileWalletAdapterError(
                                                      SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,
                                                      "Base URLs supplied by wallets must be valid `https` URLs"
                                                    );
                                                })(wallet_uri_base);
                                              } catch (e) {
                                                return void reject(e);
                                              }
                                        }
                                        resolve(result);
                                      },
                                      reject: reject,
                                    };
                                  })
                                );
                              })
                          )));
                      try {
                        resolve(yield callback(responsePromise));
                      } catch (e) {
                        reject(e);
                      } finally {
                        disposeSocket(), socket.close();
                      }
                      break;
                    }
                  }
                });
            let disposeSocket, retryWaitTimeoutId;
            const attemptSocketConnection = () => {
              disposeSocket && disposeSocket(),
                (state = {
                  __type: "connecting",
                  associationKeypair: associationKeypair,
                }),
                void 0 === connectionStartTime &&
                  (connectionStartTime = Date.now()),
                (socket = new WebSocket(websocketURL, [
                  WEBSOCKET_PROTOCOL,
                ])).addEventListener("open", handleOpen),
                socket.addEventListener("close", handleClose),
                socket.addEventListener("error", handleError),
                socket.addEventListener("message", handleMessage),
                (disposeSocket = () => {
                  window.clearTimeout(retryWaitTimeoutId),
                    socket.removeEventListener("open", handleOpen),
                    socket.removeEventListener("close", handleClose),
                    socket.removeEventListener("error", handleError),
                    socket.removeEventListener("message", handleMessage);
                });
            };
            attemptSocketConnection();
          });
        });
      }
      var bs58 = __webpack_require__(463);
      function __rest(s, e) {
        var t = {};
        for (p in s)
          Object.prototype.hasOwnProperty.call(s, p) &&
            e.indexOf(p) < 0 &&
            (t[p] = s[p]);
        if (null != s && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var i = 0, p = Object.getOwnPropertySymbols(s);
            i < p.length;
            i++
          )
            e.indexOf(p[i]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(s, p[i]) &&
              (t[p[i]] = s[p[i]]);
        return t;
      }
      function esm_awaiter(thisArg, _arguments, P, generator) {
        return new (P = P || Promise)(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : (function adopt(value) {
                  return value instanceof P
                    ? value
                    : new P(function (resolve) {
                        resolve(value);
                      });
                })(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function fromUint8Array(byteArray) {
        return window.btoa(String.fromCharCode.call(null, ...byteArray));
      }
      function toUint8Array(base64EncodedByteArray) {
        return new Uint8Array(
          window
            .atob(base64EncodedByteArray)
            .split("")
            .map((c) => c.charCodeAt(0))
        );
      }
      function getPayloadFromTransaction(transaction) {
        return fromUint8Array(
          "version" in transaction
            ? transaction.serialize()
            : transaction.serialize({
                requireAllSignatures: !1,
                verifySignatures: !1,
              })
        );
      }
      function getTransactionFromWireMessage(byteArray) {
        var messageOffset = byteArray[0] * index_browser_esm.P3 + 1;
        return "legacy" ===
          index_browser_esm.B2.deserializeMessageVersion(
            byteArray.slice(messageOffset, byteArray.length)
          )
          ? index_browser_esm.ZX.from(byteArray)
          : index_browser_esm.Kt.deserialize(byteArray);
      }
      function lib_esm_awaiter(thisArg, _arguments, P, generator) {
        return new (P = P || Promise)(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : (function adopt(value) {
                  return value instanceof P
                    ? value
                    : new P(function (resolve) {
                        resolve(value);
                      });
                })(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function esm_toUint8Array(base64EncodedByteArray) {
        return new Uint8Array(
          window
            .atob(base64EncodedByteArray)
            .split("")
            .map((c) => c.charCodeAt(0))
        );
      }
      const SolanaMobileWalletAdapterWalletName = "Mobile Wallet Adapter";
      class SolanaMobileWalletAdapter extends __webpack_exports__.Xl {
        constructor(config) {
          var _a;
          super(),
            (this.supportedTransactionVersions = new Set(["legacy", 0])),
            (this.name = SolanaMobileWalletAdapterWalletName),
            (this.url = "https://solanamobile.com/wallets"),
            (this.icon =
              "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg=="),
            (this._connecting = !1),
            (this._connectionGeneration = 0),
            (this._readyState = (function getIsSupported() {
              return (
                "undefined" != typeof window &&
                window.isSecureContext &&
                "undefined" != typeof document &&
                /android/i.test(navigator.userAgent)
              );
            })()
              ? esm_adapter.Ok.Loadable
              : esm_adapter.Ok.Unsupported),
            (this._authorizationResultCache = config.authorizationResultCache),
            (this._addressSelector = config.addressSelector),
            (this._appIdentity = config.appIdentity),
            (this._chain = null != (_a = config.chain) ? _a : config.cluster),
            (this._onWalletNotFound = config.onWalletNotFound),
            this._readyState !== esm_adapter.Ok.Unsupported &&
              this._authorizationResultCache
                .get()
                .then((authorizationResult) => {
                  authorizationResult && this.declareWalletAsInstalled();
                });
        }
        get publicKey() {
          if (null == this._publicKey && null != this._selectedAddress)
            try {
              this._publicKey = (function getPublicKeyFromAddress(address) {
                return (
                  (address = esm_toUint8Array(address)),
                  new index_browser_esm.J3(address)
                );
              })(this._selectedAddress);
            } catch (e) {
              throw new errors.Kd(
                (e instanceof Error && (null == e ? void 0 : e.message)) ||
                  "Unknown error",
                e
              );
            }
          return this._publicKey || null;
        }
        get connected() {
          return !!this._authorizationResult;
        }
        get connecting() {
          return this._connecting;
        }
        get readyState() {
          return this._readyState;
        }
        declareWalletAsInstalled() {
          this._readyState !== esm_adapter.Ok.Installed &&
            this.emit(
              "readyStateChange",
              (this._readyState = esm_adapter.Ok.Installed)
            );
        }
        runWithGuard(callback) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            try {
              return yield callback();
            } catch (e) {
              throw (this.emit("error", e), e);
            }
          });
        }
        autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.autoConnect();
          });
        }
        autoConnect() {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            if (!this.connecting && !this.connected)
              return yield this.runWithGuard(() =>
                lib_esm_awaiter(this, void 0, void 0, function* () {
                  if (
                    this._readyState !== esm_adapter.Ok.Installed &&
                    this._readyState !== esm_adapter.Ok.Loadable
                  )
                    throw new errors.AE();
                  this._connecting = !0;
                  try {
                    var cachedAuthorizationResult =
                      yield this._authorizationResultCache.get();
                    cachedAuthorizationResult &&
                      this.handleAuthorizationResult(cachedAuthorizationResult);
                  } catch (e) {
                    throw new errors.Y6(
                      (e instanceof Error && e.message) || "Unknown error",
                      e
                    );
                  } finally {
                    this._connecting = !1;
                  }
                })
              );
          });
        }
        connect() {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            if (!this.connecting && !this.connected)
              return yield this.runWithGuard(() =>
                lib_esm_awaiter(this, void 0, void 0, function* () {
                  if (
                    this._readyState !== esm_adapter.Ok.Installed &&
                    this._readyState !== esm_adapter.Ok.Loadable
                  )
                    throw new errors.AE();
                  this._connecting = !0;
                  try {
                    yield this.performAuthorization();
                  } catch (e) {
                    throw new errors.Y6(
                      (e instanceof Error && e.message) || "Unknown error",
                      e
                    );
                  } finally {
                    this._connecting = !1;
                  }
                })
              );
          });
        }
        performAuthorization(signInPayload) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            try {
              var cachedAuthorizationResult =
                yield this._authorizationResultCache.get();
              return cachedAuthorizationResult
                ? (this.handleAuthorizationResult(cachedAuthorizationResult),
                  cachedAuthorizationResult)
                : yield this.transact((wallet) =>
                    lib_esm_awaiter(this, void 0, void 0, function* () {
                      var authorizationResult = yield wallet.authorize({
                        chain: this._chain,
                        identity: this._appIdentity,
                        sign_in_payload: signInPayload,
                      });
                      return (
                        Promise.all([
                          this._authorizationResultCache.set(
                            authorizationResult
                          ),
                          this.handleAuthorizationResult(authorizationResult),
                        ]),
                        authorizationResult
                      );
                    })
                  );
            } catch (e) {
              throw new errors.Y6(
                (e instanceof Error && e.message) || "Unknown error",
                e
              );
            }
          });
        }
        handleAuthorizationResult(authorizationResult) {
          var _a;
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            var didPublicKeysChange =
              null == this._authorizationResult ||
              (null == (_a = this._authorizationResult)
                ? void 0
                : _a.accounts.length) !== authorizationResult.accounts.length ||
              this._authorizationResult.accounts.some(
                (account, ii) =>
                  account.address !== authorizationResult.accounts[ii].address
              );
            (this._authorizationResult = authorizationResult),
              this.declareWalletAsInstalled(),
              didPublicKeysChange &&
                (didPublicKeysChange = yield this._addressSelector.select(
                  authorizationResult.accounts.map(({ address }) => address)
                )) !== this._selectedAddress &&
                ((this._selectedAddress = didPublicKeysChange),
                delete this._publicKey,
                this.emit("connect", this.publicKey));
          });
        }
        performReauthorization(wallet, authToken) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            try {
              var authorizationResult = yield wallet.authorize({
                auth_token: authToken,
                identity: this._appIdentity,
              });
              Promise.all([
                this._authorizationResultCache.set(authorizationResult),
                this.handleAuthorizationResult(authorizationResult),
              ]);
            } catch (e) {
              throw (
                (this.disconnect(),
                new errors.PQ(
                  (e instanceof Error && (null == e ? void 0 : e.message)) ||
                    "Unknown error",
                  e
                ))
              );
            }
          });
        }
        disconnect() {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._authorizationResultCache.clear(),
              (this._connecting = !1),
              this._connectionGeneration++,
              delete this._authorizationResult,
              delete this._publicKey,
              delete this._selectedAddress,
              this.emit("disconnect");
          });
        }
        transact(callback) {
          var _a;
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            var walletUriBase =
                null == (_a = this._authorizationResult)
                  ? void 0
                  : _a.wallet_uri_base,
              walletUriBase = walletUriBase
                ? { baseUri: walletUriBase }
                : void 0,
              currentConnectionGeneration = this._connectionGeneration;
            try {
              return yield (function esm_transact(callback, config) {
                return esm_awaiter(this, void 0, void 0, function* () {
                  return yield transact((wallet) => {
                    var augmentedAPI = new Proxy(
                      {},
                      {
                        get(target, p) {
                          if (null == target[p])
                            switch (p) {
                              case "signAndSendTransactions":
                                target[p] = function (_a) {
                                  var {
                                      minContextSlot,
                                      commitment,
                                      skipPreflight,
                                      maxRetries,
                                      waitForCommitmentToSendNextTransaction,
                                      transactions,
                                    } = _a,
                                    rest = __rest(_a, [
                                      "minContextSlot",
                                      "commitment",
                                      "skipPreflight",
                                      "maxRetries",
                                      "waitForCommitmentToSendNextTransaction",
                                      "transactions",
                                    ]);
                                  return esm_awaiter(
                                    this,
                                    void 0,
                                    void 0,
                                    function* () {
                                      var payloads = transactions.map(
                                          getPayloadFromTransaction
                                        ),
                                        options = {
                                          min_context_slot: minContextSlot,
                                          commitment: commitment,
                                          skip_preflight: skipPreflight,
                                          max_retries: maxRetries,
                                          wait_for_commitment_to_send_next_transaction:
                                            waitForCommitmentToSendNextTransaction,
                                        },
                                        options =
                                          (yield wallet.signAndSendTransactions(
                                            Object.assign(
                                              Object.assign(
                                                Object.assign({}, rest),
                                                Object.values(options).some(
                                                  (element) => null != element
                                                )
                                                  ? { options: options }
                                                  : null
                                              ),
                                              { payloads: payloads }
                                            )
                                          ))["signatures"];
                                      return options
                                        .map(toUint8Array)
                                        .map(bs58.encode);
                                    }
                                  );
                                };
                                break;
                              case "signMessages":
                                target[p] = function (_a) {
                                  var payloads = _a["payloads"],
                                    rest = __rest(_a, ["payloads"]);
                                  return esm_awaiter(
                                    this,
                                    void 0,
                                    void 0,
                                    function* () {
                                      var base64EncodedPayloads =
                                          payloads.map(fromUint8Array),
                                        base64EncodedPayloads =
                                          (yield wallet.signMessages(
                                            Object.assign(
                                              Object.assign({}, rest),
                                              {
                                                payloads: base64EncodedPayloads,
                                              }
                                            )
                                          ))["signed_payloads"];
                                      return base64EncodedPayloads.map(
                                        toUint8Array
                                      );
                                    }
                                  );
                                };
                                break;
                              case "signTransactions":
                                target[p] = function (_a) {
                                  var transactions = _a["transactions"],
                                    rest = __rest(_a, ["transactions"]);
                                  return esm_awaiter(
                                    this,
                                    void 0,
                                    void 0,
                                    function* () {
                                      var payloads = transactions.map(
                                          getPayloadFromTransaction
                                        ),
                                        payloads =
                                          (yield wallet.signTransactions(
                                            Object.assign(
                                              Object.assign({}, rest),
                                              { payloads: payloads }
                                            )
                                          ))["signed_payloads"];
                                      return payloads
                                        .map(toUint8Array)
                                        .map(getTransactionFromWireMessage);
                                    }
                                  );
                                };
                                break;
                              default:
                                target[p] = wallet[p];
                            }
                          return target[p];
                        },
                        defineProperty() {
                          return !1;
                        },
                        deleteProperty() {
                          return !1;
                        },
                      }
                    );
                    return callback(augmentedAPI);
                  }, config);
                });
              })(callback, walletUriBase);
            } catch (e) {
              throw (
                (this._connectionGeneration !== currentConnectionGeneration &&
                  (yield new Promise(() => {})),
                e instanceof Error &&
                  "SolanaMobileWalletAdapterError" === e.name &&
                  "ERROR_WALLET_NOT_FOUND" === e.code &&
                  (yield this._onWalletNotFound(this)),
                e)
              );
            }
          });
        }
        assertIsAuthorized() {
          if (this._authorizationResult && this._selectedAddress)
            return {
              authToken: this._authorizationResult.auth_token,
              selectedAddress: this._selectedAddress,
            };
          throw new errors.kW();
        }
        performSignTransactions(transactions) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            const authToken = this.assertIsAuthorized()["authToken"];
            try {
              return yield this.transact((wallet) =>
                lib_esm_awaiter(this, void 0, void 0, function* () {
                  return (
                    yield this.performReauthorization(wallet, authToken),
                    yield wallet.signTransactions({
                      transactions: transactions,
                    })
                  );
                })
              );
            } catch (error) {
              throw new errors.z4(
                null == error ? void 0 : error.message,
                error
              );
            }
          });
        }
        sendTransaction(transaction, connection, options) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() =>
              lib_esm_awaiter(this, void 0, void 0, function* () {
                const authToken = this.assertIsAuthorized()["authToken"],
                  minContextSlot =
                    null == options ? void 0 : options.minContextSlot;
                try {
                  return yield this.transact((wallet) =>
                    lib_esm_awaiter(this, void 0, void 0, function* () {
                      function getTargetCommitment() {
                        let targetCommitment;
                        switch (connection.commitment) {
                          case "confirmed":
                          case "finalized":
                          case "processed":
                            targetCommitment = connection.commitment;
                            break;
                          default:
                            targetCommitment = "finalized";
                        }
                        let targetPreflightCommitment;
                        switch (
                          null == options ? void 0 : options.preflightCommitment
                        ) {
                          case "confirmed":
                          case "finalized":
                          case "processed":
                            targetPreflightCommitment =
                              options.preflightCommitment;
                            break;
                          case void 0:
                            targetPreflightCommitment = targetCommitment;
                            break;
                          default:
                            targetPreflightCommitment = "finalized";
                        }
                        return ("finalized" === targetPreflightCommitment
                          ? 2
                          : "confirmed" === targetPreflightCommitment
                          ? 1
                          : 0) <
                          ("finalized" === targetCommitment
                            ? 2
                            : "confirmed" === targetCommitment
                            ? 1
                            : 0)
                          ? targetPreflightCommitment
                          : targetCommitment;
                      }
                      var [capabilities, , ,] = yield Promise.all([
                        wallet.getCapabilities(),
                        this.performReauthorization(wallet, authToken),
                        "version" in transaction
                          ? null
                          : lib_esm_awaiter(this, void 0, void 0, function* () {
                              var _a;
                              transaction.feePayer ||
                                (transaction.feePayer =
                                  null != (_a = this.publicKey) ? _a : void 0),
                                null == transaction.recentBlockhash &&
                                  ((_a = (yield connection.getLatestBlockhash({
                                    commitment: getTargetCommitment(),
                                  }))["blockhash"]),
                                  (transaction.recentBlockhash = _a));
                            }),
                      ]);
                      return capabilities.supports_sign_and_send_transactions
                        ? (yield wallet.signAndSendTransactions({
                            minContextSlot: minContextSlot,
                            transactions: [transaction],
                          }))[0]
                        : (([capabilities] = yield wallet.signTransactions({
                            transactions: [transaction],
                          })),
                          "version" in capabilities
                            ? yield connection.sendTransaction(capabilities)
                            : ((capabilities = capabilities.serialize()),
                              yield connection.sendRawTransaction(
                                capabilities,
                                Object.assign(Object.assign({}, options), {
                                  preflightCommitment: getTargetCommitment(),
                                })
                              )));
                    })
                  );
                } catch (error) {
                  throw new errors.UF(
                    null == error ? void 0 : error.message,
                    error
                  );
                }
              })
            );
          });
        }
        signTransaction(transaction) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() =>
              lib_esm_awaiter(this, void 0, void 0, function* () {
                var [signedTransaction] = yield this.performSignTransactions([
                  transaction,
                ]);
                return signedTransaction;
              })
            );
          });
        }
        signAllTransactions(transactions) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() =>
              lib_esm_awaiter(this, void 0, void 0, function* () {
                return yield this.performSignTransactions(transactions);
              })
            );
          });
        }
        signMessage(message) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() =>
              lib_esm_awaiter(this, void 0, void 0, function* () {
                const { authToken, selectedAddress } =
                  this.assertIsAuthorized();
                try {
                  return yield this.transact((wallet) =>
                    lib_esm_awaiter(this, void 0, void 0, function* () {
                      yield this.performReauthorization(wallet, authToken);
                      var [signedMessage] = yield wallet.signMessages({
                        addresses: [selectedAddress],
                        payloads: [message],
                      });
                      return signedMessage.slice(-64);
                    })
                  );
                } catch (error) {
                  throw new errors.K3(
                    null == error ? void 0 : error.message,
                    error
                  );
                }
              })
            );
          });
        }
        signIn(input) {
          return lib_esm_awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() =>
              lib_esm_awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (
                  this._readyState !== esm_adapter.Ok.Installed &&
                  this._readyState !== esm_adapter.Ok.Loadable
                )
                  throw new errors.AE();
                this._connecting = !0;
                try {
                  var authorizationResult = yield this.performAuthorization(
                    Object.assign(Object.assign({}, input), {
                      domain:
                        null != (_a = null == input ? void 0 : input.domain)
                          ? _a
                          : window.location.host,
                    })
                  );
                  if (!authorizationResult.sign_in_result)
                    throw new Error(
                      "Sign in failed, no sign in result returned by wallet"
                    );
                  const signedInAddress =
                    authorizationResult.sign_in_result.address;
                  return {
                    account: Object.assign(
                      Object.assign(
                        {},
                        null !=
                          (_b = authorizationResult.accounts.find(
                            (acc) => acc.address == signedInAddress
                          ))
                          ? _b
                          : { address: signedInAddress }
                      ),
                      { publicKey: esm_toUint8Array(signedInAddress) }
                    ),
                    signedMessage: esm_toUint8Array(
                      authorizationResult.sign_in_result.signed_message
                    ),
                    signature: esm_toUint8Array(
                      authorizationResult.sign_in_result.signature
                    ),
                  };
                } catch (e) {
                  throw new errors.Y6(
                    (e instanceof Error && e.message) || "Unknown error",
                    e
                  );
                } finally {
                  this._connecting = !1;
                }
              })
            );
          });
        }
      }
      const CACHE_KEY = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
      function defaultWalletNotFoundHandler(mobileWalletAdapter) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
          "undefined" != typeof window &&
            window.location.assign(mobileWalletAdapter.url);
        });
      }
      var signAndSendTransaction = __webpack_require__(8282),
        signTransaction = __webpack_require__(8448),
        connect = __webpack_require__(8585),
        events = __webpack_require__(4010);
      const isWalletAdapterCompatibleWallet =
        function isWalletAdapterCompatibleStandardWallet(wallet) {
          return (
            connect.u in wallet.features &&
            events.j in wallet.features &&
            (signAndSendTransaction.R in wallet.features ||
              signTransaction.q in wallet.features)
          );
        };
      var esm_transaction = __webpack_require__(7158),
        signMessage = __webpack_require__(6848);
      var esm = __webpack_require__(6265);
      const MAINNET_ENDPOINT = "https://api.mainnet-beta.solana.com";
      function getCommitment(commitment) {
        switch (commitment) {
          case "processed":
          case "confirmed":
          case "finalized":
          case void 0:
            return commitment;
          case "recent":
            return "processed";
          case "single":
          case "singleGossip":
            return "confirmed";
          case "max":
          case "root":
            return "finalized";
          default:
            return;
        }
      }
      var disconnect = __webpack_require__(4293);
      function util_arraysEqual(a, b) {
        if (a !== b) {
          var length = a.length;
          if (length !== b.length) return !1;
          for (let i = 0; i < length; i++) if (a[i] !== b[i]) return !1;
        }
        return !0;
      }
      new WeakMap(),
        new WeakMap(),
        new WeakMap(),
        new WeakMap(),
        new WeakMap(),
        new WeakMap();
      var adapter_classPrivateFieldSet = function (
          receiver,
          state,
          value,
          kind,
          f
        ) {
          if ("m" === kind)
            throw new TypeError("Private method is not writable");
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return (
              "a" === kind
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        },
        adapter_classPrivateFieldGet = function (receiver, state, kind, f) {
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return "m" === kind
              ? f
              : "a" === kind
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        };
      class StandardWalletAdapter extends esm_adapter.Ce {
        constructor({ wallet }) {
          super(),
            _StandardWalletAdapter_instances.add(this),
            _StandardWalletAdapter_account.set(this, void 0),
            _StandardWalletAdapter_publicKey.set(this, void 0),
            _StandardWalletAdapter_connecting.set(this, void 0),
            _StandardWalletAdapter_disconnecting.set(this, void 0),
            _StandardWalletAdapter_off.set(this, void 0),
            _StandardWalletAdapter_supportedTransactionVersions.set(
              this,
              void 0
            ),
            _StandardWalletAdapter_wallet.set(this, void 0),
            _StandardWalletAdapter_readyState.set(
              this,
              "undefined" == typeof window || "undefined" == typeof document
                ? esm_adapter.Ok.Unsupported
                : esm_adapter.Ok.Installed
            ),
            _StandardWalletAdapter_changed.set(this, (properties) => {
              var account;
              "accounts" in properties &&
                ((account = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).accounts[0]),
                adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_account,
                  "f"
                )) &&
                !adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_disconnecting,
                  "f"
                ) &&
                account !==
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_account,
                    "f"
                  ) &&
                (account
                  ? adapter_classPrivateFieldGet(
                      this,
                      _StandardWalletAdapter_instances,
                      "m",
                      _StandardWalletAdapter_connected
                    ).call(this, account)
                  : (this.emit("error", new errors.PQ()),
                    adapter_classPrivateFieldGet(
                      this,
                      _StandardWalletAdapter_instances,
                      "m",
                      _StandardWalletAdapter_disconnected
                    ).call(this))),
                "features" in properties &&
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_instances,
                    "m",
                    _StandardWalletAdapter_reset
                  ).call(this);
            }),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_wallet,
              wallet,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_account,
              null,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_publicKey,
              null,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_connecting,
              !1,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_disconnecting,
              !1,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_off,
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_wallet,
                "f"
              ).features[events.j].on(
                "change",
                adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_changed,
                  "f"
                )
              ),
              "f"
            ),
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_instances,
              "m",
              _StandardWalletAdapter_reset
            ).call(this);
        }
        get name() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_wallet,
            "f"
          ).name;
        }
        get url() {
          return "https://github.com/solana-labs/wallet-standard";
        }
        get icon() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_wallet,
            "f"
          ).icon;
        }
        get readyState() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_readyState,
            "f"
          );
        }
        get publicKey() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_publicKey,
            "f"
          );
        }
        get connecting() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_connecting,
            "f"
          );
        }
        get supportedTransactionVersions() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_supportedTransactionVersions,
            "f"
          );
        }
        get wallet() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_wallet,
            "f"
          );
        }
        get standard() {
          return !0;
        }
        destroy() {
          adapter_classPrivateFieldSet(
            this,
            _StandardWalletAdapter_account,
            null,
            "f"
          ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_publicKey,
              null,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_connecting,
              !1,
              "f"
            ),
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_disconnecting,
              !1,
              "f"
            );
          var off = adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_off,
            "f"
          );
          off &&
            (adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_off,
              null,
              "f"
            ),
            off());
        }
        async autoConnect() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_instances,
            "m",
            _StandardWalletAdapter_connect
          ).call(this, { silent: !0 });
        }
        async connect() {
          return adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_instances,
            "m",
            _StandardWalletAdapter_connect
          ).call(this);
        }
        async disconnect() {
          if (
            disconnect.w in
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_wallet,
              "f"
            ).features
          )
            try {
              adapter_classPrivateFieldSet(
                this,
                _StandardWalletAdapter_disconnecting,
                !0,
                "f"
              ),
                await adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features[disconnect.w].disconnect();
            } catch (error) {
              this.emit("error", new errors.Y8(error?.message, error));
            } finally {
              adapter_classPrivateFieldSet(
                this,
                _StandardWalletAdapter_disconnecting,
                !1,
                "f"
              );
            }
          adapter_classPrivateFieldGet(
            this,
            _StandardWalletAdapter_instances,
            "m",
            _StandardWalletAdapter_disconnected
          ).call(this);
        }
        async sendTransaction(transaction, connection, options = {}) {
          try {
            var account = adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_account,
              "f"
            );
            if (!account) throw new errors.kW();
            let feature;
            if (
              signAndSendTransaction.R in
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_wallet,
                "f"
              ).features
            )
              if (account.features.includes(signAndSendTransaction.R))
                feature = signAndSendTransaction.R;
              else {
                if (
                  !(
                    signTransaction.q in
                      adapter_classPrivateFieldGet(
                        this,
                        _StandardWalletAdapter_wallet,
                        "f"
                      ).features && account.features.includes(signTransaction.q)
                  )
                )
                  throw new errors.fk();
                feature = signTransaction.q;
              }
            else {
              if (
                !(
                  signTransaction.q in
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features
                )
              )
                throw new errors.Ez();
              if (!account.features.includes(signTransaction.q))
                throw new errors.fk();
              feature = signTransaction.q;
            }
            var output,
              chain = (function getChainForEndpoint(endpoint) {
                return endpoint.includes(MAINNET_ENDPOINT)
                  ? esm.CE
                  : /\bdevnet\b/i.test(endpoint)
                  ? esm.sE
                  : /\btestnet\b/i.test(endpoint)
                  ? esm.re
                  : /\blocalhost\b/i.test(endpoint) ||
                    /\b127\.0\.0\.1\b/.test(endpoint)
                  ? esm.g4
                  : esm.CE;
              })(connection.rpcEndpoint);
            if (!account.chains.includes(chain)) throw new errors.UF();
            try {
              const { signers, ...sendOptions } = options;
              let serializedTransaction;
              if (
                ((serializedTransaction = (0, esm_transaction.Y)(transaction)
                  ? (signers?.length && transaction.sign(signers),
                    transaction.serialize())
                  : ((transaction = await this.prepareTransaction(
                      transaction,
                      connection,
                      sendOptions
                    )),
                    signers?.length && transaction.partialSign(...signers),
                    new Uint8Array(
                      transaction.serialize({
                        requireAllSignatures: !1,
                        verifySignatures: !1,
                      })
                    ))),
                feature === signAndSendTransaction.R)
              )
                return (
                  ([output] = await adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features[signAndSendTransaction.R].signAndSendTransaction({
                    account: account,
                    chain: chain,
                    transaction: serializedTransaction,
                    options: {
                      preflightCommitment: getCommitment(
                        sendOptions.preflightCommitment || connection.commitment
                      ),
                      skipPreflight: sendOptions.skipPreflight,
                      maxRetries: sendOptions.maxRetries,
                      minContextSlot: sendOptions.minContextSlot,
                    },
                  })),
                  bs58.encode(output.signature)
                );
              {
                const [output] = await adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features[signTransaction.q].signTransaction({
                  account: account,
                  chain: chain,
                  transaction: serializedTransaction,
                  options: {
                    preflightCommitment: getCommitment(
                      sendOptions.preflightCommitment || connection.commitment
                    ),
                    minContextSlot: sendOptions.minContextSlot,
                  },
                });
                return await connection.sendRawTransaction(
                  output.signedTransaction,
                  {
                    ...sendOptions,
                    preflightCommitment: getCommitment(
                      sendOptions.preflightCommitment || connection.commitment
                    ),
                  }
                );
              }
            } catch (error) {
              if (error instanceof errors.m7) throw error;
              throw new errors.UF(error?.message, error);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
      }
      var _StandardWalletAdapter_account = new WeakMap(),
        _StandardWalletAdapter_publicKey = new WeakMap(),
        _StandardWalletAdapter_connecting = new WeakMap(),
        _StandardWalletAdapter_disconnecting = new WeakMap(),
        _StandardWalletAdapter_off = new WeakMap(),
        _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(),
        _StandardWalletAdapter_wallet = new WeakMap(),
        _StandardWalletAdapter_readyState = new WeakMap(),
        _StandardWalletAdapter_changed = new WeakMap(),
        _StandardWalletAdapter_instances = new WeakSet(),
        _StandardWalletAdapter_connect =
          async function _StandardWalletAdapter_connect(input) {
            try {
              if (!this.connected && !this.connecting) {
                if (
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_readyState,
                    "f"
                  ) !== esm_adapter.Ok.Installed
                )
                  throw new errors.AE();
                if (
                  (adapter_classPrivateFieldSet(
                    this,
                    _StandardWalletAdapter_connecting,
                    !0,
                    "f"
                  ),
                  !adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).accounts.length)
                )
                  try {
                    await adapter_classPrivateFieldGet(
                      this,
                      _StandardWalletAdapter_wallet,
                      "f"
                    ).features[connect.u].connect(input);
                  } catch (error) {
                    throw new errors.Y6(error?.message, error);
                  }
                var account = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).accounts[0];
                if (!account) throw new errors.fk();
                adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_instances,
                  "m",
                  _StandardWalletAdapter_connected
                ).call(this, account);
              }
            } catch (error) {
              throw (this.emit("error", error), error);
            } finally {
              adapter_classPrivateFieldSet(
                this,
                _StandardWalletAdapter_connecting,
                !1,
                "f"
              );
            }
          },
        _StandardWalletAdapter_connected =
          function _StandardWalletAdapter_connected(account) {
            let publicKey;
            try {
              publicKey = new index_browser_esm.J3(account.address);
            } catch (error) {
              throw new errors.Kd(error?.message, error);
            }
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_account,
              account,
              "f"
            ),
              adapter_classPrivateFieldSet(
                this,
                _StandardWalletAdapter_publicKey,
                publicKey,
                "f"
              ),
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_instances,
                "m",
                _StandardWalletAdapter_reset
              ).call(this),
              this.emit("connect", publicKey);
          },
        _StandardWalletAdapter_disconnected =
          function _StandardWalletAdapter_disconnected() {
            adapter_classPrivateFieldSet(
              this,
              _StandardWalletAdapter_account,
              null,
              "f"
            ),
              adapter_classPrivateFieldSet(
                this,
                _StandardWalletAdapter_publicKey,
                null,
                "f"
              ),
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_instances,
                "m",
                _StandardWalletAdapter_reset
              ).call(this),
              this.emit("disconnect");
          },
        _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {
          var supportedTransactionVersions = (
            signAndSendTransaction.R in
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_wallet,
              "f"
            ).features
              ? adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features[signAndSendTransaction.R]
              : adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features[signTransaction.q]
          ).supportedTransactionVersions;
          adapter_classPrivateFieldSet(
            this,
            _StandardWalletAdapter_supportedTransactionVersions,
            util_arraysEqual(supportedTransactionVersions, ["legacy"])
              ? null
              : new Set(supportedTransactionVersions),
            "f"
          ),
            signTransaction.q in
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_wallet,
                "f"
              ).features &&
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_account,
              "f"
            )?.features.includes(signTransaction.q)
              ? ((this.signTransaction = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_instances,
                  "m",
                  _StandardWalletAdapter_signTransaction
                )),
                (this.signAllTransactions = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_instances,
                  "m",
                  _StandardWalletAdapter_signAllTransactions
                )))
              : (delete this.signTransaction, delete this.signAllTransactions),
            signMessage.F in
              adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_wallet,
                "f"
              ).features &&
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_account,
              "f"
            )?.features.includes(signMessage.F)
              ? (this.signMessage = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_instances,
                  "m",
                  _StandardWalletAdapter_signMessage
                ))
              : delete this.signMessage,
            "solana:signIn" in
            adapter_classPrivateFieldGet(
              this,
              _StandardWalletAdapter_wallet,
              "f"
            ).features
              ? (this.signIn = adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_instances,
                  "m",
                  _StandardWalletAdapter_signIn
                ))
              : delete this.signIn;
        },
        _StandardWalletAdapter_signTransaction =
          async function _StandardWalletAdapter_signTransaction(transaction) {
            try {
              var account = adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_account,
                "f"
              );
              if (!account) throw new errors.kW();
              if (
                !(
                  signTransaction.q in
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features
                )
              )
                throw new errors.Ez();
              if (!account.features.includes(signTransaction.q))
                throw new errors.fk();
              try {
                var serializedTransaction = (
                  await adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features[signTransaction.q].signTransaction({
                    account: account,
                    transaction: (0, esm_transaction.Y)(transaction)
                      ? transaction.serialize()
                      : new Uint8Array(
                          transaction.serialize({
                            requireAllSignatures: !1,
                            verifySignatures: !1,
                          })
                        ),
                  })
                )[0].signedTransaction;
                return (0, esm_transaction.Y)(transaction)
                  ? index_browser_esm.Kt.deserialize(serializedTransaction)
                  : index_browser_esm.ZX.from(serializedTransaction);
              } catch (error) {
                if (error instanceof errors.m7) throw error;
                throw new errors.z4(error?.message, error);
              }
            } catch (error) {
              throw (this.emit("error", error), error);
            }
          },
        _StandardWalletAdapter_signAllTransactions =
          async function _StandardWalletAdapter_signAllTransactions(
            transactions
          ) {
            try {
              const account = adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_account,
                "f"
              );
              if (!account) throw new errors.kW();
              if (
                !(
                  signTransaction.q in
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features
                )
              )
                throw new errors.Ez();
              if (!account.features.includes(signTransaction.q))
                throw new errors.fk();
              try {
                const signedTransactions = await adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features[signTransaction.q].signTransaction(
                  ...transactions.map((transaction) => ({
                    account: account,
                    transaction: (0, esm_transaction.Y)(transaction)
                      ? transaction.serialize()
                      : new Uint8Array(
                          transaction.serialize({
                            requireAllSignatures: !1,
                            verifySignatures: !1,
                          })
                        ),
                  }))
                );
                return transactions.map((transaction, index) => {
                  index = signedTransactions[index].signedTransaction;
                  return (0, esm_transaction.Y)(transaction)
                    ? index_browser_esm.Kt.deserialize(index)
                    : index_browser_esm.ZX.from(index);
                });
              } catch (error) {
                throw new errors.z4(error?.message, error);
              }
            } catch (error) {
              throw (this.emit("error", error), error);
            }
          },
        _StandardWalletAdapter_signMessage =
          async function _StandardWalletAdapter_signMessage(message) {
            try {
              var account = adapter_classPrivateFieldGet(
                this,
                _StandardWalletAdapter_account,
                "f"
              );
              if (!account) throw new errors.kW();
              if (
                !(
                  signMessage.F in
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features
                )
              )
                throw new errors.Ez();
              if (!account.features.includes(signMessage.F))
                throw new errors.fk();
              try {
                return (
                  await adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features[signMessage.F].signMessage({
                    account: account,
                    message: message,
                  })
                )[0].signature;
              } catch (error) {
                throw new errors.K3(error?.message, error);
              }
            } catch (error) {
              throw (this.emit("error", error), error);
            }
          },
        _StandardWalletAdapter_signIn =
          async function _StandardWalletAdapter_signIn(input = {}) {
            try {
              if (
                !(
                  "solana:signIn" in
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_wallet,
                    "f"
                  ).features
                )
              )
                throw new errors.Ez();
              let output;
              try {
                [output] = await adapter_classPrivateFieldGet(
                  this,
                  _StandardWalletAdapter_wallet,
                  "f"
                ).features["solana:signIn"].signIn(input);
              } catch (error) {
                throw new errors.o7(error?.message, error);
              }
              if (output)
                return (
                  adapter_classPrivateFieldGet(
                    this,
                    _StandardWalletAdapter_instances,
                    "m",
                    _StandardWalletAdapter_connected
                  ).call(this, output.account),
                  output
                );
              throw new errors.o7();
            } catch (error) {
              throw (this.emit("error", error), error);
            }
          },
        wallets_classPrivateFieldSet = function (
          receiver,
          state,
          value,
          kind,
          f
        ) {
          if ("m" === kind)
            throw new TypeError("Private method is not writable");
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return (
              "a" === kind
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        },
        wallets_classPrivateFieldGet = function (receiver, state, kind, f) {
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return "m" === kind
              ? f
              : "a" === kind
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        };
      let wallets = void 0;
      const registered = new Set(),
        listeners = {};
      function getWallets() {
        if (
          !wallets &&
          ((wallets = Object.freeze({ register: register, get: get, on: on })),
          "undefined" != typeof window)
        ) {
          const api = Object.freeze({ register: register });
          try {
            window.addEventListener(
              "wallet-standard:register-wallet",
              ({ detail: callback }) => callback(api)
            );
          } catch (error) {
            console.error(
              "wallet-standard:register-wallet event listener could not be added\n",
              error
            );
          }
          try {
            window.dispatchEvent(new AppReadyEvent(api));
          } catch (error) {
            console.error(
              "wallet-standard:app-ready event could not be dispatched\n",
              error
            );
          }
        }
        return wallets;
      }
      function register(...wallets) {
        return (wallets = wallets.filter((wallet) => !registered.has(wallet)))
          .length
          ? (wallets.forEach((wallet) => registered.add(wallet)),
            listeners.register?.forEach((listener) =>
              wallets_guard(() => listener(...wallets))
            ),
            function unregister() {
              wallets.forEach((wallet) => registered.delete(wallet)),
                listeners.unregister?.forEach((listener) =>
                  wallets_guard(() => listener(...wallets))
                );
            })
          : () => {};
      }
      function get() {
        return [...registered];
      }
      function on(event, listener) {
        return (
          listeners[event]?.push(listener) || (listeners[event] = [listener]),
          function off() {
            listeners[event] = listeners[event]?.filter(
              (existingListener) => listener !== existingListener
            );
          }
        );
      }
      function wallets_guard(callback) {
        try {
          callback();
        } catch (error) {
          console.error(error);
        }
      }
      class AppReadyEvent extends Event {
        constructor(api) {
          super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1,
          }),
            _AppReadyEvent_detail.set(this, void 0),
            wallets_classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
        }
        get detail() {
          return wallets_classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
        }
        get type() {
          return "wallet-standard:app-ready";
        }
        preventDefault() {
          throw new Error("preventDefault cannot be called");
        }
        stopImmediatePropagation() {
          throw new Error("stopImmediatePropagation cannot be called");
        }
        stopPropagation() {
          throw new Error("stopPropagation cannot be called");
        }
      }
      var Environment,
        _AppReadyEvent_detail = new WeakMap(),
        react = __webpack_require__(3696);
      function useConstant(fn) {
        var ref = (0, react.useRef)();
        return (
          ref.current || (ref.current = { value: fn() }), ref.current.value
        );
      }
      function wrapWalletsWithAdapters(wallets) {
        return wallets
          .filter(isWalletAdapterCompatibleWallet)
          .map((wallet) => new StandardWalletAdapter({ wallet: wallet }));
      }
      !(function (Environment) {
        (Environment[(Environment.DESKTOP_WEB = 0)] = "DESKTOP_WEB"),
          (Environment[(Environment.MOBILE_WEB = 1)] = "MOBILE_WEB");
      })((Environment = Environment || {}));
      var useConnection = __webpack_require__(1089);
      class WalletNotSelectedError extends errors.m7 {
        constructor() {
          super(...arguments), (this.name = "WalletNotSelectedError");
        }
      }
      var useWallet = __webpack_require__(3712);
      function WalletProviderBase({
        children,
        wallets: adapters,
        adapter,
        isUnloadingRef,
        onAutoConnectRequest,
        onConnectError,
        onError,
        onSelectWallet,
      }) {
        const isConnectingRef = (0, react.useRef)(!1),
          [connecting, setConnecting] = (0, react.useState)(!1),
          isDisconnectingRef = (0, react.useRef)(!1),
          [disconnecting, setDisconnecting] = (0, react.useState)(!1),
          [publicKey, setPublicKey] = (0, react.useState)(
            () => adapter?.publicKey ?? null
          ),
          [connected, setConnected] = (0, react.useState)(
            () => adapter?.connected ?? !1
          ),
          onErrorRef = (0, react.useRef)(onError),
          handleErrorRef =
            ((0, react.useEffect)(
              () => (
                (onErrorRef.current = onError),
                () => {
                  onErrorRef.current = void 0;
                }
              ),
              [onError]
            ),
            (0, react.useRef)(
              (error, adapter) => (
                isUnloadingRef.current ||
                  (onErrorRef.current
                    ? onErrorRef.current(error, adapter)
                    : (console.error(error, adapter),
                      error instanceof errors.AE &&
                        "undefined" != typeof window &&
                        adapter &&
                        window.open(adapter.url, "_blank"))),
                error
              )
            )),
          [wallets, setWallets] = (0, react.useState)(() =>
            adapters
              .map((adapter) => ({
                adapter: adapter,
                readyState: adapter.readyState,
              }))
              .filter(
                ({ readyState }) => readyState !== esm_adapter.Ok.Unsupported
              )
          ),
          wallet =
            ((0, react.useEffect)(() => {
              function handleReadyStateChange(readyState) {
                setWallets((prevWallets) => {
                  var adapter,
                    index = prevWallets.findIndex(
                      ({ adapter }) => adapter === this
                    );
                  return -1 === index
                    ? prevWallets
                    : ((adapter = prevWallets[index]["adapter"]),
                      [
                        ...prevWallets.slice(0, index),
                        { adapter: adapter, readyState: readyState },
                        ...prevWallets.slice(index + 1),
                      ].filter(
                        ({ readyState }) =>
                          readyState !== esm_adapter.Ok.Unsupported
                      ));
                });
              }
              return (
                setWallets((wallets) =>
                  adapters
                    .map((adapter, index) => {
                      index = wallets[index];
                      return index &&
                        index.adapter === adapter &&
                        index.readyState === adapter.readyState
                        ? index
                        : { adapter: adapter, readyState: adapter.readyState };
                    })
                    .filter(
                      ({ readyState }) =>
                        readyState !== esm_adapter.Ok.Unsupported
                    )
                ),
                adapters.forEach((adapter) =>
                  adapter.on(
                    "readyStateChange",
                    handleReadyStateChange,
                    adapter
                  )
                ),
                () => {
                  adapters.forEach((adapter) =>
                    adapter.off(
                      "readyStateChange",
                      handleReadyStateChange,
                      adapter
                    )
                  );
                }
              );
            }, [adapter, adapters]),
            (0, react.useMemo)(
              () =>
                wallets.find((wallet) => wallet.adapter === adapter) ?? null,
              [adapter, wallets]
            )),
          didAttemptAutoConnectRef =
            ((0, react.useEffect)(() => {
              if (adapter) {
                const handleConnect = (publicKey) => {
                    setPublicKey(publicKey),
                      (isConnectingRef.current = !1),
                      setConnecting(!1),
                      setConnected(!0),
                      (isDisconnectingRef.current = !1),
                      setDisconnecting(!1);
                  },
                  handleDisconnect = () => {
                    isUnloadingRef.current ||
                      (setPublicKey(null),
                      (isConnectingRef.current = !1),
                      setConnecting(!1),
                      setConnected(!1),
                      (isDisconnectingRef.current = !1),
                      setDisconnecting(!1));
                  },
                  handleError = (error) => {
                    handleErrorRef.current(error, adapter);
                  };
                return (
                  adapter.on("connect", handleConnect),
                  adapter.on("disconnect", handleDisconnect),
                  adapter.on("error", handleError),
                  () => {
                    adapter.off("connect", handleConnect),
                      adapter.off("disconnect", handleDisconnect),
                      adapter.off("error", handleError),
                      handleDisconnect();
                  }
                );
              }
            }, [adapter, isUnloadingRef]),
            (0, react.useRef)(!1));
        (0, react.useEffect)(
          () => () => {
            didAttemptAutoConnectRef.current = !1;
          },
          [adapter]
        ),
          (0, react.useEffect)(() => {
            didAttemptAutoConnectRef.current ||
              isConnectingRef.current ||
              connected ||
              !onAutoConnectRequest ||
              (wallet?.readyState !== esm_adapter.Ok.Installed &&
                wallet?.readyState !== esm_adapter.Ok.Loadable) ||
              ((isConnectingRef.current = !0),
              setConnecting(!0),
              (didAttemptAutoConnectRef.current = !0),
              (async function () {
                try {
                  await onAutoConnectRequest();
                } catch {
                  onConnectError();
                } finally {
                  setConnecting(!1), (isConnectingRef.current = !1);
                }
              })());
          }, [connected, onAutoConnectRequest, onConnectError, wallet]);
        var sendTransaction = (0, react.useCallback)(
            async (transaction, connection, options) => {
              if (!adapter)
                throw handleErrorRef.current(new WalletNotSelectedError());
              if (connected)
                return adapter.sendTransaction(
                  transaction,
                  connection,
                  options
                );
              throw handleErrorRef.current(new errors.kW(), adapter);
            },
            [adapter, connected]
          ),
          signTransaction = (0, react.useMemo)(
            () =>
              adapter && "signTransaction" in adapter
                ? async (transaction) => {
                    if (connected) return adapter.signTransaction(transaction);
                    throw handleErrorRef.current(new errors.kW(), adapter);
                  }
                : void 0,
            [adapter, connected]
          ),
          signAllTransactions = (0, react.useMemo)(
            () =>
              adapter && "signAllTransactions" in adapter
                ? async (transactions) => {
                    if (connected)
                      return adapter.signAllTransactions(transactions);
                    throw handleErrorRef.current(new errors.kW(), adapter);
                  }
                : void 0,
            [adapter, connected]
          ),
          signMessage = (0, react.useMemo)(
            () =>
              adapter && "signMessage" in adapter
                ? async (message) => {
                    if (connected) return adapter.signMessage(message);
                    throw handleErrorRef.current(new errors.kW(), adapter);
                  }
                : void 0,
            [adapter, connected]
          ),
          signIn = (0, react.useMemo)(
            () =>
              adapter && "signIn" in adapter
                ? async (input) => adapter.signIn(input)
                : void 0,
            [adapter]
          ),
          handleConnect = (0, react.useCallback)(async () => {
            if (
              !(
                isConnectingRef.current ||
                isDisconnectingRef.current ||
                wallet?.adapter.connected
              )
            ) {
              if (!wallet)
                throw handleErrorRef.current(new WalletNotSelectedError());
              var { adapter, readyState } = wallet;
              if (
                readyState !== esm_adapter.Ok.Installed &&
                readyState !== esm_adapter.Ok.Loadable
              )
                throw handleErrorRef.current(new errors.AE(), adapter);
              (isConnectingRef.current = !0), setConnecting(!0);
              try {
                await adapter.connect();
              } catch (e) {
                throw (onConnectError(), e);
              } finally {
                setConnecting(!1), (isConnectingRef.current = !1);
              }
            }
          }, [onConnectError, wallet]),
          handleDisconnect = (0, react.useCallback)(async () => {
            if (!isDisconnectingRef.current && adapter) {
              (isDisconnectingRef.current = !0), setDisconnecting(!0);
              try {
                await adapter.disconnect();
              } finally {
                setDisconnecting(!1), (isDisconnectingRef.current = !1);
              }
            }
          }, [adapter]);
        return react.createElement(
          useWallet.b.Provider,
          {
            value: {
              autoConnect: !!onAutoConnectRequest,
              wallets: wallets,
              wallet: wallet,
              publicKey: publicKey,
              connected: connected,
              connecting: connecting,
              disconnecting: disconnecting,
              select: onSelectWallet,
              connect: handleConnect,
              disconnect: handleDisconnect,
              sendTransaction: sendTransaction,
              signTransaction: signTransaction,
              signAllTransactions: signAllTransactions,
              signMessage: signMessage,
              signIn: signIn,
            },
          },
          children
        );
      }
      let _userAgent;
      function getIsMobile(adapters) {
        return (
          (function getEnvironment({ adapters, userAgentString }) {
            return !adapters.some(
              (adapter) =>
                adapter.name !== SolanaMobileWalletAdapterWalletName &&
                adapter.readyState === esm_adapter.Ok.Installed
            ) &&
              userAgentString &&
              /android/i.test(userAgentString) &&
              !(function isWebView(userAgentString) {
                return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(
                  userAgentString
                );
              })(userAgentString)
              ? Environment.MOBILE_WEB
              : Environment.DESKTOP_WEB;
          })({
            adapters: adapters,
            userAgentString: (function getUserAgent() {
              return (_userAgent =
                void 0 === _userAgent
                  ? globalThis.navigator?.userAgent ?? null
                  : _userAgent);
            })(),
          }) === Environment.MOBILE_WEB
        );
      }
    },
    1089: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        E: () => ConnectionContext,
        w: () =>
          function useConnection() {
            return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              ConnectionContext
            );
          },
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3696);
      const ConnectionContext = (0,
      react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});
    },
    3712: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        b: () => WalletContext,
        v: () =>
          function useWallet() {
            return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              WalletContext
            );
          },
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3696);
      const EMPTY_ARRAY = [];
      __webpack_exports__ = {
        autoConnect: !1,
        connecting: !1,
        connected: !1,
        disconnecting: !1,
        select() {
          logMissingProviderError("call", "select");
        },
        connect() {
          return Promise.reject(logMissingProviderError("call", "connect"));
        },
        disconnect() {
          return Promise.reject(logMissingProviderError("call", "disconnect"));
        },
        sendTransaction() {
          return Promise.reject(
            logMissingProviderError("call", "sendTransaction")
          );
        },
        signTransaction() {
          return Promise.reject(
            logMissingProviderError("call", "signTransaction")
          );
        },
        signAllTransactions() {
          return Promise.reject(
            logMissingProviderError("call", "signAllTransactions")
          );
        },
        signMessage() {
          return Promise.reject(logMissingProviderError("call", "signMessage"));
        },
        signIn() {
          return Promise.reject(logMissingProviderError("call", "signIn"));
        },
      };
      function logMissingProviderError(action, property) {
        action = new Error(
          `You have tried to ${action} "${property}" on a WalletContext without providing one. ` +
            "Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext."
        );
        return console.error(action), action;
      }
      Object.defineProperty(__webpack_exports__, "wallets", {
        get() {
          return logMissingProviderError("read", "wallets"), EMPTY_ARRAY;
        },
      }),
        Object.defineProperty(__webpack_exports__, "wallet", {
          get() {
            return logMissingProviderError("read", "wallet"), null;
          },
        }),
        Object.defineProperty(__webpack_exports__, "publicKey", {
          get() {
            return logMissingProviderError("read", "publicKey"), null;
          },
        });
      const WalletContext = (0,
      react__WEBPACK_IMPORTED_MODULE_0__.createContext)(__webpack_exports__);
    },
    6278: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        d: () => SolflareWalletAdapter,
      });
      var __webpack_exports__ = __webpack_require__(1594),
        adapter = __webpack_require__(4045),
        errors = __webpack_require__(2631),
        esm_transaction = __webpack_require__(7158),
        index_browser_esm = __webpack_require__(8769),
        __classPrivateFieldSet = function (receiver, state, value, kind, f) {
          if ("m" === kind)
            throw new TypeError("Private method is not writable");
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return (
              "a" === kind
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        },
        __classPrivateFieldGet = function (receiver, state, kind, f) {
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return "m" === kind
              ? f
              : "a" === kind
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        };
      function registerWallet(wallet) {
        const callback = ({ register }) => register(wallet);
        try {
          window.dispatchEvent(new RegisterWalletEvent(callback));
        } catch (error) {
          console.error(
            "wallet-standard:register-wallet event could not be dispatched\n",
            error
          );
        }
        try {
          window.addEventListener(
            "wallet-standard:app-ready",
            ({ detail: api }) => callback(api)
          );
        } catch (error) {
          console.error(
            "wallet-standard:app-ready event listener could not be added\n",
            error
          );
        }
      }
      class RegisterWalletEvent extends Event {
        constructor(callback) {
          super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1,
          }),
            _RegisterWalletEvent_detail.set(this, void 0),
            __classPrivateFieldSet(
              this,
              _RegisterWalletEvent_detail,
              callback,
              "f"
            );
        }
        get detail() {
          return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, "f");
        }
        get type() {
          return "wallet-standard:register-wallet";
        }
        preventDefault() {
          throw new Error("preventDefault cannot be called");
        }
        stopImmediatePropagation() {
          throw new Error("stopImmediatePropagation cannot be called");
        }
        stopPropagation() {
          throw new Error("stopPropagation cannot be called");
        }
      }
      var _RegisterWalletEvent_detail = new WeakMap(),
        esm = __webpack_require__(6265),
        signAndSendTransaction = __webpack_require__(8282),
        signTransaction = __webpack_require__(8448),
        signMessage = __webpack_require__(6848),
        connect = __webpack_require__(8585),
        disconnect = __webpack_require__(4293),
        events = __webpack_require__(4010);
      var _SolflareMetaMaskWallet_instances,
        _SolflareMetaMaskWallet_listeners,
        _SolflareMetaMaskWallet_version,
        _SolflareMetaMaskWallet_name,
        _SolflareMetaMaskWallet_icon,
        _SolflareMetaMaskWallet_solflareMetaMask,
        _SolflareMetaMaskWallet_on,
        _SolflareMetaMaskWallet_emit,
        _SolflareMetaMaskWallet_off,
        _SolflareMetaMaskWallet_connect,
        _SolflareMetaMaskWallet_disconnect,
        _SolflareMetaMaskWallet_signAndSendTransaction,
        _SolflareMetaMaskWallet_signTransaction,
        _SolflareMetaMaskWallet_signMessage,
        wallet_classPrivateFieldGet = function (receiver, state, kind, f) {
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return "m" === kind
              ? f
              : "a" === kind
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        },
        wallet_classPrivateFieldSet = function (
          receiver,
          state,
          value,
          kind,
          f
        ) {
          if ("m" === kind)
            throw new TypeError("Private method is not writable");
          if ("a" === kind && !f)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if (
            "function" == typeof state
              ? receiver === state && f
              : state.has(receiver)
          )
            return (
              "a" === kind
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        };
      class SolflareMetaMaskWallet {
        constructor() {
          _SolflareMetaMaskWallet_instances.add(this),
            _SolflareMetaMaskWallet_listeners.set(this, {}),
            _SolflareMetaMaskWallet_version.set(this, "1.0.0"),
            _SolflareMetaMaskWallet_name.set(this, "MetaMask"),
            _SolflareMetaMaskWallet_icon.set(
              this,
              "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4="
            ),
            _SolflareMetaMaskWallet_solflareMetaMask.set(this, null),
            _SolflareMetaMaskWallet_on.set(
              this,
              (event, listener) => (
                wallet_classPrivateFieldGet(
                  this,
                  _SolflareMetaMaskWallet_listeners,
                  "f"
                )[event]?.push(listener) ||
                  (wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_listeners,
                    "f"
                  )[event] = [listener]),
                () =>
                  wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_instances,
                    "m",
                    _SolflareMetaMaskWallet_off
                  ).call(this, event, listener)
              )
            ),
            _SolflareMetaMaskWallet_connect.set(this, async () => {
              if (
                !wallet_classPrivateFieldGet(
                  this,
                  _SolflareMetaMaskWallet_solflareMetaMask,
                  "f"
                )
              ) {
                let SolflareMetaMaskClass;
                try {
                  SolflareMetaMaskClass = (
                    await __webpack_require__
                      .e(879)
                      .then(__webpack_require__.bind(__webpack_require__, 7879))
                  ).default;
                } catch (error) {
                  throw new Error("Unable to load Solflare MetaMask SDK");
                }
                wallet_classPrivateFieldSet(
                  this,
                  _SolflareMetaMaskWallet_solflareMetaMask,
                  new SolflareMetaMaskClass(),
                  "f"
                ),
                  wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  ).on("standard_change", (properties) =>
                    wallet_classPrivateFieldGet(
                      this,
                      _SolflareMetaMaskWallet_instances,
                      "m",
                      _SolflareMetaMaskWallet_emit
                    ).call(this, "change", properties)
                  );
              }
              return (
                this.accounts.length ||
                  (await wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  ).connect()),
                { accounts: this.accounts }
              );
            }),
            _SolflareMetaMaskWallet_disconnect.set(this, async () => {
              wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_solflareMetaMask,
                "f"
              ) &&
                (await wallet_classPrivateFieldGet(
                  this,
                  _SolflareMetaMaskWallet_solflareMetaMask,
                  "f"
                ).disconnect());
            }),
            _SolflareMetaMaskWallet_signAndSendTransaction.set(
              this,
              async (...inputs) => {
                if (
                  wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  )
                )
                  return wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  ).standardSignAndSendTransaction(...inputs);
                throw new errors.kW();
              }
            ),
            _SolflareMetaMaskWallet_signTransaction.set(
              this,
              async (...inputs) => {
                if (
                  wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  )
                )
                  return wallet_classPrivateFieldGet(
                    this,
                    _SolflareMetaMaskWallet_solflareMetaMask,
                    "f"
                  ).standardSignTransaction(...inputs);
                throw new errors.kW();
              }
            ),
            _SolflareMetaMaskWallet_signMessage.set(this, async (...inputs) => {
              if (
                wallet_classPrivateFieldGet(
                  this,
                  _SolflareMetaMaskWallet_solflareMetaMask,
                  "f"
                )
              )
                return wallet_classPrivateFieldGet(
                  this,
                  _SolflareMetaMaskWallet_solflareMetaMask,
                  "f"
                ).standardSignMessage(...inputs);
              throw new errors.kW();
            });
        }
        get version() {
          return wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_version,
            "f"
          );
        }
        get name() {
          return wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_name,
            "f"
          );
        }
        get icon() {
          return wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_icon,
            "f"
          );
        }
        get chains() {
          return [esm.CE, esm.sE, esm.re];
        }
        get features() {
          return {
            [connect.u]: {
              version: "1.0.0",
              connect: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_connect,
                "f"
              ),
            },
            [disconnect.w]: {
              version: "1.0.0",
              disconnect: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_disconnect,
                "f"
              ),
            },
            [events.j]: {
              version: "1.0.0",
              on: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_on,
                "f"
              ),
            },
            [signAndSendTransaction.R]: {
              version: "1.0.0",
              supportedTransactionVersions: ["legacy", 0],
              signAndSendTransaction: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_signAndSendTransaction,
                "f"
              ),
            },
            [signTransaction.q]: {
              version: "1.0.0",
              supportedTransactionVersions: ["legacy", 0],
              signTransaction: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_signTransaction,
                "f"
              ),
            },
            [signMessage.F]: {
              version: "1.0.0",
              signMessage: wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_signMessage,
                "f"
              ),
            },
          };
        }
        get accounts() {
          return wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_solflareMetaMask,
            "f"
          )
            ? wallet_classPrivateFieldGet(
                this,
                _SolflareMetaMaskWallet_solflareMetaMask,
                "f"
              ).standardAccounts
            : [];
        }
      }
      (_SolflareMetaMaskWallet_listeners = new WeakMap()),
        (_SolflareMetaMaskWallet_version = new WeakMap()),
        (_SolflareMetaMaskWallet_name = new WeakMap()),
        (_SolflareMetaMaskWallet_icon = new WeakMap()),
        (_SolflareMetaMaskWallet_solflareMetaMask = new WeakMap()),
        (_SolflareMetaMaskWallet_on = new WeakMap()),
        (_SolflareMetaMaskWallet_connect = new WeakMap()),
        (_SolflareMetaMaskWallet_disconnect = new WeakMap()),
        (_SolflareMetaMaskWallet_signAndSendTransaction = new WeakMap()),
        (_SolflareMetaMaskWallet_signTransaction = new WeakMap()),
        (_SolflareMetaMaskWallet_signMessage = new WeakMap()),
        (_SolflareMetaMaskWallet_instances = new WeakSet()),
        (_SolflareMetaMaskWallet_emit = function _SolflareMetaMaskWallet_emit(
          event,
          ...args
        ) {
          wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_listeners,
            "f"
          )[event]?.forEach((listener) => listener.apply(null, args));
        });
      let registered = !(_SolflareMetaMaskWallet_off =
        function _SolflareMetaMaskWallet_off(event, listener) {
          wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_listeners,
            "f"
          )[event] = wallet_classPrivateFieldGet(
            this,
            _SolflareMetaMaskWallet_listeners,
            "f"
          )[event]?.filter((existingListener) => listener !== existingListener);
        });
      async function detectAndRegisterSolflareMetaMaskWallet() {
        const id = "solflare-detect-metamask";
        function postMessage() {
          window.postMessage(
            {
              target: "metamask-contentscript",
              data: {
                name: "metamask-provider",
                data: { id: id, jsonrpc: "2.0", method: "wallet_getSnaps" },
              },
            },
            window.location.origin
          );
        }
        function onMessage(event) {
          event = event.data;
          "metamask-inpage" === event?.target &&
            "metamask-provider" === event.data?.name &&
            (event.data.data?.id === id
              ? (window.removeEventListener("message", onMessage),
                event.data.data.error ||
                  (function register() {
                    registered ||
                      (registerWallet(new SolflareMetaMaskWallet()),
                      (registered = !0));
                  })())
              : postMessage());
        }
        window.addEventListener("message", onMessage),
          window.setTimeout(
            () => window.removeEventListener("message", onMessage),
            5e3
          ),
          postMessage();
      }
      class SolflareWalletAdapter extends __webpack_exports__.DE {
        constructor(config = {}) {
          super(),
            (this.name = "Solflare"),
            (this.url = "https://solflare.com"),
            (this.icon =
              "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+"),
            (this.supportedTransactionVersions = new Set(["legacy", 0])),
            (this._readyState =
              "undefined" == typeof window || "undefined" == typeof document
                ? adapter.Ok.Unsupported
                : adapter.Ok.Loadable),
            (this._disconnected = () => {
              var wallet = this._wallet;
              wallet &&
                (wallet.off("disconnect", this._disconnected),
                (this._wallet = null),
                (this._publicKey = null),
                this.emit("error", new errors.PQ()),
                this.emit("disconnect"));
            }),
            (this._accountChanged = (newPublicKey) => {
              if (newPublicKey) {
                var publicKey = this._publicKey;
                if (publicKey) {
                  try {
                    newPublicKey = new index_browser_esm.J3(
                      newPublicKey.toBytes()
                    );
                  } catch (error) {
                    return void this.emit(
                      "error",
                      new errors.Kd(error?.message, error)
                    );
                  }
                  publicKey.equals(newPublicKey) ||
                    ((this._publicKey = newPublicKey),
                    this.emit("connect", newPublicKey));
                }
              }
            }),
            (this._connecting = !1),
            (this._publicKey = null),
            (this._wallet = null),
            (this._config = config),
            this._readyState !== adapter.Ok.Unsupported &&
              ((0, adapter.qG)(
                () =>
                  !(
                    (!window.solflare?.isSolflare && !window.SolflareApp) ||
                    ((this._readyState = adapter.Ok.Installed),
                    this.emit("readyStateChange", this._readyState),
                    0)
                  )
              ),
              detectAndRegisterSolflareMetaMaskWallet());
        }
        get publicKey() {
          return this._publicKey;
        }
        get connecting() {
          return this._connecting;
        }
        get connected() {
          return !!this._wallet?.connected;
        }
        get readyState() {
          return this._readyState;
        }
        async autoConnect() {
          (this.readyState === adapter.Ok.Loadable && (0, adapter.Br)()) ||
            (await this.connect());
        }
        async connect() {
          try {
            if (!this.connected && !this.connecting) {
              if (
                this._readyState !== adapter.Ok.Loadable &&
                this._readyState !== adapter.Ok.Installed
              )
                throw new errors.AE();
              var url, ref;
              if (this.readyState === adapter.Ok.Loadable && (0, adapter.Br)())
                (url = encodeURIComponent(window.location.href)),
                  (ref = encodeURIComponent(window.location.origin)),
                  (window.location.href =
                    `https://solflare.com/ul/v1/browse/${url}?ref=` + ref);
              else {
                let SolflareClass;
                try {
                  SolflareClass = (
                    await __webpack_require__
                      .e(544)
                      .then(__webpack_require__.bind(__webpack_require__, 7544))
                  ).default;
                } catch (error) {
                  throw new errors.Sz(error?.message, error);
                }
                let wallet;
                try {
                  wallet = new SolflareClass({ network: this._config.network });
                } catch (error) {
                  throw new errors.Ez(error?.message, error);
                }
                if (((this._connecting = !0), !wallet.connected))
                  try {
                    await wallet.connect();
                  } catch (error) {
                    throw new errors.Y6(error?.message, error);
                  }
                if (!wallet.publicKey) throw new errors.Y6();
                let publicKey;
                try {
                  publicKey = new index_browser_esm.J3(
                    wallet.publicKey.toBytes()
                  );
                } catch (error) {
                  throw new errors.Kd(error?.message, error);
                }
                wallet.on("disconnect", this._disconnected),
                  wallet.on("accountChanged", this._accountChanged),
                  (this._wallet = wallet),
                  (this._publicKey = publicKey),
                  this.emit("connect", publicKey);
              }
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          } finally {
            this._connecting = !1;
          }
        }
        async disconnect() {
          var wallet = this._wallet;
          if (wallet) {
            wallet.off("disconnect", this._disconnected),
              wallet.off("accountChanged", this._accountChanged),
              (this._wallet = null),
              (this._publicKey = null);
            try {
              await wallet.disconnect();
            } catch (error) {
              this.emit("error", new errors.Y8(error?.message, error));
            }
          }
          this.emit("disconnect");
        }
        async sendTransaction(transaction, connection, options = {}) {
          try {
            var wallet = this._wallet;
            if (!wallet) throw new errors.kW();
            try {
              const { signers, ...sendOptions } = options;
              return (
                (0, esm_transaction.Y)(transaction)
                  ? signers?.length && transaction.sign(signers)
                  : ((transaction = await this.prepareTransaction(
                      transaction,
                      connection,
                      sendOptions
                    )),
                    signers?.length && transaction.partialSign(...signers)),
                (sendOptions.preflightCommitment =
                  sendOptions.preflightCommitment || connection.commitment),
                await wallet.signAndSendTransaction(transaction, sendOptions)
              );
            } catch (error) {
              if (error instanceof errors.m7) throw error;
              throw new errors.UF(error?.message, error);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signTransaction(transaction) {
          try {
            var wallet = this._wallet;
            if (!wallet) throw new errors.kW();
            try {
              return (await wallet.signTransaction(transaction)) || transaction;
            } catch (error) {
              throw new errors.z4(error?.message, error);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signAllTransactions(transactions) {
          try {
            var wallet = this._wallet;
            if (!wallet) throw new errors.kW();
            try {
              return (
                (await wallet.signAllTransactions(transactions)) || transactions
              );
            } catch (error) {
              throw new errors.z4(error?.message, error);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signMessage(message) {
          try {
            var wallet = this._wallet;
            if (!wallet) throw new errors.kW();
            try {
              return await wallet.signMessage(message, "utf8");
            } catch (error) {
              throw new errors.K3(error?.message, error);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
      }
    },
    8075: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        G: () => TorusWalletAdapter,
      });
      var __webpack_exports__ = __webpack_require__(1594),
        _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(4045),
        _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(2631),
        _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(8769);
      class TorusWalletAdapter extends __webpack_exports__.DE {
        constructor(
          { params = { showTorusButton: !1 } } = {
            params: { showTorusButton: !1 },
          }
        ) {
          super(),
            (this.name = "Torus"),
            (this.url = "https://tor.us"),
            (this.icon =
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K"),
            (this.supportedTransactionVersions = null),
            (this._readyState =
              "undefined" == typeof window || "undefined" == typeof document
                ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                    .Unsupported
                : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                    .Loadable),
            (this._connecting = !1),
            (this._wallet = null),
            (this._publicKey = null),
            (this._params = params);
        }
        get publicKey() {
          return this._publicKey;
        }
        get connecting() {
          return this._connecting;
        }
        get connected() {
          return !!this._wallet?.isLoggedIn;
        }
        get readyState() {
          return this._readyState;
        }
        async connect() {
          try {
            if (!this.connected && !this.connecting) {
              if (
                this._readyState !==
                _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.Ok
                  .Loadable
              )
                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.AE();
              this._connecting = !0;
              let TorusClass;
              try {
                TorusClass = (
                  await Promise.all([
                    __webpack_require__.e(449),
                    __webpack_require__.e(394),
                    __webpack_require__.e(22),
                  ]).then(__webpack_require__.bind(__webpack_require__, 8394))
                ).default;
              } catch (error) {
                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Sz(
                  error?.message,
                  error
                );
              }
              let wallet;
              try {
                wallet = window.torus || new TorusClass();
              } catch (error) {
                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Ez(
                  error?.message,
                  error
                );
              }
              if (!wallet.isInitialized)
                try {
                  await wallet.init(this._params);
                } catch (error) {
                  throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Y6(
                    error?.message,
                    error
                  );
                }
              let accounts;
              try {
                accounts = await wallet.login();
              } catch (error) {
                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.fk(
                  error?.message,
                  error
                );
              }
              let publicKey;
              try {
                publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.J3(
                  accounts[0]
                );
              } catch (error) {
                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Kd(
                  error?.message,
                  error
                );
              }
              (this._wallet = wallet),
                (this._publicKey = publicKey),
                this.emit("connect", publicKey);
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          } finally {
            this._connecting = !1;
          }
        }
        async disconnect() {
          var wallet = this._wallet;
          if (wallet) {
            (this._wallet = null), (this._publicKey = null);
            try {
              wallet.isLoggedIn && (await wallet.cleanUp());
            } catch (error) {
              this.emit(
                "error",
                new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.Y8(
                  error?.message,
                  error
                )
              );
            }
          }
          this.emit("disconnect");
        }
        async sendTransaction(transaction, connection, options = {}) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              const { signers, ...sendOptions } = options;
              (transaction = await this.prepareTransaction(
                transaction,
                connection,
                sendOptions
              )),
                signers?.length && transaction.partialSign(...signers),
                (sendOptions.preflightCommitment =
                  sendOptions.preflightCommitment || connection.commitment);
              var signature = (
                await wallet.signAndSendTransaction(transaction, sendOptions)
              )["signature"];
              return signature;
            } catch (error) {
              if (
                error instanceof
                _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.m7
              )
                throw error;
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.UF(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signTransaction(transaction) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              return (await wallet.signTransaction(transaction)) || transaction;
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.z4(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signAllTransactions(transactions) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              return (
                (await wallet.signAllTransactions(transactions)) || transactions
              );
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.z4(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
        async signMessage(message) {
          try {
            var wallet = this._wallet;
            if (!wallet)
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.kW();
            try {
              return await wallet.signMessage(message);
            } catch (error) {
              throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.K3(
                error?.message,
                error
              );
            }
          } catch (error) {
            throw (this.emit("error", error), error);
          }
        }
      }
    },
    6265: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        CE: () => SOLANA_MAINNET_CHAIN,
        g4: () => SOLANA_LOCALNET_CHAIN,
        re: () => SOLANA_TESTNET_CHAIN,
        sE: () => SOLANA_DEVNET_CHAIN,
      });
      const SOLANA_MAINNET_CHAIN = "solana:mainnet",
        SOLANA_DEVNET_CHAIN = "solana:devnet",
        SOLANA_TESTNET_CHAIN = "solana:testnet",
        SOLANA_LOCALNET_CHAIN = "solana:localnet";
      SOLANA_MAINNET_CHAIN,
        SOLANA_DEVNET_CHAIN,
        SOLANA_TESTNET_CHAIN,
        SOLANA_LOCALNET_CHAIN;
    },
    8282: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        R: () => SolanaSignAndSendTransaction,
      });
      const SolanaSignAndSendTransaction = "solana:signAndSendTransaction";
    },
    6848: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        F: () => SolanaSignMessage,
      });
      const SolanaSignMessage = "solana:signMessage";
    },
    8448: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        q: () => SolanaSignTransaction,
      });
      const SolanaSignTransaction = "solana:signTransaction";
    },
    8585: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, { u: () => StandardConnect });
      const StandardConnect = "standard:connect";
    },
    4293: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        w: () => StandardDisconnect,
      });
      const StandardDisconnect = "standard:disconnect";
    },
    4010: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, { j: () => StandardEvents });
      const StandardEvents = "standard:events";
    },
    5467: (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__
    ) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        N9: () =>
          function Q(t) {
            let o = { ...q, ...t };
            const s = t.stacked,
              [a, r] = (0, react.useState)(!0),
              c = (0, react.useRef)(null),
              { getToastToRender: d, isToastActive: m, count: f } = L(o),
              { className: g, style: y, rtl: v, containerId: h } = o;
            function E() {
              s && (r(!0), B.play());
            }
            return (
              O(() => {
                if (s) {
                  var e;
                  const t = c.current.querySelectorAll('[data-in="true"]'),
                    s = null == (e = o.position) ? void 0 : e.includes("top");
                  let r = 0,
                    i = 0;
                  Array.from(t)
                    .reverse()
                    .forEach((e, t) => {
                      e.classList.add("Toastify__toast--stacked"),
                        0 < t && (e.dataset.collapsed = "" + a),
                        e.dataset.pos || (e.dataset.pos = s ? "top" : "bot"),
                        (t = r * (a ? 0.2 : 1) + (a ? 0 : 12 * t));
                      e.style.setProperty("--y", `${s ? t : -1 * t}px`),
                        e.style.setProperty("--g", "12"),
                        e.style.setProperty("--s", "" + (1 - (a ? i : 0))),
                        (r += e.offsetHeight),
                        (i += 0.025);
                    });
                }
              }, [a, f, s]),
              react.createElement(
                "div",
                {
                  ref: c,
                  className: "Toastify",
                  id: h,
                  onMouseEnter: () => {
                    s && (r(!1), B.pause());
                  },
                  onMouseLeave: E,
                },
                d((t, n) => {
                  var o = n.length ? { ...y } : { ...y, pointerEvents: "none" };
                  return react.createElement(
                    "div",
                    {
                      className: (function T(e) {
                        var t = dist_clsx(
                          "Toastify__toast-container",
                          "Toastify__toast-container--" + e,
                          { "Toastify__toast-container--rtl": v }
                        );
                        return u(g)
                          ? g({ position: e, rtl: v, defaultClassName: t })
                          : dist_clsx(t, p(g));
                      })(t),
                      style: o,
                      key: "container-" + t,
                    },
                    n.map((t) => {
                      var { content: t, props: o } = t;
                      return react.createElement(
                        R,
                        {
                          ...o,
                          stacked: s,
                          collapseAll: E,
                          isIn: m(o.toastId, o.containerId),
                          style: o.style,
                          key: "toast-" + o.key,
                        },
                        t
                      );
                    })
                  );
                })
              )
            );
          },
      });
      var react = __webpack_require__(3696);
      const dist_clsx = function clsx() {
          for (var e, f = 0, n = "", o = arguments.length; f < o; f++)
            (e = arguments[f]) &&
              (e = (function r(e) {
                var f,
                  n = "";
                if ("string" == typeof e || "number" == typeof e) n += e;
                else if ("object" == typeof e)
                  if (Array.isArray(e))
                    for (var o = e.length, t = 0; t < o; t++)
                      e[t] && (f = r(e[t])) && (n && (n += " "), (n += f));
                  else for (f in e) e[f] && (n && (n += " "), (n += f));
                return n;
              })(e)) &&
              (n && (n += " "), (n += e));
          return n;
        },
        c = (e) => "number" == typeof e && !isNaN(e),
        d = (e) => "string" == typeof e,
        u = (e) => "function" == typeof e,
        p = (e) => (d(e) || u(e) ? e : null),
        m = (e) => (0, react.isValidElement)(e) || d(e) || u(e) || c(e);
      function g(t) {
        let {
          enter: a,
          exit: r,
          appendPosition: i = !1,
          collapse: l = !0,
          collapseDuration: c = 300,
        } = t;
        return function (t) {
          let {
            children: d,
            position: u,
            preventExitTransition: p,
            done: m,
            nodeRef: g,
            isIn: y,
            playToast: v,
          } = t;
          const h = i ? a + "--" + u : a,
            T = i ? r + "--" + u : r,
            E = (0, react.useRef)(0);
          return (
            (0, react.useLayoutEffect)(() => {
              const e = g.current,
                t = h.split(" "),
                n = (o) => {
                  o.target === g.current &&
                    (v(),
                    e.removeEventListener("animationend", n),
                    e.removeEventListener("animationcancel", n),
                    0 === E.current) &&
                    "animationcancel" !== o.type &&
                    e.classList.remove(...t);
                };
              e.classList.add(...t),
                e.addEventListener("animationend", n),
                e.addEventListener("animationcancel", n);
            }, []),
            (0, react.useEffect)(() => {
              const e = g.current,
                t = () => {
                  e.removeEventListener("animationend", t),
                    l
                      ? (function f(e, t, n) {
                          void 0 === n && (n = 300);
                          const { scrollHeight: o, style: s } = e;
                          requestAnimationFrame(() => {
                            (s.minHeight = "initial"),
                              (s.height = o + "px"),
                              (s.transition = `all ${n}ms`),
                              requestAnimationFrame(() => {
                                (s.height = "0"),
                                  (s.padding = "0"),
                                  (s.margin = "0"),
                                  setTimeout(t, n);
                              });
                          });
                        })(e, m, c)
                      : m();
                };
              y ||
                (p
                  ? t()
                  : ((E.current = 1),
                    (e.className += " " + T),
                    e.addEventListener("animationend", t)));
            }, [y]),
            react.createElement(react.Fragment, null, d)
          );
        };
      }
      function y(e, t) {
        return null != e
          ? {
              content: e.content,
              containerId: e.props.containerId,
              id: e.props.toastId,
              theme: e.props.theme,
              type: e.props.type,
              data: e.props.data || {},
              isLoading: e.props.isLoading,
              icon: e.props.icon,
              status: t,
            }
          : {};
      }
      const v = new Map();
      let h = [];
      const T = new Set(),
        E = (e) => T.forEach((t) => t(e)),
        b = () => 0 < v.size;
      function I(e, t) {
        if (t) return !(null == (t = v.get(t)) || !t.isToastActive(e));
        let o = !1;
        return (
          v.forEach((t) => {
            t.isToastActive(e) && (o = !0);
          }),
          o
        );
      }
      function _(e, t) {
        m(e) &&
          (b() || h.push({ content: e, options: t }),
          v.forEach((n) => {
            n.buildToast(e, t);
          }));
      }
      function C(e, t) {
        v.forEach((n) => {
          (null != t &&
            t.containerId &&
            (null == t ? void 0 : t.containerId) !== n.id) ||
            n.toggle(e, null == t ? void 0 : t.id);
        });
      }
      function L(e) {
        var {
          subscribe: o,
          getSnapshot: s,
          setProps: i,
        } = (0, react.useRef)(
          (function (e) {
            const n = e.containerId || 1;
            return {
              subscribe(o) {
                var s = (function (e, n, o) {
                  let s = 1,
                    r = 0,
                    i = [],
                    l = [],
                    f = [],
                    g = n;
                  const v = new Map(),
                    h = new Set(),
                    T = () => {
                      (f = Array.from(v.values())), h.forEach((e) => e());
                    },
                    E = (e) => {
                      (l = null == e ? [] : l.filter((t) => t !== e)), T();
                    },
                    b = (e) => {
                      var {
                          toastId: n,
                          onOpen: s,
                          updateId: a,
                          children: r,
                        } = e.props,
                        a = null == a;
                      e.staleId && v.delete(e.staleId),
                        v.set(n, e),
                        (l = [...l, e.props.toastId].filter(
                          (t) => t !== e.staleId
                        )),
                        T(),
                        o(y(e, a ? "added" : "updated")),
                        a && u(s) && s((0, react.isValidElement)(r) && r.props);
                    };
                  return {
                    id: e,
                    props: g,
                    observe: (e) => (h.add(e), () => h.delete(e)),
                    toggle: (e, t) => {
                      v.forEach((n) => {
                        (null != t && t !== n.props.toastId) ||
                          (u(n.toggle) && n.toggle(e));
                      });
                    },
                    removeToast: E,
                    toasts: v,
                    clearQueue: () => {
                      (r -= i.length), (i = []);
                    },
                    buildToast: (n, l) => {
                      if (
                        !(() => {
                          var { containerId: n, toastId: o, updateId: s } = l,
                            n = n ? n !== e : 1 !== e,
                            o = v.has(o) && null == s;
                          return n || o;
                        })()
                      ) {
                        const {
                            toastId: f,
                            updateId: h,
                            data: I,
                            staleId: _,
                            delay: C,
                          } = l,
                          L = () => {
                            E(f);
                          },
                          N = null == h;
                        N && r++;
                        var k,
                          w = {
                            ...g,
                            style: g.toastStyle,
                            key: s++,
                            ...Object.fromEntries(
                              Object.entries(l).filter((e) => {
                                var [, e] = e;
                                return null != e;
                              })
                            ),
                            toastId: f,
                            updateId: h,
                            data: I,
                            closeToast: L,
                            isIn: !1,
                            className: p(l.className || g.toastClassName),
                            bodyClassName: p(
                              l.bodyClassName || g.bodyClassName
                            ),
                            progressClassName: p(
                              l.progressClassName || g.progressClassName
                            ),
                            autoClose:
                              !l.isLoading &&
                              ((w = l.autoClose),
                              (k = g.autoClose),
                              !1 === w || (c(w) && 0 < w) ? w : k),
                            deleteToast() {
                              var e = v.get(f),
                                { onClose: n, children: s } = e.props;
                              u(n) &&
                                n((0, react.isValidElement)(s) && s.props),
                                o(y(e, "removed")),
                                v.delete(f),
                                --r < 0 && (r = 0),
                                0 < i.length ? b(i.shift()) : T();
                            },
                          };
                        (w.closeButton = g.closeButton),
                          !1 === l.closeButton || m(l.closeButton)
                            ? (w.closeButton = l.closeButton)
                            : !0 === l.closeButton &&
                              (w.closeButton =
                                !m(g.closeButton) || g.closeButton);
                        let P = n;
                        (0, react.isValidElement)(n) && !d(n.type)
                          ? (P = (0, react.cloneElement)(n, {
                              closeToast: L,
                              toastProps: w,
                              data: I,
                            }))
                          : u(n) &&
                            (P = n({ closeToast: L, toastProps: w, data: I }));
                        const M = { content: P, props: w, staleId: _ };
                        g.limit && 0 < g.limit && r > g.limit && N
                          ? i.push(M)
                          : c(C)
                          ? setTimeout(() => {
                              b(M);
                            }, C)
                          : b(M);
                      }
                    },
                    setProps(e) {
                      g = e;
                    },
                    setToggle: (e, t) => {
                      v.get(e).toggle = t;
                    },
                    isToastActive: (e) => l.some((t) => t === e),
                    getSnapshot: () => (g.newestOnTop ? f.reverse() : f),
                  };
                })(n, e, E);
                v.set(n, s);
                const r = s.observe(o);
                return (
                  h.forEach((e) => _(e.content, e.options)),
                  (h = []),
                  () => {
                    r(), v.delete(n);
                  }
                );
              },
              setProps(e) {
                var t;
                null != (t = v.get(n)) && t.setProps(e);
              },
              getSnapshot() {
                var e;
                return null == (e = v.get(n)) ? void 0 : e.getSnapshot();
              },
            };
          })(e)
        ).current;
        i(e);
        const l = (0, react.useSyncExternalStore)(o, s, s);
        return {
          getToastToRender: function (e) {
            if (!l) return [];
            const t = new Map();
            return (
              l.forEach((e) => {
                var n = e.props["position"];
                t.has(n) || t.set(n, []), t.get(n).push(e);
              }),
              Array.from(t, (t) => e(t[0], t[1]))
            );
          },
          isToastActive: I,
          count: null == l ? void 0 : l.length,
        };
      }
      function N(e) {
        const [t, o] = (0, react.useState)(!1),
          [a, r] = (0, react.useState)(!1),
          l = (0, react.useRef)(null),
          c = (0, react.useRef)({
            start: 0,
            delta: 0,
            removalDistance: 0,
            canCloseOnClick: !0,
            canDrag: !1,
            didMove: !1,
          }).current,
          {
            autoClose: d,
            pauseOnHover: u,
            closeToast: p,
            onClick: m,
            closeOnClick: f,
          } = e;
        var g;
        function h() {
          o(!0);
        }
        function T() {
          o(!1);
        }
        function E(n) {
          var o = l.current;
          c.canDrag &&
            o &&
            ((c.didMove = !0),
            t && T(),
            (c.delta =
              "x" === e.draggableDirection
                ? n.clientX - c.start
                : n.clientY - c.start),
            c.start !== n.clientX && (c.canCloseOnClick = !1),
            (o.style.transform = `translate3d(${
              "x" === e.draggableDirection
                ? c.delta + "px, var(--y)"
                : `0, calc(${c.delta}px + var(--y))`
            },0)`),
            (o.style.opacity =
              "" + (1 - Math.abs(c.delta / c.removalDistance))));
        }
        function b() {
          document.removeEventListener("pointermove", E),
            document.removeEventListener("pointerup", b);
          var t = l.current;
          c.canDrag &&
            c.didMove &&
            t &&
            ((c.canDrag = !1),
            Math.abs(c.delta) > c.removalDistance
              ? (r(!0), e.closeToast(), e.collapseAll())
              : ((t.style.transition = "transform 0.2s, opacity 0.2s"),
                t.style.removeProperty("transform"),
                t.style.removeProperty("opacity")));
        }
        null !=
          (y = v.get(
            (g = { id: e.toastId, containerId: e.containerId, fn: o })
              .containerId || 1
          )) && y.setToggle(g.id, g.fn),
          (0, react.useEffect)(() => {
            if (e.pauseOnFocusLoss)
              return (
                document.hasFocus() || T(),
                window.addEventListener("focus", h),
                window.addEventListener("blur", T),
                () => {
                  window.removeEventListener("focus", h),
                    window.removeEventListener("blur", T);
                }
              );
          }, [e.pauseOnFocusLoss]);
        var y = {
          onPointerDown: function (t) {
            var n;
            (!0 !== e.draggable && e.draggable !== t.pointerType) ||
              ((c.didMove = !1),
              document.addEventListener("pointermove", E),
              document.addEventListener("pointerup", b),
              (n = l.current),
              (c.canCloseOnClick = !0),
              (c.canDrag = !0),
              (n.style.transition = "none"),
              "x" === e.draggableDirection
                ? ((c.start = t.clientX),
                  (c.removalDistance =
                    n.offsetWidth * (e.draggablePercent / 100)))
                : ((c.start = t.clientY),
                  (c.removalDistance =
                    (n.offsetHeight *
                      (80 === e.draggablePercent
                        ? 1.5 * e.draggablePercent
                        : e.draggablePercent)) /
                    100)));
          },
          onPointerUp: function (t) {
            var {
              top: n,
              bottom: o,
              left: s,
              right: a,
            } = l.current.getBoundingClientRect();
            ("touchend" !== t.nativeEvent.type &&
              e.pauseOnHover &&
              t.clientX >= s &&
              t.clientX <= a &&
              t.clientY >= n &&
              t.clientY <= o
              ? T
              : h)();
          },
        };
        return (
          d && u && ((y.onMouseEnter = T), e.stacked || (y.onMouseLeave = h)),
          f &&
            (y.onClick = (e) => {
              m && m(e), c.canCloseOnClick && p();
            }),
          {
            playToast: h,
            pauseToast: T,
            isRunning: t,
            preventExitTransition: a,
            toastRef: l,
            eventHandlers: y,
          }
        );
      }
      function $(t) {
        let {
          delay: n,
          isRunning: o,
          closeToast: s,
          type: a = "default",
          hide: r,
          className: i,
          style: c,
          controlledProgress: d,
          progress: p,
          rtl: m,
          isIn: f,
          theme: g,
        } = t;
        var t = r || (d && 0 === p),
          v = {
            ...c,
            animationDuration: n + "ms",
            animationPlayState: o ? "running" : "paused",
          },
          h =
            (d && (v.transform = `scaleX(${p})`),
            dist_clsx(
              "Toastify__progress-bar",
              d
                ? "Toastify__progress-bar--controlled"
                : "Toastify__progress-bar--animated",
              "Toastify__progress-bar-theme--" + g,
              "Toastify__progress-bar--" + a,
              { "Toastify__progress-bar--rtl": m }
            )),
          h = u(i)
            ? i({ rtl: m, type: a, defaultClassName: h })
            : dist_clsx(h, i),
          E = {
            [d && 1 <= p ? "onTransitionEnd" : "onAnimationEnd"]:
              d && p < 1
                ? null
                : () => {
                    f && s();
                  },
          };
        return react.createElement(
          "div",
          { className: "Toastify__progress-bar--wrp", "data-hidden": t },
          react.createElement("div", {
            className:
              `Toastify__progress-bar--bg Toastify__progress-bar-theme--${g} Toastify__progress-bar--` +
              a,
          }),
          react.createElement("div", {
            role: "progressbar",
            "aria-hidden": t ? "true" : "false",
            "aria-label": "notification timer",
            className: h,
            style: v,
            ...E,
          })
        );
      }
      let w = 1;
      const k = () => "" + w++;
      function M(e, t) {
        return _(e, t), t.toastId;
      }
      function x(e, t) {
        return {
          ...t,
          type: (t && t.type) || e,
          toastId: (function P(e) {
            return e && (d(e.toastId) || c(e.toastId)) ? e.toastId : k();
          })(t),
        };
      }
      function A(e) {
        return (t, n) => M(t, x(e, n));
      }
      function B(e, t) {
        return M(e, x("default", t));
      }
      (B.loading = (e, t) =>
        M(
          e,
          x("default", {
            isLoading: !0,
            autoClose: !1,
            closeOnClick: !1,
            closeButton: !1,
            draggable: !1,
            ...t,
          })
        )),
        (B.promise = function (e, t, n) {
          let o,
            { pending: s, error: a, success: r } = t;
          s &&
            (o = d(s) ? B.loading(s, n) : B.loading(s.render, { ...n, ...s }));
          const i = {
              isLoading: null,
              autoClose: null,
              closeOnClick: null,
              closeButton: null,
              draggable: null,
            },
            l = (e, t, s) => {
              if (null != t)
                return (
                  (e = { type: e, ...i, ...n, data: s }),
                  (t = d(t) ? { render: t } : t),
                  o ? B.update(o, { ...e, ...t }) : B(t.render, { ...e, ...t }),
                  s
                );
              B.dismiss(o);
            },
            c = u(e) ? e() : e;
          return (
            c.then((e) => l("success", r, e)).catch((e) => l("error", a, e)), c
          );
        }),
        (B.success = A("success")),
        (B.info = A("info")),
        (B.error = A("error")),
        (B.warning = A("warning")),
        (B.warn = B.warning),
        (B.dark = (e, t) => M(e, x("default", { theme: "dark", ...t }))),
        (B.dismiss = function (e) {
          !(function (e) {
            var t;
            if (b()) {
              if (null == e || d((t = e)) || c(t))
                v.forEach((t) => {
                  t.removeToast(e);
                });
              else if (e && ("containerId" in e || "id" in e)) {
                const t = v.get(e.containerId);
                t
                  ? t.removeToast(e.id)
                  : v.forEach((t) => {
                      t.removeToast(e.id);
                    });
              }
            } else h = h.filter((t) => null != e && t.options.toastId !== e);
          })(e);
        }),
        (B.clearWaitingQueue = function (e) {
          void 0 === e && (e = {}),
            v.forEach((t) => {
              !t.props.limit ||
                (e.containerId && t.id !== e.containerId) ||
                t.clearQueue();
            });
        }),
        (B.isActive = I),
        (B.update = function (e, t) {
          var s,
            n = ((e, t) => {
              var t = t["containerId"];
              return null == (t = v.get(t || 1)) ? void 0 : t.toasts.get(e);
            })(e, (t = void 0 === t ? {} : t));
          n &&
            (({ props: n, content: s } = n),
            (n = {
              delay: 100,
              ...n,
              ...t,
              toastId: t.toastId || e,
              updateId: k(),
            }).toastId !== e && (n.staleId = e),
            (t = n.render || s),
            delete n.render,
            M(t, n));
        }),
        (B.done = (e) => {
          B.update(e, { progress: 1 });
        }),
        (B.onChange = function (e) {
          return (
            T.add(e),
            () => {
              T.delete(e);
            }
          );
        }),
        (B.play = (e) => C(!0, e)),
        (B.pause = (e) => C(!1, e));
      function S(e, t) {
        return {
          enter: `Toastify--animate Toastify__${e}-enter`,
          exit: `Toastify--animate Toastify__${e}-exit`,
          appendPosition: (t = void 0 === t ? !1 : t),
        };
      }
      const O =
          "undefined" != typeof window
            ? react.useLayoutEffect
            : react.useEffect,
        D = (t) => {
          let { theme: n, type: o, isLoading: s, ...a } = t;
          return react.createElement("svg", {
            viewBox: "0 0 24 24",
            width: "100%",
            height: "100%",
            fill:
              "colored" === n
                ? "currentColor"
                : `var(--toastify-icon-color-${o})`,
            ...a,
          });
        },
        z = {
          info: function (t) {
            return react.createElement(
              D,
              { ...t },
              react.createElement("path", {
                d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
              })
            );
          },
          warning: function (t) {
            return react.createElement(
              D,
              { ...t },
              react.createElement("path", {
                d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
              })
            );
          },
          success: function (t) {
            return react.createElement(
              D,
              { ...t },
              react.createElement("path", {
                d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
              })
            );
          },
          error: function (t) {
            return react.createElement(
              D,
              { ...t },
              react.createElement("path", {
                d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
              })
            );
          },
          spinner: function () {
            return react.createElement("div", {
              className: "Toastify__spinner",
            });
          },
        },
        R = (n) => {
          var {
              isRunning: o,
              preventExitTransition: s,
              toastRef: r,
              eventHandlers: i,
              playToast: c,
            } = N(n),
            {
              closeButton: d,
              children: p,
              autoClose: m,
              onClick: f,
              type: g,
              hideProgressBar: y,
              closeToast: v,
              transition: h,
              position: T,
              className: E,
              style: b,
              bodyClassName: I,
              bodyStyle: _,
              progressClassName: C,
              progressStyle: L,
              updateId: w,
              role: k,
              progress: P,
              rtl: M,
              toastId: x,
              deleteToast: A,
              isIn: B,
              isLoading: O,
              closeOnClick: D,
              theme: R,
            } = n,
            D = dist_clsx(
              "Toastify__toast",
              "Toastify__toast-theme--" + R,
              "Toastify__toast--" + g,
              { "Toastify__toast--rtl": M },
              { "Toastify__toast--close-on-click": D }
            ),
            D = u(E)
              ? E({ rtl: M, position: T, type: g, defaultClassName: D })
              : dist_clsx(D, E),
            E = (function (e) {
              let { theme: n, type: o, isLoading: s, icon: r } = e,
                i = null;
              e = { theme: n, type: o };
              return (
                !1 !== r &&
                  (u(r)
                    ? (i = r({ ...e, isLoading: s }))
                    : (0, react.isValidElement)(r)
                    ? (i = (0, react.cloneElement)(r, e))
                    : s
                    ? (i = z.spinner())
                    : o in z && (i = z[o](e))),
                i
              );
            })(n),
            n = !!P || !m,
            Y = { closeToast: v, type: g, theme: R };
          let q = null;
          return (
            !1 !== d &&
              (q = u(d)
                ? d(Y)
                : (0, react.isValidElement)(d)
                ? (0, react.cloneElement)(d, Y)
                : (function () {
                    let { closeToast: n, theme: o, ariaLabel: s = "close" } = Y;
                    return react.createElement(
                      "button",
                      {
                        className:
                          "Toastify__close-button Toastify__close-button--" + o,
                        type: "button",
                        onClick: (e) => {
                          e.stopPropagation(), n(e);
                        },
                        "aria-label": s,
                      },
                      react.createElement(
                        "svg",
                        { "aria-hidden": "true", viewBox: "0 0 14 16" },
                        react.createElement("path", {
                          fillRule: "evenodd",
                          d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
                        })
                      )
                    );
                  })()),
            react.createElement(
              h,
              {
                isIn: B,
                done: A,
                position: T,
                preventExitTransition: s,
                nodeRef: r,
                playToast: c,
              },
              react.createElement(
                "div",
                {
                  id: x,
                  onClick: f,
                  "data-in": B,
                  className: D,
                  ...i,
                  style: b,
                  ref: r,
                },
                react.createElement(
                  "div",
                  {
                    ...(B && { role: k }),
                    className: u(I)
                      ? I({ type: g })
                      : dist_clsx("Toastify__toast-body", I),
                    style: _,
                  },
                  null != E &&
                    react.createElement(
                      "div",
                      {
                        className: dist_clsx("Toastify__toast-icon", {
                          "Toastify--animate-icon Toastify__zoom-enter": !O,
                        }),
                      },
                      E
                    ),
                  react.createElement("div", null, p)
                ),
                q,
                react.createElement($, {
                  ...(w && !n ? { key: "pb-" + w } : {}),
                  rtl: M,
                  theme: R,
                  delay: m,
                  isRunning: o,
                  isIn: B,
                  closeToast: v,
                  hide: y,
                  type: g,
                  style: L,
                  className: C,
                  controlledProgress: n,
                  progress: P || 0,
                })
              )
            )
          );
        },
        H = g(S("bounce", !0)),
        q =
          (g(S("slide", !0)),
          g(S("zoom")),
          g(S("flip")),
          {
            position: "top-right",
            transition: H,
            autoClose: 5e3,
            closeButton: !0,
            pauseOnHover: !0,
            pauseOnFocusLoss: !0,
            draggable: "touch",
            draggablePercent: 80,
            draggableDirection: "x",
            role: "alert",
            theme: "light",
          });
    },
  },
]);
